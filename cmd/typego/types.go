package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"

	"github.com/repyh3/typego/compiler"
	"github.com/repyh3/typego/internal/linker"
	"github.com/spf13/cobra"
)

var typesFile string

var typesCmd = &cobra.Command{
	Use:   "types [file]",
	Short: "Sync and update TypeGo ambient definitions",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("Syncing TypeGo definitions...")

		dtsPath := filepath.Join(".typego", "types", "go.d.ts")
		if err := os.MkdirAll(filepath.Dir(dtsPath), 0755); err != nil {
			fmt.Printf("Error: %v\n", err)
			return
		}

		// Read existing (target) file first, or create default
		var currentContent []byte
		if existing, err := os.ReadFile(dtsPath); err == nil {
			currentContent = existing
		} else {
			// Create default TypeGo definitions
			currentContent = []byte(`// TypeGo Type Definitions
// Auto-generated by typego types

declare module "go:fmt" {
    export function Println(...args: any[]): void;
    export function Printf(format: string, ...args: any[]): void;
}

declare module "go:os" {
    export function WriteFile(path: string, data: string): void;
}

declare module "go:net/http" {
    export function Get(url: string): { Status: string; StatusCode: number; Body: string };
    export function Fetch(url: string): Promise<{ Status: string; StatusCode: number; Body: string }>;
}

declare module "go:*" {
    const value: any;
    export = value;
}
`)
		}

		// Initialize Fetcher
		fetcher, err := linker.NewFetcher()
		if err != nil {
			fmt.Printf("Failed to init fetcher: %v\n", err)
			return
		}
		defer fetcher.Cleanup()

		// Collect all TypeScript files to scan (deduplicated)
		fileSet := make(map[string]bool)
		if len(args) > 0 {
			// Explicit file provided
			absPath, _ := filepath.Abs(args[0])
			fileSet[absPath] = true
		} else {
			// Recursively find all .ts files in the current project
			err := filepath.WalkDir(".", func(path string, d os.DirEntry, err error) error {
				if err != nil {
					return err
				}

				// Skip common non-source and system directories
				if d.IsDir() {
					name := d.Name()
					if name == "node_modules" || name == ".typego" || name == ".git" || name == ".gemini" {
						return filepath.SkipDir
					}
					return nil
				}

				// Only collect .ts files
				if filepath.Ext(path) == ".ts" {
					absPath, _ := filepath.Abs(path)
					fileSet[absPath] = true
				}
				return nil
			})
			if err != nil {
				fmt.Printf("Error searching for TypeScript files: %v\n", err)
			}
		}

		// Collect unique Go imports from all files
		goImports := make(map[string]bool)
		for file := range fileSet {
			fmt.Printf("ðŸ” Scanning %s...\n", filepath.Base(file))
			res, err := compiler.Compile(file, nil)
			if err != nil {
				// Silently skip - expected during broad scan of potentially non-entrypoint files
			}
			if res != nil {
				for _, imp := range res.Imports {
					if len(imp) > 3 && imp[:3] == "go:" {
						goImports[imp[3:]] = true
					}
				}
			}
		}

		// Generate types for each unique import
		for cleanImp := range goImports {
			fmt.Printf("ðŸ“¦ Generating types for %s...\n", cleanImp)

			if err := fetcher.Get(cleanImp); err != nil {
				fmt.Printf("Warning: Failed to fetch %s: %v\n", cleanImp, err)
				continue
			}

			info, err := linker.Inspect(cleanImp, fetcher.TempDir)
			if err != nil {
				fmt.Printf("Failed to inspect %s: %v\n", cleanImp, err)
				continue
			}

			newTypeBlock := linker.GenerateTypes(info)

			// Additive Merge Logic
			pattern := fmt.Sprintf(`(?s)// MODULE: go:%s.*?// END: go:%s\n`, regexp.QuoteMeta(info.Name), regexp.QuoteMeta(info.Name))
			re := regexp.MustCompile(pattern)

			if re.Match(currentContent) {
				currentContent = re.ReplaceAll(currentContent, []byte(newTypeBlock))
			} else {
				currentContent = append(currentContent, []byte("\n"+newTypeBlock)...)
			}
		}

		if err := os.WriteFile(dtsPath, currentContent, 0644); err != nil {
			fmt.Printf("Error writing types: %v\n", err)
			return
		}

		fmt.Println("âœ… Definitions synced to .typego/types/go.d.ts")
	},
}

func init() {
	rootCmd.AddCommand(typesCmd)
}

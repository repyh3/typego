package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"

	"github.com/repyh3/typego/compiler"
	"github.com/repyh3/typego/internal/linker"
	"github.com/spf13/cobra"
)

var typesFile string

var typesCmd = &cobra.Command{
	Use:   "types [file]",
	Short: "Sync and update TypeGo ambient definitions",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("Syncing TypeGo definitions...")

		dtsPath := filepath.Join(".typego", "types", "go.d.ts")
		if err := os.MkdirAll(filepath.Dir(dtsPath), 0755); err != nil {
			fmt.Printf("Error: %v\n", err)
			return
		}

		// Read existing (target) file first, or create default
		var currentContent []byte
		if existing, err := os.ReadFile(dtsPath); err == nil {
			currentContent = existing
		} else {
			// Create default TypeGo definitions
			currentContent = []byte(`// TypeGo Type Definitions
// Auto-generated by typego types

declare module "go:fmt" {
    export function Println(...args: any[]): void;
    export function Printf(format: string, ...args: any[]): void;
}

declare module "go:os" {
    export function WriteFile(path: string, data: string): void;
}

declare module "go:net/http" {
    export function Get(url: string): { Status: string; StatusCode: number; Body: string };
    export function Fetch(url: string): Promise<{ Status: string; StatusCode: number; Body: string }>;
}

declare module "go:*" {
    const value: any;
    export = value;
}
`)
		}

		// Initialize Fetcher
		fetcher, err := linker.NewFetcher()
		if err != nil {
			fmt.Printf("Failed to init fetcher: %v\n", err)
			return
		}
		defer fetcher.Cleanup()

		// If a file is provided, scan it for imports
		if len(args) > 0 {
			filename := args[0]
			absPath, _ := filepath.Abs(filename)
			fmt.Printf("ðŸ” Scanning %s for imports...\n", absPath)

			res, err := compiler.Compile(absPath, nil)
			if err != nil {
				fmt.Printf("Warning: Scan failed: %v\n", err)
			}

			if res != nil {
				for _, imp := range res.Imports {
					if len(imp) > 3 && imp[:3] == "go:" {
						cleanImp := imp[3:]
						fmt.Printf("ðŸ“¦ Generating types for %s...\n", cleanImp)

						if err := fetcher.Get(cleanImp); err != nil {
							// Ignored
						}

						info, err := linker.Inspect(cleanImp, fetcher.TempDir)
						if err != nil {
							fmt.Printf("Failed to inspect %s: %v\n", cleanImp, err)
							continue
						}

						newTypeBlock := linker.GenerateTypes(info)

						// Additive Merge Logic
						// Regex to find existing block: // MODULE: go:pkg ... // END: go:pkg
						pattern := fmt.Sprintf(`(?s)// MODULE: go:%s.*?// END: go:%s\n`, regexp.QuoteMeta(info.Name), regexp.QuoteMeta(info.Name))
						re := regexp.MustCompile(pattern)

						if re.Match(currentContent) {
							// Replace existing
							currentContent = re.ReplaceAll(currentContent, []byte(newTypeBlock))
						} else {
							// Append
							currentContent = append(currentContent, []byte("\n"+newTypeBlock)...)
						}
					}
				}
			}
		}

		if err := os.WriteFile(dtsPath, currentContent, 0644); err != nil {
			fmt.Printf("Error writing types: %v\n", err)
			return
		}

		fmt.Println("âœ… Definitions synced to .typego/types/go.d.ts")
	},
}

func init() {
	rootCmd.AddCommand(typesCmd)
}

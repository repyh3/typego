package main

import (
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/repyh3/typego/compiler"
	"github.com/repyh3/typego/internal/linker"
	"github.com/spf13/cobra"
)

var typesCmd = &cobra.Command{
	Use:   "types [file]",
	Short: "Sync and update TypeGo ambient definitions",
	Run: func(cmd *cobra.Command, args []string) {
		fmt.Println("Syncing TypeGo definitions...")

		dtsPath := filepath.Join(".typego", "types", "go.d.ts")
		if err := os.MkdirAll(filepath.Dir(dtsPath), 0755); err != nil {
			fmt.Printf("Error: %v\n", err)
			return
		}

		// Read existing (target) file first, or create default
		var currentContent []byte
		if existing, err := os.ReadFile(dtsPath); err == nil {
			currentContent = existing
		} else {
			// Create default TypeGo definitions
			currentContent = []byte(`// TypeGo Type Definitions
// Auto-generated by typego types

declare module "go:sync" {
    export function Spawn(fn: () => void): void;
    export function Sleep(ms: number): Promise<void>;
}

declare module "go:memory" {
    export function makeShared(name: string, size: number): Uint8Array;
}

declare module "go:*" {
    const value: any;
    export = value;
}
`)
		}

		// Initialize Fetcher
		fetcher, err := linker.NewFetcher()
		if err != nil {
			fmt.Printf("Failed to init fetcher: %v\n", err)
			return
		}
		defer fetcher.Cleanup()

		// Collect all TypeScript files to scan (deduplicated)
		fileSet := make(map[string]bool)
		if len(args) > 0 {
			// Explicit file provided
			absPath, _ := filepath.Abs(args[0])
			fileSet[absPath] = true
		} else {
			// Recursively find all .ts files in the current project
			err := filepath.WalkDir(".", func(path string, d os.DirEntry, err error) error {
				if err != nil {
					return err
				}

				// Skip common non-source and system directories
				if d.IsDir() {
					name := d.Name()
					if name == "node_modules" || name == ".typego" || name == ".git" || name == ".gemini" {
						return filepath.SkipDir
					}
					return nil
				}

				// Only collect .ts files
				if filepath.Ext(path) == ".ts" {
					absPath, _ := filepath.Abs(path)
					fileSet[absPath] = true
				}
				return nil
			})
			if err != nil {
				fmt.Printf("Error searching for TypeScript files: %v\n", err)
			}
		}

		// Collect unique Go imports from all files
		goImports := make(map[string]bool)
		for file := range fileSet {
			fmt.Printf("ðŸ” Scanning %s...\n", filepath.Base(file))
			res, _ := compiler.Compile(file, nil)
			if res != nil {
				for _, imp := range res.Imports {
					if strings.HasPrefix(imp, "go:") || strings.HasPrefix(imp, "typego:") {
						// Strip prefix to get clean name (e.g. "fmt" or "memory")
						// actually, we might want to keep the full name for mapping
						goImports[imp] = true
					}
				}
			}
		}

		// Generate types for each unique import
		for imp := range goImports {
			fmt.Printf("ðŸ“¦ Generating types for %s...\n", imp)

			var pkgPath string

			if strings.HasPrefix(imp, "go:") {
				name := imp[3:]
				switch name {
				case "fmt", "os", "net/http", "net/url":
					// Inspect native Go package for high-quality types
					pkgPath = name
				case "sync":
					// Inject hardcoded types for sync (special binding)
					block := `	export function Spawn(fn: () => void): void;
	export function Sleep(ms: number): Promise<void>;
	export function Chan<T = any>(buffer?: number): {
		Send(val: T): void;
		Recv(): T;
		TryRecv(): [T, boolean];
		Close(): void;
	};`
					currentContent = updateTypeBlock(currentContent, imp, block)
					continue
				case "memory":
					// Legacy go:memory
					block := `	export function makeShared(name: string, size: number): { buffer: ArrayBuffer; mutex: any };
	export function Ptr(val: any): any;`
					currentContent = updateTypeBlock(currentContent, imp, block)
					continue
				default:
					pkgPath = name
				}
			} else if strings.HasPrefix(imp, "typego:") {
				name := imp[7:]
				switch name {
				case "memory":
					block := `	export function makeShared(name: string, size: number): { buffer: ArrayBuffer; mutex: any };
	export function stats(): { alloc: number; totalAlloc: number; sys: number; numGC: number };
	export function ptr(val: any): any;`
					currentContent = updateTypeBlock(currentContent, imp, block)
					continue
				case "worker":
					block := `	export class Worker {
		constructor(scriptPath: string);
		postMessage(msg: any): void;
		terminate(): void;
		onmessage: (msg: { data: any }) => void;
	};`
					currentContent = updateTypeBlock(currentContent, imp, block)
					continue
				}
			}

			if pkgPath == "" {
				continue
			}

			// specific internal modules don't need fetching if we are in the repo
			isInternal := strings.HasPrefix(pkgPath, "github.com/repyh3/typego")
			if !isInternal {
				if err := fetcher.Get(pkgPath); err != nil {
					fmt.Printf("Warning: Failed to fetch %s: %v\n", pkgPath, err)
					continue
				}
			}

			info, err := linker.Inspect(pkgPath, fetcher.TempDir)
			if err != nil {
				fmt.Printf("Failed to inspect %s: %v\n", pkgPath, err)
				continue
			}

			// Update ImportPath to match the requested import (e.g. "go:fmt" -> "fmt" so generator adds "go:")
			info.ImportPath = strings.TrimPrefix(imp, "go:")

			newTypeBlock := linker.GenerateTypes(info)

			// Additive Merge Logic
			pattern := fmt.Sprintf(`(?s)// MODULE: %s.*?// END: %s\n`, regexp.QuoteMeta(imp), regexp.QuoteMeta(imp))
			re := regexp.MustCompile(pattern)

			if re.Match(currentContent) {
				currentContent = re.ReplaceAll(currentContent, []byte(newTypeBlock))
			} else {
				currentContent = append(currentContent, []byte("\n"+newTypeBlock)...)
			}
		}

		if err := os.WriteFile(dtsPath, currentContent, 0644); err != nil {
			fmt.Printf("Error writing types: %v\n", err)
			return
		}

		fmt.Println("âœ… Definitions synced to .typego/types/go.d.ts")
	},
}

func init() {
	rootCmd.AddCommand(typesCmd)
}

func updateTypeBlock(content []byte, moduleName, typeDef string) []byte {
	newBlock := fmt.Sprintf("// MODULE: %s\ndeclare module \"%s\" {\n%s\n}\n// END: %s\n", moduleName, moduleName, typeDef, moduleName)
	pattern := fmt.Sprintf(`(?s)// MODULE: %s.*?// END: %s\n`, regexp.QuoteMeta(moduleName), regexp.QuoteMeta(moduleName))
	re := regexp.MustCompile(pattern)

	if re.Match(content) {
		return re.ReplaceAll(content, []byte(newBlock))
	}
	return append(content, []byte("\n"+newBlock)...)
}

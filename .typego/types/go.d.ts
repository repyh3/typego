// TypeGo Type Definitions
// Auto-generated by typego types

declare module "go:sync" {
    export function Spawn(fn: () => void): void;
    export function Sleep(ms: number): Promise<void>;
}

declare module "go:memory" {
    export function makeShared(name: string, size: number): Uint8Array;
}

declare module "go:*" {
    const value: any;
    export = value;
}

// MODULE: go:go:github.com/fatih/color
declare module "go:go:github.com/fatih/color" {
	/**
	 * Color defines a custom color object which is defined by SGR parameters.
	 */
	export interface Color {
		/**
		 * AddRGB is used to chain foreground RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddRGB(r: number, g: number, b: number): Color;
		/**
		 * AddRGB is used to chain background RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddBgRGB(r: number, g: number, b: number): Color;
		/**
		 * Set sets the SGR sequence.
		 */
		Set(): Color;
		/**
		 * SetWriter is used to set the SGR sequence with the given io.Writer. This is
		 * a low-level function, and users should use the higher-level functions, such
		 * as color.Fprint, color.Print, etc.
		 */
		SetWriter(w: io.Writer): Color;
		/**
		 * UnsetWriter resets all escape attributes and clears the output with the give
		 * io.Writer. Usually should be called after SetWriter().
		 */
		UnsetWriter(w: io.Writer): void;
		/**
		 * Add is used to chain SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: Add(color.FgRed, color.Underline).
		 */
		Add(...value: Attribute[]): Color;
		/**
		 * Fprint formats using the default formats for its operands and writes to w.
		 * Spaces are added between operands when neither is a string.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprint(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Print formats using the default formats for its operands and writes to
		 * standard output. Spaces are added between operands when neither is a
		 * string. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Print(...a: any[]): [number, Error | null];
		/**
		 * Fprintf formats according to a format specifier and writes to w.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintf(w: io.Writer, format: string, ...a: any[]): [number, Error | null];
		/**
		 * Printf formats according to a format specifier and writes to standard output.
		 * It returns the number of bytes written and any write error encountered.
		 * This is the standard fmt.Printf() method wrapped with the given color.
		 */
		Printf(format: string, ...a: any[]): [number, Error | null];
		/**
		 * Fprintln formats using the default formats for its operands and writes to w.
		 * Spaces are always added between operands and a newline is appended.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintln(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Println formats using the default formats for its operands and writes to
		 * standard output. Spaces are always added between operands and a newline is
		 * appended. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Println(...a: any[]): [number, Error | null];
		/**
		 * Sprint is just like Print, but returns a string instead of printing it.
		 */
		Sprint(...a: any[]): string;
		/**
		 * Sprintln is just like Println, but returns a string instead of printing it.
		 */
		Sprintln(...a: any[]): string;
		/**
		 * Sprintf is just like Printf, but returns a string instead of printing it.
		 */
		Sprintf(format: string, ...a: any[]): string;
		/**
		 * FprintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprint().
		 */
		FprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Print().
		 */
		PrintFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintf().
		 */
		FprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Printf().
		 */
		PrintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintln().
		 */
		FprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Println().
		 */
		PrintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprint(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output, example:
		 * 
		 * 	put := New(FgYellow).SprintFunc()
		 * 	fmt.Fprintf(color.Output, "This is a %s", put("warning"))
		 */
		SprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintfFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintf(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintlnFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintln(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * DisableColor disables the color output. Useful to not change any existing
		 * code and still being able to output. Can be used for flags like
		 * "--no-color". To enable back use EnableColor() method.
		 */
		DisableColor(): void;
		/**
		 * EnableColor enables the color output. Use it in conjunction with
		 * DisableColor(). Otherwise, this method has no side effects.
		 */
		EnableColor(): void;
		/**
		 * Equals returns a boolean value indicating whether two colors are equal.
		 */
		Equals(c2: Color): boolean;
	}

	/**
	 * New returns a newly created color object.
	 */
	export function New(...value: Attribute[]): Color;
	/**
	 * RGB returns a new foreground color in 24-bit RGB.
	 */
	export function RGB(r: number, g: number, b: number): Color;
	/**
	 * BgRGB returns a new background color in 24-bit RGB.
	 */
	export function BgRGB(r: number, g: number, b: number): Color;
	/**
	 * Set sets the given parameters immediately. It will change the color of
	 * output with the given SGR parameters until color.Unset() is called.
	 */
	export function Set(...p: Attribute[]): Color;
	/**
	 * Unset resets all escape attributes and clears the output. Usually should
	 * be called after Set().
	 */
	export function Unset(): void;
	/**
	 * Black is a convenient helper function to print with black foreground. A
	 * newline is appended to format by default.
	 */
	export function Black(format: string, ...a: any[]): void;
	/**
	 * Red is a convenient helper function to print with red foreground. A
	 * newline is appended to format by default.
	 */
	export function Red(format: string, ...a: any[]): void;
	/**
	 * Green is a convenient helper function to print with green foreground. A
	 * newline is appended to format by default.
	 */
	export function Green(format: string, ...a: any[]): void;
	/**
	 * Yellow is a convenient helper function to print with yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function Yellow(format: string, ...a: any[]): void;
	/**
	 * Blue is a convenient helper function to print with blue foreground. A
	 * newline is appended to format by default.
	 */
	export function Blue(format: string, ...a: any[]): void;
	/**
	 * Magenta is a convenient helper function to print with magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function Magenta(format: string, ...a: any[]): void;
	/**
	 * Cyan is a convenient helper function to print with cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function Cyan(format: string, ...a: any[]): void;
	/**
	 * White is a convenient helper function to print with white foreground. A
	 * newline is appended to format by default.
	 */
	export function White(format: string, ...a: any[]): void;
	/**
	 * BlackString is a convenient helper function to return a string with black
	 * foreground.
	 */
	export function BlackString(format: string, ...a: any[]): string;
	/**
	 * RedString is a convenient helper function to return a string with red
	 * foreground.
	 */
	export function RedString(format: string, ...a: any[]): string;
	/**
	 * GreenString is a convenient helper function to return a string with green
	 * foreground.
	 */
	export function GreenString(format: string, ...a: any[]): string;
	/**
	 * YellowString is a convenient helper function to return a string with yellow
	 * foreground.
	 */
	export function YellowString(format: string, ...a: any[]): string;
	/**
	 * BlueString is a convenient helper function to return a string with blue
	 * foreground.
	 */
	export function BlueString(format: string, ...a: any[]): string;
	/**
	 * MagentaString is a convenient helper function to return a string with magenta
	 * foreground.
	 */
	export function MagentaString(format: string, ...a: any[]): string;
	/**
	 * CyanString is a convenient helper function to return a string with cyan
	 * foreground.
	 */
	export function CyanString(format: string, ...a: any[]): string;
	/**
	 * WhiteString is a convenient helper function to return a string with white
	 * foreground.
	 */
	export function WhiteString(format: string, ...a: any[]): string;
	/**
	 * HiBlack is a convenient helper function to print with hi-intensity black foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlack(format: string, ...a: any[]): void;
	/**
	 * HiRed is a convenient helper function to print with hi-intensity red foreground. A
	 * newline is appended to format by default.
	 */
	export function HiRed(format: string, ...a: any[]): void;
	/**
	 * HiGreen is a convenient helper function to print with hi-intensity green foreground. A
	 * newline is appended to format by default.
	 */
	export function HiGreen(format: string, ...a: any[]): void;
	/**
	 * HiYellow is a convenient helper function to print with hi-intensity yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function HiYellow(format: string, ...a: any[]): void;
	/**
	 * HiBlue is a convenient helper function to print with hi-intensity blue foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlue(format: string, ...a: any[]): void;
	/**
	 * HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function HiMagenta(format: string, ...a: any[]): void;
	/**
	 * HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function HiCyan(format: string, ...a: any[]): void;
	/**
	 * HiWhite is a convenient helper function to print with hi-intensity white foreground. A
	 * newline is appended to format by default.
	 */
	export function HiWhite(format: string, ...a: any[]): void;
	/**
	 * HiBlackString is a convenient helper function to return a string with hi-intensity black
	 * foreground.
	 */
	export function HiBlackString(format: string, ...a: any[]): string;
	/**
	 * HiRedString is a convenient helper function to return a string with hi-intensity red
	 * foreground.
	 */
	export function HiRedString(format: string, ...a: any[]): string;
	/**
	 * HiGreenString is a convenient helper function to return a string with hi-intensity green
	 * foreground.
	 */
	export function HiGreenString(format: string, ...a: any[]): string;
	/**
	 * HiYellowString is a convenient helper function to return a string with hi-intensity yellow
	 * foreground.
	 */
	export function HiYellowString(format: string, ...a: any[]): string;
	/**
	 * HiBlueString is a convenient helper function to return a string with hi-intensity blue
	 * foreground.
	 */
	export function HiBlueString(format: string, ...a: any[]): string;
	/**
	 * HiMagentaString is a convenient helper function to return a string with hi-intensity magenta
	 * foreground.
	 */
	export function HiMagentaString(format: string, ...a: any[]): string;
	/**
	 * HiCyanString is a convenient helper function to return a string with hi-intensity cyan
	 * foreground.
	 */
	export function HiCyanString(format: string, ...a: any[]): string;
	/**
	 * HiWhiteString is a convenient helper function to return a string with hi-intensity white
	 * foreground.
	 */
	export function HiWhiteString(format: string, ...a: any[]): string;
}
// END: go:go:github.com/fatih/color

// MODULE: go:go:net/url
declare module "go:go:net/url" {
	import { Userinfo } from "go:net/url";

	/**
	 * The Userinfo type is an immutable encapsulation of username and
	 * password details for a [URL]. An existing Userinfo value is guaranteed
	 * to have a username set (potentially empty, as allowed by RFC 2396),
	 * and optionally a password.
	 */
	export interface Userinfo {
		/**
		 * Username returns the username.
		 */
		Username(): string;
		/**
		 * Password returns the password in case it is set, and whether it is set.
		 */
		Password(): [string, boolean];
		/**
		 * String returns the encoded userinfo information in the standard form
		 * of "username[:password]".
		 */
		String(): string;
	}

	/**
	 * Error reports an error and the operation and URL that caused it.
	 */
	export interface Error {
		Op: string;
		URL: string;
		Err: Error | null;
		Unwrap(): Error | null;
		Error(): string;
		Timeout(): boolean;
		Temporary(): boolean;
	}

	/**
	 * A URL represents a parsed URL (technically, a URI reference).
	 * 
	 * The general form represented is:
	 * 
	 * 	[scheme:][//[userinfo@]host][/]path[?query][#fragment]
	 * 
	 * URLs that do not start with a slash after the scheme are interpreted as:
	 * 
	 * 	scheme:opaque[?query][#fragment]
	 * 
	 * The Host field contains the host and port subcomponents of the URL.
	 * When the port is present, it is separated from the host with a colon.
	 * When the host is an IPv6 address, it must be enclosed in square brackets:
	 * "[fe80::1]:80". The [net.JoinHostPort] function combines a host and port
	 * into a string suitable for the Host field, adding square brackets to
	 * the host when necessary.
	 * 
	 * Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
	 * A consequence is that it is impossible to tell which slashes in the Path were
	 * slashes in the raw URL and which were %2f. This distinction is rarely important,
	 * but when it is, the code should use the [URL.EscapedPath] method, which preserves
	 * the original encoding of Path.
	 * 
	 * The RawPath field is an optional field which is only set when the default
	 * encoding of Path is different from the escaped path. See the EscapedPath method
	 * for more details.
	 * 
	 * URL's String method uses the EscapedPath method to obtain the path.
	 */
	export interface URL {
		Scheme: string;
		Opaque: string;
		User: Userinfo;
		Host: string;
		Path: string;
		RawPath: string;
		OmitHost: boolean;
		ForceQuery: boolean;
		RawQuery: string;
		Fragment: string;
		RawFragment: string;
		/**
		 * EscapedPath returns the escaped form of u.Path.
		 * In general there are multiple possible escaped forms of any path.
		 * EscapedPath returns u.RawPath when it is a valid escaping of u.Path.
		 * Otherwise EscapedPath ignores u.RawPath and computes an escaped
		 * form on its own.
		 * The [URL.String] and [URL.RequestURI] methods use EscapedPath to construct
		 * their results.
		 * In general, code should call EscapedPath instead of
		 * reading u.RawPath directly.
		 */
		EscapedPath(): string;
		/**
		 * EscapedFragment returns the escaped form of u.Fragment.
		 * In general there are multiple possible escaped forms of any fragment.
		 * EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment.
		 * Otherwise EscapedFragment ignores u.RawFragment and computes an escaped
		 * form on its own.
		 * The [URL.String] method uses EscapedFragment to construct its result.
		 * In general, code should call EscapedFragment instead of
		 * reading u.RawFragment directly.
		 */
		EscapedFragment(): string;
		/**
		 * String reassembles the [URL] into a valid URL string.
		 * The general form of the result is one of:
		 * 
		 * 	scheme:opaque?query#fragment
		 * 	scheme://userinfo@host/path?query#fragment
		 * 
		 * If u.Opaque is non-empty, String uses the first form;
		 * otherwise it uses the second form.
		 * Any non-ASCII characters in host are escaped.
		 * To obtain the path, String uses u.EscapedPath().
		 * 
		 * In the second form, the following rules apply:
		 *   - if u.Scheme is empty, scheme: is omitted.
		 *   - if u.User is nil, userinfo@ is omitted.
		 *   - if u.Host is empty, host/ is omitted.
		 *   - if u.Scheme and u.Host are empty and u.User is nil,
		 *     the entire scheme://userinfo@host/ is omitted.
		 *   - if u.Host is non-empty and u.Path begins with a /,
		 *     the form host/path does not add its own /.
		 *   - if u.RawQuery is empty, ?query is omitted.
		 *   - if u.Fragment is empty, #fragment is omitted.
		 */
		String(): string;
		/**
		 * Redacted is like [URL.String] but replaces any password with "xxxxx".
		 * Only the password in u.User is redacted.
		 */
		Redacted(): string;
		/**
		 * IsAbs reports whether the [URL] is absolute.
		 * Absolute means that it has a non-empty scheme.
		 */
		IsAbs(): boolean;
		/**
		 * Parse parses a [URL] in the context of the receiver. The provided URL
		 * may be relative or absolute. Parse returns nil, err on parse
		 * failure, otherwise its return value is the same as [URL.ResolveReference].
		 */
		Parse(ref: string): [URL, Error | null];
		/**
		 * ResolveReference resolves a URI reference to an absolute URI from
		 * an absolute base URI u, per RFC 3986 Section 5.2. The URI reference
		 * may be relative or absolute. ResolveReference always returns a new
		 * [URL] instance, even if the returned URL is identical to either the
		 * base or reference. If ref is an absolute URL, then ResolveReference
		 * ignores base and returns a copy of ref.
		 */
		ResolveReference(ref: URL): URL;
		/**
		 * Query parses RawQuery and returns the corresponding values.
		 * It silently discards malformed value pairs.
		 * To check errors use [ParseQuery].
		 */
		Query(): Values;
		/**
		 * RequestURI returns the encoded path?query or opaque?query
		 * string that would be used in an HTTP request for u.
		 */
		RequestURI(): string;
		/**
		 * Hostname returns u.Host, stripping any valid port number if present.
		 * 
		 * If the result is enclosed in square brackets, as literal IPv6 addresses are,
		 * the square brackets are removed from the result.
		 */
		Hostname(): string;
		/**
		 * Port returns the port part of u.Host, without the leading colon.
		 * 
		 * If u.Host doesn't contain a valid numeric port, Port returns an empty string.
		 */
		Port(): string;
		MarshalBinary(): [byte[], Error | null];
		AppendBinary(b: byte[]): [byte[], Error | null];
		UnmarshalBinary(text: byte[]): Error | null;
		/**
		 * JoinPath returns a new [URL] with the provided path elements joined to
		 * any existing path and the resulting path cleaned of any ./ or ../ elements.
		 * Any sequences of multiple / characters will be reduced to a single /.
		 */
		JoinPath(...elem: string[]): URL;
	}

	/**
	 * QueryUnescape does the inverse transformation of [QueryEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB.
	 * It returns an error if any % is not followed by two hexadecimal
	 * digits.
	 */
	export function QueryUnescape(s: string): string;
	/**
	 * PathUnescape does the inverse transformation of [PathEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB. It returns an error if any % is not followed
	 * by two hexadecimal digits.
	 * 
	 * PathUnescape is identical to [QueryUnescape] except that it does not
	 * unescape '+' to ' ' (space).
	 */
	export function PathUnescape(s: string): string;
	/**
	 * QueryEscape escapes the string so it can be safely placed
	 * inside a [URL] query.
	 */
	export function QueryEscape(s: string): string;
	/**
	 * PathEscape escapes the string so it can be safely placed inside a [URL] path segment,
	 * replacing special characters (including /) with %XX sequences as needed.
	 */
	export function PathEscape(s: string): string;
	/**
	 * User returns a [Userinfo] containing the provided username
	 * and no password set.
	 */
	export function User(username: string): Userinfo;
	/**
	 * UserPassword returns a [Userinfo] containing the provided username
	 * and password.
	 * 
	 * This functionality should only be used with legacy web sites.
	 * RFC 2396 warns that interpreting Userinfo this way
	 * “is NOT RECOMMENDED, because the passing of authentication
	 * information in clear text (such as URI) has proven to be a
	 * security risk in almost every case where it has been used.”
	 */
	export function UserPassword(username: string, password: string): Userinfo;
	/**
	 * Parse parses a raw url into a [URL] structure.
	 * 
	 * The url may be relative (a path, without a host) or absolute
	 * (starting with a scheme). Trying to parse a hostname and path
	 * without a scheme is invalid but may not necessarily return an
	 * error, due to parsing ambiguities.
	 */
	export function Parse(rawURL: string): URL;
	/**
	 * ParseRequestURI parses a raw url into a [URL] structure. It assumes that
	 * url was received in an HTTP request, so the url is interpreted
	 * only as an absolute URI or an absolute path.
	 * The string url is assumed not to have a #fragment suffix.
	 * (Web browsers strip #fragment before sending the URL to a web server.)
	 */
	export function ParseRequestURI(rawURL: string): URL;
	/**
	 * ParseQuery parses the URL-encoded query string and returns
	 * a map listing the values specified for each key.
	 * ParseQuery always returns a non-nil map containing all the
	 * valid query parameters found; err describes the first decoding error
	 * encountered, if any.
	 * 
	 * Query is expected to be a list of key=value settings separated by ampersands.
	 * A setting without an equals sign is interpreted as a key set to an empty
	 * value.
	 * Settings containing a non-URL-encoded semicolon are considered invalid.
	 */
	export function ParseQuery(query: string): Values;
	/**
	 * JoinPath returns a [URL] string with the provided path elements joined to
	 * the existing path of base and the resulting path cleaned of any ./ or ../ elements.
	 */
	export function JoinPath(base: string, ...elem: string[]): string;
}
// END: go:go:net/url

// MODULE: go:go:net/http
declare module "go:go:net/http" {
	import { ReadCloser } from "go:io";
	import { URL, Values } from "go:net/url";
	import { Form } from "go:mime/multipart";
	import { SameSite, Request, Response, Handler, RoundTripper, CookieJar, HTTP2Config, Protocols, Header } from "go:net/http";
	import { Config, ConnectionState } from "go:crypto/tls";
	import { Duration, Time } from "go:time";
	import { Logger } from "go:log";

	/**
	 * A Server defines parameters for running an HTTP server.
	 * The zero value for Server is a valid configuration.
	 */
	export interface Server {
		Addr: string;
		Handler: Handler;
		DisableGeneralOptionsHandler: boolean;
		TLSConfig: Config;
		ReadTimeout: Duration;
		ReadHeaderTimeout: Duration;
		WriteTimeout: Duration;
		IdleTimeout: Duration;
		MaxHeaderBytes: number;
		TLSNextProto: Record<string, unknown>;
		ConnState: (...args: unknown[]) => unknown;
		ErrorLog: Logger;
		BaseContext: (...args: unknown[]) => unknown;
		ConnContext: (...args: unknown[]) => unknown;
		HTTP2: HTTP2Config;
		Protocols: Protocols;
		/**
		 * Close immediately closes all active net.Listeners and any
		 * connections in state [StateNew], [StateActive], or [StateIdle]. For a
		 * graceful shutdown, use [Server.Shutdown].
		 * 
		 * Close does not attempt to close (and does not even know about)
		 * any hijacked connections, such as WebSockets.
		 * 
		 * Close returns any error returned from closing the [Server]'s
		 * underlying Listener(s).
		 */
		Close(): Error | null;
		/**
		 * Shutdown gracefully shuts down the server without interrupting any
		 * active connections. Shutdown works by first closing all open
		 * listeners, then closing all idle connections, and then waiting
		 * indefinitely for connections to return to idle and then shut down.
		 * If the provided context expires before the shutdown is complete,
		 * Shutdown returns the context's error, otherwise it returns any
		 * error returned from closing the [Server]'s underlying Listener(s).
		 * 
		 * When Shutdown is called, [Serve], [ServeTLS], [ListenAndServe], and
		 * [ListenAndServeTLS] immediately return [ErrServerClosed]. Make sure the
		 * program doesn't exit and waits instead for Shutdown to return.
		 * 
		 * Shutdown does not attempt to close nor wait for hijacked
		 * connections such as WebSockets. The caller of Shutdown should
		 * separately notify such long-lived connections of shutdown and wait
		 * for them to close, if desired. See [Server.RegisterOnShutdown] for a way to
		 * register shutdown notification functions.
		 * 
		 * Once Shutdown has been called on a server, it may not be reused;
		 * future calls to methods such as Serve will return ErrServerClosed.
		 */
		Shutdown(ctx: context.Context): Error | null;
		/**
		 * RegisterOnShutdown registers a function to call on [Server.Shutdown].
		 * This can be used to gracefully shutdown connections that have
		 * undergone ALPN protocol upgrade or that have been hijacked.
		 * This function should start protocol-specific graceful shutdown,
		 * but should not wait for shutdown to complete.
		 */
		RegisterOnShutdown(f: (...args: unknown[]) => unknown): void;
		/**
		 * ListenAndServe listens on the TCP network address s.Addr and then
		 * calls [Serve] to handle requests on incoming connections.
		 * Accepted connections are configured to enable TCP keep-alives.
		 * 
		 * If s.Addr is blank, ":http" is used.
		 * 
		 * ListenAndServe always returns a non-nil error. After [Server.Shutdown] or [Server.Close],
		 * the returned error is [ErrServerClosed].
		 */
		ListenAndServe(): Error | null;
		/**
		 * Serve accepts incoming connections on the Listener l, creating a
		 * new service goroutine for each. The service goroutines read requests and
		 * then call s.Handler to reply to them.
		 * 
		 * HTTP/2 support is only enabled if the Listener returns [*tls.Conn]
		 * connections and they were configured with "h2" in the TLS
		 * Config.NextProtos.
		 * 
		 * Serve always returns a non-nil error and closes l.
		 * After [Server.Shutdown] or [Server.Close], the returned error is [ErrServerClosed].
		 */
		Serve(l: net.Listener): Error | null;
		/**
		 * ServeTLS accepts incoming connections on the Listener l, creating a
		 * new service goroutine for each. The service goroutines perform TLS
		 * setup and then read requests, calling s.Handler to reply to them.
		 * 
		 * Files containing a certificate and matching private key for the
		 * server must be provided if neither the [Server]'s
		 * TLSConfig.Certificates, TLSConfig.GetCertificate nor
		 * config.GetConfigForClient are populated.
		 * If the certificate is signed by a certificate authority, the
		 * certFile should be the concatenation of the server's certificate,
		 * any intermediates, and the CA's certificate.
		 * 
		 * ServeTLS always returns a non-nil error. After [Server.Shutdown] or [Server.Close], the
		 * returned error is [ErrServerClosed].
		 */
		ServeTLS(l: net.Listener, certFile: string, keyFile: string): Error | null;
		/**
		 * SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.
		 * By default, keep-alives are always enabled. Only very
		 * resource-constrained environments or servers in the process of
		 * shutting down should disable them.
		 */
		SetKeepAlivesEnabled(v: boolean): void;
		/**
		 * ListenAndServeTLS listens on the TCP network address s.Addr and
		 * then calls [ServeTLS] to handle requests on incoming TLS connections.
		 * Accepted connections are configured to enable TCP keep-alives.
		 * 
		 * Filenames containing a certificate and matching private key for the
		 * server must be provided if neither the [Server]'s TLSConfig.Certificates
		 * nor TLSConfig.GetCertificate are populated. If the certificate is
		 * signed by a certificate authority, the certFile should be the
		 * concatenation of the server's certificate, any intermediates, and
		 * the CA's certificate.
		 * 
		 * If s.Addr is blank, ":https" is used.
		 * 
		 * ListenAndServeTLS always returns a non-nil error. After [Server.Shutdown] or
		 * [Server.Close], the returned error is [ErrServerClosed].
		 */
		ListenAndServeTLS(certFile: string, keyFile: string): Error | null;
	}

	/**
	 * Transport is an implementation of [RoundTripper] that supports HTTP,
	 * HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).
	 * 
	 * By default, Transport caches connections for future re-use.
	 * This may leave many open connections when accessing many hosts.
	 * This behavior can be managed using [Transport.CloseIdleConnections] method
	 * and the [Transport.MaxIdleConnsPerHost] and [Transport.DisableKeepAlives] fields.
	 * 
	 * Transports should be reused instead of created as needed.
	 * Transports are safe for concurrent use by multiple goroutines.
	 * 
	 * A Transport is a low-level primitive for making HTTP and HTTPS requests.
	 * For high-level functionality, such as cookies and redirects, see [Client].
	 * 
	 * Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2
	 * for HTTPS URLs, depending on whether the server supports HTTP/2,
	 * and how the Transport is configured. The [DefaultTransport] supports HTTP/2.
	 * To explicitly enable HTTP/2 on a transport, set [Transport.Protocols].
	 * 
	 * Responses with status codes in the 1xx range are either handled
	 * automatically (100 expect-continue) or ignored. The one
	 * exception is HTTP status code 101 (Switching Protocols), which is
	 * considered a terminal status and returned by [Transport.RoundTrip]. To see the
	 * ignored 1xx responses, use the httptrace trace package's
	 * ClientTrace.Got1xxResponse.
	 * 
	 * Transport only retries a request upon encountering a network error
	 * if the connection has been already been used successfully and if the
	 * request is idempotent and either has no body or has its [Request.GetBody]
	 * defined. HTTP requests are considered idempotent if they have HTTP methods
	 * GET, HEAD, OPTIONS, or TRACE; or if their [Header] map contains an
	 * "Idempotency-Key" or "X-Idempotency-Key" entry. If the idempotency key
	 * value is a zero-length slice, the request is treated as idempotent but the
	 * header is not sent on the wire.
	 */
	export interface Transport {
		Proxy: (...args: unknown[]) => unknown;
		OnProxyConnectResponse: (...args: unknown[]) => unknown;
		DialContext: (...args: unknown[]) => unknown;
		Dial: (...args: unknown[]) => unknown;
		DialTLSContext: (...args: unknown[]) => unknown;
		DialTLS: (...args: unknown[]) => unknown;
		TLSClientConfig: Config;
		TLSHandshakeTimeout: Duration;
		DisableKeepAlives: boolean;
		DisableCompression: boolean;
		MaxIdleConns: number;
		MaxIdleConnsPerHost: number;
		MaxConnsPerHost: number;
		IdleConnTimeout: Duration;
		ResponseHeaderTimeout: Duration;
		ExpectContinueTimeout: Duration;
		TLSNextProto: Record<string, unknown>;
		ProxyConnectHeader: Header;
		GetProxyConnectHeader: (...args: unknown[]) => unknown;
		MaxResponseHeaderBytes: number;
		WriteBufferSize: number;
		ReadBufferSize: number;
		ForceAttemptHTTP2: boolean;
		HTTP2: HTTP2Config;
		Protocols: Protocols;
		/**
		 * Clone returns a deep copy of t's exported fields.
		 */
		Clone(): Transport;
		/**
		 * RegisterProtocol registers a new protocol with scheme.
		 * The [Transport] will pass requests using the given scheme to rt.
		 * It is rt's responsibility to simulate HTTP request semantics.
		 * 
		 * RegisterProtocol can be used by other packages to provide
		 * implementations of protocol schemes like "ftp" or "file".
		 * 
		 * If rt.RoundTrip returns [ErrSkipAltProtocol], the Transport will
		 * handle the [Transport.RoundTrip] itself for that one request, as if the
		 * protocol were not registered.
		 */
		RegisterProtocol(scheme: string, rt: RoundTripper): void;
		/**
		 * CloseIdleConnections closes any connections which were previously
		 * connected from previous requests but are now sitting idle in
		 * a "keep-alive" state. It does not interrupt any connections currently
		 * in use.
		 */
		CloseIdleConnections(): void;
		/**
		 * CancelRequest cancels an in-flight request by closing its connection.
		 * CancelRequest should only be called after [Transport.RoundTrip] has returned.
		 * 
		 * Deprecated: Use [Request.WithContext] to create a request with a
		 * cancelable context instead. CancelRequest cannot cancel HTTP/2
		 * requests. This may become a no-op in a future release of Go.
		 */
		CancelRequest(req: Request): void;
	}

	/**
	 * A Client is an HTTP client. Its zero value ([DefaultClient]) is a
	 * usable client that uses [DefaultTransport].
	 * 
	 * The [Client.Transport] typically has internal state (cached TCP
	 * connections), so Clients should be reused instead of created as
	 * needed. Clients are safe for concurrent use by multiple goroutines.
	 * 
	 * A Client is higher-level than a [RoundTripper] (such as [Transport])
	 * and additionally handles HTTP details such as cookies and
	 * redirects.
	 * 
	 * When following redirects, the Client will forward all headers set on the
	 * initial [Request] except:
	 * 
	 *   - when forwarding sensitive headers like "Authorization",
	 *     "WWW-Authenticate", and "Cookie" to untrusted targets.
	 *     These headers will be ignored when following a redirect to a domain
	 *     that is not a subdomain match or exact match of the initial domain.
	 *     For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
	 *     will forward the sensitive headers, but a redirect to "bar.com" will not.
	 *   - when forwarding the "Cookie" header with a non-nil cookie Jar.
	 *     Since each redirect may mutate the state of the cookie jar,
	 *     a redirect may possibly alter a cookie set in the initial request.
	 *     When forwarding the "Cookie" header, any mutated cookies will be omitted,
	 *     with the expectation that the Jar will insert those mutated cookies
	 *     with the updated values (assuming the origin matches).
	 *     If Jar is nil, the initial cookies are forwarded without change.
	 */
	export interface Client {
		Transport: RoundTripper;
		CheckRedirect: (...args: unknown[]) => unknown;
		Jar: CookieJar;
		Timeout: Duration;
		/**
		 * Get issues a GET to the specified URL. If the response is one of the
		 * following redirect codes, Get follows the redirect after calling the
		 * [Client.CheckRedirect] function:
		 * 
		 * 	301 (Moved Permanently)
		 * 	302 (Found)
		 * 	303 (See Other)
		 * 	307 (Temporary Redirect)
		 * 	308 (Permanent Redirect)
		 * 
		 * An error is returned if the [Client.CheckRedirect] function fails
		 * or if there was an HTTP protocol error. A non-2xx response doesn't
		 * cause an error. Any returned error will be of type [*url.Error]. The
		 * url.Error value's Timeout method will report true if the request
		 * timed out.
		 * 
		 * When err is nil, resp always contains a non-nil resp.Body.
		 * Caller should close resp.Body when done reading from it.
		 * 
		 * To make a request with custom headers, use [NewRequest] and [Client.Do].
		 * 
		 * To make a request with a specified context.Context, use [NewRequestWithContext]
		 * and Client.Do.
		 */
		Get(url: string): [Response, Error | null];
		/**
		 * Do sends an HTTP request and returns an HTTP response, following
		 * policy (such as redirects, cookies, auth) as configured on the
		 * client.
		 * 
		 * An error is returned if caused by client policy (such as
		 * CheckRedirect), or failure to speak HTTP (such as a network
		 * connectivity problem). A non-2xx status code doesn't cause an
		 * error.
		 * 
		 * If the returned error is nil, the [Response] will contain a non-nil
		 * Body which the user is expected to close. If the Body is not both
		 * read to EOF and closed, the [Client]'s underlying [RoundTripper]
		 * (typically [Transport]) may not be able to re-use a persistent TCP
		 * connection to the server for a subsequent "keep-alive" request.
		 * 
		 * The request Body, if non-nil, will be closed by the underlying
		 * Transport, even on errors. The Body may be closed asynchronously after
		 * Do returns.
		 * 
		 * On error, any Response can be ignored. A non-nil Response with a
		 * non-nil error only occurs when CheckRedirect fails, and even then
		 * the returned [Response.Body] is already closed.
		 * 
		 * Generally [Get], [Post], or [PostForm] will be used instead of Do.
		 * 
		 * If the server replies with a redirect, the Client first uses the
		 * CheckRedirect function to determine whether the redirect should be
		 * followed. If permitted, a 301, 302, or 303 redirect causes
		 * subsequent requests to use HTTP method GET
		 * (or HEAD if the original request was HEAD), with no body.
		 * A 307 or 308 redirect preserves the original HTTP method and body,
		 * provided that the [Request.GetBody] function is defined.
		 * The [NewRequest] function automatically sets GetBody for common
		 * standard library body types.
		 * 
		 * Any returned error will be of type [*url.Error]. The url.Error
		 * value's Timeout method will report true if the request timed out.
		 */
		Do(req: Request): [Response, Error | null];
		/**
		 * Post issues a POST to the specified URL.
		 * 
		 * Caller should close resp.Body when done reading from it.
		 * 
		 * If the provided body is an [io.Closer], it is closed after the
		 * request.
		 * 
		 * To set custom headers, use [NewRequest] and [Client.Do].
		 * 
		 * To make a request with a specified context.Context, use [NewRequestWithContext]
		 * and [Client.Do].
		 * 
		 * See the [Client.Do] method documentation for details on how redirects
		 * are handled.
		 */
		Post(url: string, contentType: string, body: io.Reader): [Response, Error | null];
		/**
		 * PostForm issues a POST to the specified URL,
		 * with data's keys and values URL-encoded as the request body.
		 * 
		 * The Content-Type header is set to application/x-www-form-urlencoded.
		 * To set other headers, use [NewRequest] and [Client.Do].
		 * 
		 * When err is nil, resp always contains a non-nil resp.Body.
		 * Caller should close resp.Body when done reading from it.
		 * 
		 * See the [Client.Do] method documentation for details on how redirects
		 * are handled.
		 * 
		 * To make a request with a specified context.Context, use [NewRequestWithContext]
		 * and Client.Do.
		 */
		PostForm(url: string, data: url.Values): [Response, Error | null];
		/**
		 * Head issues a HEAD to the specified URL. If the response is one of the
		 * following redirect codes, Head follows the redirect after calling the
		 * [Client.CheckRedirect] function:
		 * 
		 * 	301 (Moved Permanently)
		 * 	302 (Found)
		 * 	303 (See Other)
		 * 	307 (Temporary Redirect)
		 * 	308 (Permanent Redirect)
		 * 
		 * To make a request with a specified [context.Context], use [NewRequestWithContext]
		 * and [Client.Do].
		 */
		Head(url: string): [Response, Error | null];
		/**
		 * CloseIdleConnections closes any connections on its [Transport] which
		 * were previously connected from previous requests but are now
		 * sitting idle in a "keep-alive" state. It does not interrupt any
		 * connections currently in use.
		 * 
		 * If [Client.Transport] does not have a [Client.CloseIdleConnections] method
		 * then this method does nothing.
		 */
		CloseIdleConnections(): void;
	}

	/**
	 * A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an
	 * HTTP response or the Cookie header of an HTTP request.
	 * 
	 * See https://tools.ietf.org/html/rfc6265 for details.
	 */
	export interface Cookie {
		Name: string;
		Value: string;
		Quoted: boolean;
		Path: string;
		Domain: string;
		Expires: Time;
		RawExpires: string;
		MaxAge: number;
		Secure: boolean;
		HttpOnly: boolean;
		SameSite: SameSite;
		Partitioned: boolean;
		Raw: string;
		Unparsed: string[];
		/**
		 * String returns the serialization of the cookie for use in a [Cookie]
		 * header (if only Name and Value are set) or a Set-Cookie response
		 * header (if other fields are set).
		 * If c is nil or c.Name is invalid, the empty string is returned.
		 */
		String(): string;
		/**
		 * Valid reports whether the cookie is valid.
		 */
		Valid(): Error | null;
	}

	/**
	 * CrossOriginProtection implements protections against [Cross-Site Request
	 * Forgery (CSRF)] by rejecting non-safe cross-origin browser requests.
	 * 
	 * Cross-origin requests are currently detected with the [Sec-Fetch-Site]
	 * header, available in all browsers since 2023, or by comparing the hostname of
	 * the [Origin] header with the Host header.
	 * 
	 * The GET, HEAD, and OPTIONS methods are [safe methods] and are always allowed.
	 * It's important that applications do not perform any state changing actions
	 * due to requests with safe methods.
	 * 
	 * Requests without Sec-Fetch-Site or Origin headers are currently assumed to be
	 * either same-origin or non-browser requests, and are allowed.
	 * 
	 * The zero value of CrossOriginProtection is valid and has no trusted origins
	 * or bypass patterns.
	 * 
	 * [Sec-Fetch-Site]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site
	 * [Origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin
	 * [Cross-Site Request Forgery (CSRF)]: https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF
	 * [safe methods]: https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP
	 */
	export interface CrossOriginProtection {
		/**
		 * AddTrustedOrigin allows all requests with an [Origin] header
		 * which exactly matches the given value.
		 * 
		 * Origin header values are of the form "scheme://host[:port]".
		 * 
		 * AddTrustedOrigin can be called concurrently with other methods
		 * or request handling, and applies to future requests.
		 * 
		 * [Origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin
		 */
		AddTrustedOrigin(origin: string): Error | null;
		/**
		 * AddInsecureBypassPattern permits all requests that match the given pattern.
		 * 
		 * The pattern syntax and precedence rules are the same as [ServeMux]. Only
		 * requests that match the pattern directly are permitted. Those that ServeMux
		 * would redirect to a pattern (e.g. after cleaning the path or adding a
		 * trailing slash) are not.
		 * 
		 * AddInsecureBypassPattern can be called concurrently with other methods or
		 * request handling, and applies to future requests.
		 */
		AddInsecureBypassPattern(pattern: string): void;
		/**
		 * SetDenyHandler sets a handler to invoke when a request is rejected.
		 * The default error handler responds with a 403 Forbidden status.
		 * 
		 * SetDenyHandler can be called concurrently with other methods
		 * or request handling, and applies to future requests.
		 * 
		 * Check does not call the error handler.
		 */
		SetDenyHandler(h: Handler): void;
		/**
		 * Check applies cross-origin checks to a request.
		 * It returns an error if the request should be rejected.
		 */
		Check(req: Request): Error | null;
		/**
		 * Handler returns a handler that applies cross-origin checks
		 * before invoking the handler h.
		 * 
		 * If a request fails cross-origin checks, the request is rejected
		 * with a 403 Forbidden status or handled with the handler passed
		 * to [CrossOriginProtection.SetDenyHandler].
		 */
		Handler(h: Handler): Handler;
	}

	/**
	 * PushOptions describes options for [Pusher.Push].
	 */
	export interface PushOptions {
		Method: string;
		Header: Header;
	}

	/**
	 * HTTP2Config defines HTTP/2 configuration parameters common to
	 * both [Transport] and [Server].
	 */
	export interface HTTP2Config {
		MaxConcurrentStreams: number;
		MaxDecoderHeaderTableSize: number;
		MaxEncoderHeaderTableSize: number;
		MaxReadFrameSize: number;
		MaxReceiveBufferPerConnection: number;
		MaxReceiveBufferPerStream: number;
		SendPingTimeout: Duration;
		PingTimeout: Duration;
		WriteByteTimeout: Duration;
		PermitProhibitedCipherSuites: boolean;
		CountError: (...args: unknown[]) => unknown;
	}

	/**
	 * MaxBytesError is returned by [MaxBytesReader] when its read limit is exceeded.
	 */
	export interface MaxBytesError {
		Limit: number;
		Error(): string;
	}

	/**
	 * Response represents the response from an HTTP request.
	 * 
	 * The [Client] and [Transport] return Responses from servers once
	 * the response headers have been received. The response body
	 * is streamed on demand as the Body field is read.
	 */
	export interface Response {
		Status: string;
		StatusCode: number;
		Proto: string;
		ProtoMajor: number;
		ProtoMinor: number;
		Header: Header;
		Body: ReadCloser;
		ContentLength: number;
		TransferEncoding: string[];
		Close: boolean;
		Uncompressed: boolean;
		Trailer: Header;
		Request: Request;
		TLS: ConnectionState;
		/**
		 * Cookies parses and returns the cookies set in the Set-Cookie headers.
		 */
		Cookies(): Cookie[];
		/**
		 * Location returns the URL of the response's "Location" header,
		 * if present. Relative redirects are resolved relative to
		 * [Response.Request]. [ErrNoLocation] is returned if no
		 * Location header is present.
		 */
		Location(): [url.URL, Error | null];
		/**
		 * ProtoAtLeast reports whether the HTTP protocol used
		 * in the response is at least major.minor.
		 */
		ProtoAtLeast(major: number, minor: number): boolean;
		/**
		 * Write writes r to w in the HTTP/1.x server response format,
		 * including the status line, headers, body, and optional trailer.
		 * 
		 * This method consults the following fields of the response r:
		 * 
		 * 	StatusCode
		 * 	ProtoMajor
		 * 	ProtoMinor
		 * 	Request.Method
		 * 	TransferEncoding
		 * 	Trailer
		 * 	Body
		 * 	ContentLength
		 * 	Header, values for non-canonical keys will have unpredictable behavior
		 * 
		 * The Response Body is closed after it is sent.
		 */
		Write(w: io.Writer): Error | null;
	}

	/**
	 * A ResponseController is used by an HTTP handler to control the response.
	 * 
	 * A ResponseController may not be used after the [Handler.ServeHTTP] method has returned.
	 */
	export interface ResponseController {
		/**
		 * Flush flushes buffered data to the client.
		 */
		Flush(): Error | null;
		/**
		 * Hijack lets the caller take over the connection.
		 * See the [Hijacker] interface for details.
		 */
		Hijack(): [net.Conn, bufio.ReadWriter, Error | null];
		/**
		 * SetReadDeadline sets the deadline for reading the entire request, including the body.
		 * Reads from the request body after the deadline has been exceeded will return an error.
		 * A zero value means no deadline.
		 * 
		 * Setting the read deadline after it has been exceeded will not extend it.
		 */
		SetReadDeadline(deadline: time.Time): Error | null;
		/**
		 * SetWriteDeadline sets the deadline for writing the response.
		 * Writes to the response body after the deadline has been exceeded will not block,
		 * but may succeed if the data has been buffered.
		 * A zero value means no deadline.
		 * 
		 * Setting the write deadline after it has been exceeded will not extend it.
		 */
		SetWriteDeadline(deadline: time.Time): Error | null;
		/**
		 * EnableFullDuplex indicates that the request handler will interleave reads from [Request.Body]
		 * with writes to the [ResponseWriter].
		 * 
		 * For HTTP/1 requests, the Go HTTP server by default consumes any unread portion of
		 * the request body before beginning to write the response, preventing handlers from
		 * concurrently reading from the request and writing the response.
		 * Calling EnableFullDuplex disables this behavior and permits handlers to continue to read
		 * from the request while concurrently writing the response.
		 * 
		 * For HTTP/2 requests, the Go HTTP server always permits concurrent reads and responses.
		 */
		EnableFullDuplex(): Error | null;
	}

	/**
	 * Protocols is a set of HTTP protocols.
	 * The zero value is an empty set of protocols.
	 * 
	 * The supported protocols are:
	 * 
	 *   - HTTP1 is the HTTP/1.0 and HTTP/1.1 protocols.
	 *     HTTP1 is supported on both unsecured TCP and secured TLS connections.
	 * 
	 *   - HTTP2 is the HTTP/2 protcol over a TLS connection.
	 * 
	 *   - UnencryptedHTTP2 is the HTTP/2 protocol over an unsecured TCP connection.
	 */
	export interface Protocols {
		/**
		 * HTTP1 reports whether p includes HTTP/1.
		 */
		HTTP1(): boolean;
		/**
		 * SetHTTP1 adds or removes HTTP/1 from p.
		 */
		SetHTTP1(ok: boolean): void;
		/**
		 * HTTP2 reports whether p includes HTTP/2.
		 */
		HTTP2(): boolean;
		/**
		 * SetHTTP2 adds or removes HTTP/2 from p.
		 */
		SetHTTP2(ok: boolean): void;
		/**
		 * UnencryptedHTTP2 reports whether p includes unencrypted HTTP/2.
		 */
		UnencryptedHTTP2(): boolean;
		/**
		 * SetUnencryptedHTTP2 adds or removes unencrypted HTTP/2 from p.
		 */
		SetUnencryptedHTTP2(ok: boolean): void;
		String(): string;
	}

	/**
	 * ProtocolError represents an HTTP protocol error.
	 * 
	 * Deprecated: Not all errors in the http package related to protocol errors
	 * are of type ProtocolError.
	 */
	export interface ProtocolError {
		ErrorString: string;
		Error(): string;
		/**
		 * Is lets http.ErrNotSupported match errors.ErrUnsupported.
		 */
		Is(err: Error | null): boolean;
	}

	/**
	 * A Request represents an HTTP request received by a server
	 * or to be sent by a client.
	 * 
	 * The field semantics differ slightly between client and server
	 * usage. In addition to the notes on the fields below, see the
	 * documentation for [Request.Write] and [RoundTripper].
	 */
	export interface Request {
		Method: string;
		URL: URL;
		Proto: string;
		ProtoMajor: number;
		ProtoMinor: number;
		Header: Header;
		Body: ReadCloser;
		GetBody: (...args: unknown[]) => unknown;
		ContentLength: number;
		TransferEncoding: string[];
		Close: boolean;
		Host: string;
		Form: Values;
		PostForm: Values;
		MultipartForm: Form;
		Trailer: Header;
		RemoteAddr: string;
		RequestURI: string;
		TLS: ConnectionState;
		Cancel: any;
		Response: Response;
		Pattern: string;
		/**
		 * Context returns the request's context. To change the context, use
		 * [Request.Clone] or [Request.WithContext].
		 * 
		 * The returned context is always non-nil; it defaults to the
		 * background context.
		 * 
		 * For outgoing client requests, the context controls cancellation.
		 * 
		 * For incoming server requests, the context is canceled when the
		 * client's connection closes, the request is canceled (with HTTP/2),
		 * or when the ServeHTTP method returns.
		 */
		Context(): context.Context;
		/**
		 * WithContext returns a shallow copy of r with its context changed
		 * to ctx. The provided ctx must be non-nil.
		 * 
		 * For outgoing client request, the context controls the entire
		 * lifetime of a request and its response: obtaining a connection,
		 * sending the request, and reading the response headers and body.
		 * 
		 * To create a new request with a context, use [NewRequestWithContext].
		 * To make a deep copy of a request with a new context, use [Request.Clone].
		 */
		WithContext(ctx: context.Context): Request;
		/**
		 * Clone returns a deep copy of r with its context changed to ctx.
		 * The provided ctx must be non-nil.
		 * 
		 * Clone only makes a shallow copy of the Body field.
		 * 
		 * For an outgoing client request, the context controls the entire
		 * lifetime of a request and its response: obtaining a connection,
		 * sending the request, and reading the response headers and body.
		 */
		Clone(ctx: context.Context): Request;
		/**
		 * ProtoAtLeast reports whether the HTTP protocol used
		 * in the request is at least major.minor.
		 */
		ProtoAtLeast(major: number, minor: number): boolean;
		/**
		 * UserAgent returns the client's User-Agent, if sent in the request.
		 */
		UserAgent(): string;
		/**
		 * Cookies parses and returns the HTTP cookies sent with the request.
		 */
		Cookies(): Cookie[];
		/**
		 * CookiesNamed parses and returns the named HTTP cookies sent with the request
		 * or an empty slice if none matched.
		 */
		CookiesNamed(name: string): Cookie[];
		/**
		 * Cookie returns the named cookie provided in the request or
		 * [ErrNoCookie] if not found.
		 * If multiple cookies match the given name, only one cookie will
		 * be returned.
		 */
		Cookie(name: string): [Cookie, Error | null];
		/**
		 * AddCookie adds a cookie to the request. Per RFC 6265 section 5.4,
		 * AddCookie does not attach more than one [Cookie] header field. That
		 * means all cookies, if any, are written into the same line,
		 * separated by semicolon.
		 * AddCookie only sanitizes c's name and value, and does not sanitize
		 * a Cookie header already present in the request.
		 */
		AddCookie(c: Cookie): void;
		/**
		 * Referer returns the referring URL, if sent in the request.
		 * 
		 * Referer is misspelled as in the request itself, a mistake from the
		 * earliest days of HTTP.  This value can also be fetched from the
		 * [Header] map as Header["Referer"]; the benefit of making it available
		 * as a method is that the compiler can diagnose programs that use the
		 * alternate (correct English) spelling req.Referrer() but cannot
		 * diagnose programs that use Header["Referrer"].
		 */
		Referer(): string;
		/**
		 * MultipartReader returns a MIME multipart reader if this is a
		 * multipart/form-data or a multipart/mixed POST request, else returns nil and an error.
		 * Use this function instead of [Request.ParseMultipartForm] to
		 * process the request body as a stream.
		 */
		MultipartReader(): [multipart.Reader, Error | null];
		/**
		 * Write writes an HTTP/1.1 request, which is the header and body, in wire format.
		 * This method consults the following fields of the request:
		 * 
		 * 	Host
		 * 	URL
		 * 	Method (defaults to "GET")
		 * 	Header
		 * 	ContentLength
		 * 	TransferEncoding
		 * 	Body
		 * 
		 * If Body is present, Content-Length is <= 0 and [Request.TransferEncoding]
		 * hasn't been set to "identity", Write adds "Transfer-Encoding:
		 * chunked" to the header. Body is closed after it is sent.
		 */
		Write(w: io.Writer): Error | null;
		/**
		 * WriteProxy is like [Request.Write] but writes the request in the form
		 * expected by an HTTP proxy. In particular, [Request.WriteProxy] writes the
		 * initial Request-URI line of the request with an absolute URI, per
		 * section 5.3 of RFC 7230, including the scheme and host.
		 * In either case, WriteProxy also writes a Host header, using
		 * either r.Host or r.URL.Host.
		 */
		WriteProxy(w: io.Writer): Error | null;
		/**
		 * BasicAuth returns the username and password provided in the request's
		 * Authorization header, if the request uses HTTP Basic Authentication.
		 * See RFC 2617, Section 2.
		 */
		BasicAuth(): [string, boolean];
		/**
		 * SetBasicAuth sets the request's Authorization header to use HTTP
		 * Basic Authentication with the provided username and password.
		 * 
		 * With HTTP Basic Authentication the provided username and password
		 * are not encrypted. It should generally only be used in an HTTPS
		 * request.
		 * 
		 * The username may not contain a colon. Some protocols may impose
		 * additional requirements on pre-escaping the username and
		 * password. For instance, when used with OAuth2, both arguments must
		 * be URL encoded first with [url.QueryEscape].
		 */
		SetBasicAuth(username: string, password: string): void;
		/**
		 * ParseForm populates r.Form and r.PostForm.
		 * 
		 * For all requests, ParseForm parses the raw query from the URL and updates
		 * r.Form.
		 * 
		 * For POST, PUT, and PATCH requests, it also reads the request body, parses it
		 * as a form and puts the results into both r.PostForm and r.Form. Request body
		 * parameters take precedence over URL query string values in r.Form.
		 * 
		 * If the request Body's size has not already been limited by [MaxBytesReader],
		 * the size is capped at 10MB.
		 * 
		 * For other HTTP methods, or when the Content-Type is not
		 * application/x-www-form-urlencoded, the request Body is not read, and
		 * r.PostForm is initialized to a non-nil, empty value.
		 * 
		 * [Request.ParseMultipartForm] calls ParseForm automatically.
		 * ParseForm is idempotent.
		 */
		ParseForm(): Error | null;
		/**
		 * ParseMultipartForm parses a request body as multipart/form-data.
		 * The whole request body is parsed and up to a total of maxMemory bytes of
		 * its file parts are stored in memory, with the remainder stored on
		 * disk in temporary files.
		 * ParseMultipartForm calls [Request.ParseForm] if necessary.
		 * If ParseForm returns an error, ParseMultipartForm returns it but also
		 * continues parsing the request body.
		 * After one call to ParseMultipartForm, subsequent calls have no effect.
		 */
		ParseMultipartForm(maxMemory: number): Error | null;
		/**
		 * FormValue returns the first value for the named component of the query.
		 * The precedence order:
		 *  1. application/x-www-form-urlencoded form body (POST, PUT, PATCH only)
		 *  2. query parameters (always)
		 *  3. multipart/form-data form body (always)
		 * 
		 * FormValue calls [Request.ParseMultipartForm] and [Request.ParseForm]
		 * if necessary and ignores any errors returned by these functions.
		 * If key is not present, FormValue returns the empty string.
		 * To access multiple values of the same key, call ParseForm and
		 * then inspect [Request.Form] directly.
		 */
		FormValue(key: string): string;
		/**
		 * PostFormValue returns the first value for the named component of the POST,
		 * PUT, or PATCH request body. URL query parameters are ignored.
		 * PostFormValue calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary and ignores
		 * any errors returned by these functions.
		 * If key is not present, PostFormValue returns the empty string.
		 */
		PostFormValue(key: string): string;
		/**
		 * FormFile returns the first file for the provided form key.
		 * FormFile calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary.
		 */
		FormFile(key: string): [multipart.File, multipart.FileHeader, Error | null];
		/**
		 * PathValue returns the value for the named path wildcard in the [ServeMux] pattern
		 * that matched the request.
		 * It returns the empty string if the request was not matched against a pattern
		 * or there is no such wildcard in the pattern.
		 */
		PathValue(name: string): string;
		/**
		 * SetPathValue sets name to value, so that subsequent calls to r.PathValue(name)
		 * return value.
		 */
		SetPathValue(name: string, value: string): void;
	}

	/**
	 * ServeMux is an HTTP request multiplexer.
	 * It matches the URL of each incoming request against a list of registered
	 * patterns and calls the handler for the pattern that
	 * most closely matches the URL.
	 * 
	 * # Patterns
	 * 
	 * Patterns can match the method, host and path of a request.
	 * Some examples:
	 * 
	 *   - "/index.html" matches the path "/index.html" for any host and method.
	 *   - "GET /static/" matches a GET request whose path begins with "/static/".
	 *   - "example.com/" matches any request to the host "example.com".
	 *   - "example.com/{$}" matches requests with host "example.com" and path "/".
	 *   - "/b/{bucket}/o/{objectname...}" matches paths whose first segment is "b"
	 *     and whose third segment is "o". The name "bucket" denotes the second
	 *     segment and "objectname" denotes the remainder of the path.
	 * 
	 * In general, a pattern looks like
	 * 
	 * 	[METHOD ][HOST]/[PATH]
	 * 
	 * All three parts are optional; "/" is a valid pattern.
	 * If METHOD is present, it must be followed by at least one space or tab.
	 * 
	 * Literal (that is, non-wildcard) parts of a pattern match
	 * the corresponding parts of a request case-sensitively.
	 * 
	 * A pattern with no method matches every method. A pattern
	 * with the method GET matches both GET and HEAD requests.
	 * Otherwise, the method must match exactly.
	 * 
	 * A pattern with no host matches every host.
	 * A pattern with a host matches URLs on that host only.
	 * 
	 * A path can include wildcard segments of the form {NAME} or {NAME...}.
	 * For example, "/b/{bucket}/o/{objectname...}".
	 * The wildcard name must be a valid Go identifier.
	 * Wildcards must be full path segments: they must be preceded by a slash and followed by
	 * either a slash or the end of the string.
	 * For example, "/b_{bucket}" is not a valid pattern.
	 * 
	 * Normally a wildcard matches only a single path segment,
	 * ending at the next literal slash (not %2F) in the request URL.
	 * But if the "..." is present, then the wildcard matches the remainder of the URL path, including slashes.
	 * (Therefore it is invalid for a "..." wildcard to appear anywhere but at the end of a pattern.)
	 * The match for a wildcard can be obtained by calling [Request.PathValue] with the wildcard's name.
	 * A trailing slash in a path acts as an anonymous "..." wildcard.
	 * 
	 * The special wildcard {$} matches only the end of the URL.
	 * For example, the pattern "/{$}" matches only the path "/",
	 * whereas the pattern "/" matches every path.
	 * 
	 * For matching, both pattern paths and incoming request paths are unescaped segment by segment.
	 * So, for example, the path "/a%2Fb/100%25" is treated as having two segments, "a/b" and "100%".
	 * The pattern "/a%2fb/" matches it, but the pattern "/a/b/" does not.
	 * 
	 * # Precedence
	 * 
	 * If two or more patterns match a request, then the most specific pattern takes precedence.
	 * A pattern P1 is more specific than P2 if P1 matches a strict subset of P2’s requests;
	 * that is, if P2 matches all the requests of P1 and more.
	 * If neither is more specific, then the patterns conflict.
	 * There is one exception to this rule, for backwards compatibility:
	 * if two patterns would otherwise conflict and one has a host while the other does not,
	 * then the pattern with the host takes precedence.
	 * If a pattern passed to [ServeMux.Handle] or [ServeMux.HandleFunc] conflicts with
	 * another pattern that is already registered, those functions panic.
	 * 
	 * As an example of the general rule, "/images/thumbnails/" is more specific than "/images/",
	 * so both can be registered.
	 * The former matches paths beginning with "/images/thumbnails/"
	 * and the latter will match any other path in the "/images/" subtree.
	 * 
	 * As another example, consider the patterns "GET /" and "/index.html":
	 * both match a GET request for "/index.html", but the former pattern
	 * matches all other GET and HEAD requests, while the latter matches any
	 * request for "/index.html" that uses a different method.
	 * The patterns conflict.
	 * 
	 * # Trailing-slash redirection
	 * 
	 * Consider a [ServeMux] with a handler for a subtree, registered using a trailing slash or "..." wildcard.
	 * If the ServeMux receives a request for the subtree root without a trailing slash,
	 * it redirects the request by adding the trailing slash.
	 * This behavior can be overridden with a separate registration for the path without
	 * the trailing slash or "..." wildcard. For example, registering "/images/" causes ServeMux
	 * to redirect a request for "/images" to "/images/", unless "/images" has
	 * been registered separately.
	 * 
	 * # Request sanitizing
	 * 
	 * ServeMux also takes care of sanitizing the URL request path and the Host
	 * header, stripping the port number and redirecting any request containing . or
	 * .. segments or repeated slashes to an equivalent, cleaner URL.
	 * Escaped path elements such as "%2e" for "." and "%2f" for "/" are preserved
	 * and aren't considered separators for request routing.
	 * 
	 * # Compatibility
	 * 
	 * The pattern syntax and matching behavior of ServeMux changed significantly
	 * in Go 1.22. To restore the old behavior, set the GODEBUG environment variable
	 * to "httpmuxgo121=1". This setting is read once, at program startup; changes
	 * during execution will be ignored.
	 * 
	 * The backwards-incompatible changes include:
	 *   - Wildcards are just ordinary literal path segments in 1.21.
	 *     For example, the pattern "/{x}" will match only that path in 1.21,
	 *     but will match any one-segment path in 1.22.
	 *   - In 1.21, no pattern was rejected, unless it was empty or conflicted with an existing pattern.
	 *     In 1.22, syntactically invalid patterns will cause [ServeMux.Handle] and [ServeMux.HandleFunc] to panic.
	 *     For example, in 1.21, the patterns "/{"  and "/a{x}" match themselves,
	 *     but in 1.22 they are invalid and will cause a panic when registered.
	 *   - In 1.22, each segment of a pattern is unescaped; this was not done in 1.21.
	 *     For example, in 1.22 the pattern "/%61" matches the path "/a" ("%61" being the URL escape sequence for "a"),
	 *     but in 1.21 it would match only the path "/%2561" (where "%25" is the escape for the percent sign).
	 *   - When matching patterns to paths, in 1.22 each segment of the path is unescaped; in 1.21, the entire path is unescaped.
	 *     This change mostly affects how paths with %2F escapes adjacent to slashes are treated.
	 *     See https://go.dev/issue/21955 for details.
	 */
	export interface ServeMux {
		/**
		 * Handler returns the handler to use for the given request,
		 * consulting r.Method, r.Host, and r.URL.Path. It always returns
		 * a non-nil handler. If the path is not in its canonical form, the
		 * handler will be an internally-generated handler that redirects
		 * to the canonical path. If the host contains a port, it is ignored
		 * when matching handlers.
		 * 
		 * The path and host are used unchanged for CONNECT requests.
		 * 
		 * Handler also returns the registered pattern that matches the
		 * request or, in the case of internally-generated redirects,
		 * the path that will match after following the redirect.
		 * 
		 * If there is no registered handler that applies to the request,
		 * Handler returns a “page not found” or “method not supported”
		 * handler and an empty pattern.
		 * 
		 * Handler does not modify its argument. In particular, it does not
		 * populate named path wildcards, so r.PathValue will always return
		 * the empty string.
		 */
		Handler(r: Request): [Handler, string];
		/**
		 * ServeHTTP dispatches the request to the handler whose
		 * pattern most closely matches the request URL.
		 */
		ServeHTTP(w: ResponseWriter, r: Request): void;
		/**
		 * Handle registers the handler for the given pattern.
		 * If the given pattern conflicts with one that is already registered, Handle
		 * panics.
		 */
		Handle(pattern: string, handler: Handler): void;
		/**
		 * HandleFunc registers the handler function for the given pattern.
		 * If the given pattern conflicts with one that is already registered, HandleFunc
		 * panics.
		 */
		HandleFunc(pattern: string, handler: (...args: unknown[]) => unknown): void;
	}

	/**
	 * Get issues a GET to the specified URL. If the response is one of
	 * the following redirect codes, Get follows the redirect, up to a
	 * maximum of 10 redirects:
	 * 
	 * 	301 (Moved Permanently)
	 * 	302 (Found)
	 * 	303 (See Other)
	 * 	307 (Temporary Redirect)
	 * 	308 (Permanent Redirect)
	 * 
	 * An error is returned if there were too many redirects or if there
	 * was an HTTP protocol error. A non-2xx response doesn't cause an
	 * error. Any returned error will be of type [*url.Error]. The url.Error
	 * value's Timeout method will report true if the request timed out.
	 * 
	 * When err is nil, resp always contains a non-nil resp.Body.
	 * Caller should close resp.Body when done reading from it.
	 * 
	 * Get is a wrapper around DefaultClient.Get.
	 * 
	 * To make a request with custom headers, use [NewRequest] and
	 * DefaultClient.Do.
	 * 
	 * To make a request with a specified context.Context, use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function Get(url: string): Response;
	/**
	 * Post issues a POST to the specified URL.
	 * 
	 * Caller should close resp.Body when done reading from it.
	 * 
	 * If the provided body is an [io.Closer], it is closed after the
	 * request.
	 * 
	 * Post is a wrapper around DefaultClient.Post.
	 * 
	 * To set custom headers, use [NewRequest] and DefaultClient.Do.
	 * 
	 * See the [Client.Do] method documentation for details on how redirects
	 * are handled.
	 * 
	 * To make a request with a specified context.Context, use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function Post(url: string, contentType: string, body: io.Reader): Response;
	/**
	 * PostForm issues a POST to the specified URL, with data's keys and
	 * values URL-encoded as the request body.
	 * 
	 * The Content-Type header is set to application/x-www-form-urlencoded.
	 * To set other headers, use [NewRequest] and DefaultClient.Do.
	 * 
	 * When err is nil, resp always contains a non-nil resp.Body.
	 * Caller should close resp.Body when done reading from it.
	 * 
	 * PostForm is a wrapper around DefaultClient.PostForm.
	 * 
	 * See the [Client.Do] method documentation for details on how redirects
	 * are handled.
	 * 
	 * To make a request with a specified [context.Context], use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function PostForm(url: string, data: url.Values): Response;
	/**
	 * Head issues a HEAD to the specified URL. If the response is one of
	 * the following redirect codes, Head follows the redirect, up to a
	 * maximum of 10 redirects:
	 * 
	 * 	301 (Moved Permanently)
	 * 	302 (Found)
	 * 	303 (See Other)
	 * 	307 (Temporary Redirect)
	 * 	308 (Permanent Redirect)
	 * 
	 * Head is a wrapper around DefaultClient.Head.
	 * 
	 * To make a request with a specified [context.Context], use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function Head(url: string): Response;
	/**
	 * ParseCookie parses a Cookie header value and returns all the cookies
	 * which were set in it. Since the same cookie name can appear multiple times
	 * the returned Values can contain more than one value for a given key.
	 */
	export function ParseCookie(line: string): Cookie[];
	/**
	 * ParseSetCookie parses a Set-Cookie header value and returns a cookie.
	 * It returns an error on syntax error.
	 */
	export function ParseSetCookie(line: string): Cookie;
	/**
	 * SetCookie adds a Set-Cookie header to the provided [ResponseWriter]'s headers.
	 * The provided cookie must have a valid Name. Invalid cookies may be
	 * silently dropped.
	 */
	export function SetCookie(w: ResponseWriter, cookie: Cookie): void;
	/**
	 * NewCrossOriginProtection returns a new [CrossOriginProtection] value.
	 */
	export function NewCrossOriginProtection(): CrossOriginProtection;
	/**
	 * NewFileTransport returns a new [RoundTripper], serving the provided
	 * [FileSystem]. The returned RoundTripper ignores the URL host in its
	 * incoming requests, as well as most other properties of the
	 * request.
	 * 
	 * The typical use case for NewFileTransport is to register the "file"
	 * protocol with a [Transport], as in:
	 * 
	 * 	t := &http.Transport{}
	 * 	t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
	 * 	c := &http.Client{Transport: t}
	 * 	res, err := c.Get("file:///etc/passwd")
	 * 	...
	 */
	export function NewFileTransport(fs: FileSystem): RoundTripper;
	/**
	 * NewFileTransportFS returns a new [RoundTripper], serving the provided
	 * file system fsys. The returned RoundTripper ignores the URL host in its
	 * incoming requests, as well as most other properties of the
	 * request. The files provided by fsys must implement [io.Seeker].
	 * 
	 * The typical use case for NewFileTransportFS is to register the "file"
	 * protocol with a [Transport], as in:
	 * 
	 * 	fsys := os.DirFS("/")
	 * 	t := &http.Transport{}
	 * 	t.RegisterProtocol("file", http.NewFileTransportFS(fsys))
	 * 	c := &http.Client{Transport: t}
	 * 	res, err := c.Get("file:///etc/passwd")
	 * 	...
	 */
	export function NewFileTransportFS(fsys: fs.FS): RoundTripper;
	/**
	 * ServeContent replies to the request using the content in the
	 * provided ReadSeeker. The main benefit of ServeContent over [io.Copy]
	 * is that it handles Range requests properly, sets the MIME type, and
	 * handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,
	 * and If-Range requests.
	 * 
	 * If the response's Content-Type header is not set, ServeContent
	 * first tries to deduce the type from name's file extension and,
	 * if that fails, falls back to reading the first block of the content
	 * and passing it to [DetectContentType].
	 * The name is otherwise unused; in particular it can be empty and is
	 * never sent in the response.
	 * 
	 * If modtime is not the zero time or Unix epoch, ServeContent
	 * includes it in a Last-Modified header in the response. If the
	 * request includes an If-Modified-Since header, ServeContent uses
	 * modtime to decide whether the content needs to be sent at all.
	 * 
	 * The content's Seek method must work: ServeContent uses
	 * a seek to the end of the content to determine its size.
	 * Note that [*os.File] implements the [io.ReadSeeker] interface.
	 * 
	 * If the caller has set w's ETag header formatted per RFC 7232, section 2.3,
	 * ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.
	 * 
	 * If an error occurs when serving the request (for example, when
	 * handling an invalid range request), ServeContent responds with an
	 * error message. By default, ServeContent strips the Cache-Control,
	 * Content-Encoding, ETag, and Last-Modified headers from error responses.
	 * The GODEBUG setting httpservecontentkeepheaders=1 causes ServeContent
	 * to preserve these headers.
	 */
	export function ServeContent(w: ResponseWriter, req: Request, name: string, modtime: time.Time, content: io.ReadSeeker): void;
	/**
	 * ServeFile replies to the request with the contents of the named
	 * file or directory.
	 * 
	 * If the provided file or directory name is a relative path, it is
	 * interpreted relative to the current directory and may ascend to
	 * parent directories. If the provided name is constructed from user
	 * input, it should be sanitized before calling [ServeFile].
	 * 
	 * As a precaution, ServeFile will reject requests where r.URL.Path
	 * contains a ".." path element; this protects against callers who
	 * might unsafely use [filepath.Join] on r.URL.Path without sanitizing
	 * it and then use that filepath.Join result as the name argument.
	 * 
	 * As another special case, ServeFile redirects any request where r.URL.Path
	 * ends in "/index.html" to the same path, without the final
	 * "index.html". To avoid such redirects either modify the path or
	 * use [ServeContent].
	 * 
	 * Outside of those two special cases, ServeFile does not use
	 * r.URL.Path for selecting the file or directory to serve; only the
	 * file or directory provided in the name argument is used.
	 */
	export function ServeFile(w: ResponseWriter, r: Request, name: string): void;
	/**
	 * ServeFileFS replies to the request with the contents
	 * of the named file or directory from the file system fsys.
	 * The files provided by fsys must implement [io.Seeker].
	 * 
	 * If the provided name is constructed from user input, it should be
	 * sanitized before calling [ServeFileFS].
	 * 
	 * As a precaution, ServeFileFS will reject requests where r.URL.Path
	 * contains a ".." path element; this protects against callers who
	 * might unsafely use [filepath.Join] on r.URL.Path without sanitizing
	 * it and then use that filepath.Join result as the name argument.
	 * 
	 * As another special case, ServeFileFS redirects any request where r.URL.Path
	 * ends in "/index.html" to the same path, without the final
	 * "index.html". To avoid such redirects either modify the path or
	 * use [ServeContent].
	 * 
	 * Outside of those two special cases, ServeFileFS does not use
	 * r.URL.Path for selecting the file or directory to serve; only the
	 * file or directory provided in the name argument is used.
	 */
	export function ServeFileFS(w: ResponseWriter, r: Request, fsys: fs.FS, name: string): void;
	/**
	 * FS converts fsys to a [FileSystem] implementation,
	 * for use with [FileServer] and [NewFileTransport].
	 * The files provided by fsys must implement [io.Seeker].
	 */
	export function FS(fsys: fs.FS): FileSystem;
	/**
	 * FileServer returns a handler that serves HTTP requests
	 * with the contents of the file system rooted at root.
	 * 
	 * As a special case, the returned file server redirects any request
	 * ending in "/index.html" to the same path, without the final
	 * "index.html".
	 * 
	 * To use the operating system's file system implementation,
	 * use [http.Dir]:
	 * 
	 * 	http.Handle("/", http.FileServer(http.Dir("/tmp")))
	 * 
	 * To use an [fs.FS] implementation, use [http.FileServerFS] instead.
	 */
	export function FileServer(root: FileSystem): Handler;
	/**
	 * FileServerFS returns a handler that serves HTTP requests
	 * with the contents of the file system fsys.
	 * The files provided by fsys must implement [io.Seeker].
	 * 
	 * As a special case, the returned file server redirects any request
	 * ending in "/index.html" to the same path, without the final
	 * "index.html".
	 * 
	 * 	http.Handle("/", http.FileServerFS(fsys))
	 */
	export function FileServerFS(root: fs.FS): Handler;
	/**
	 * ParseTime parses a time header (such as the Date: header),
	 * trying each of the three formats allowed by HTTP/1.1:
	 * [TimeFormat], [time.RFC850], and [time.ANSIC].
	 */
	export function ParseTime(text: string): time.Time;
	/**
	 * CanonicalHeaderKey returns the canonical format of the
	 * header key s. The canonicalization converts the first
	 * letter and any letter following a hyphen to upper case;
	 * the rest are converted to lowercase. For example, the
	 * canonical key for "accept-encoding" is "Accept-Encoding".
	 * If s contains a space or invalid header field bytes, it is
	 * returned without modifications.
	 */
	export function CanonicalHeaderKey(s: string): string;
	/**
	 * ParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6.
	 * "HTTP/1.0" returns (1, 0, true). Note that strings without
	 * a minor version, such as "HTTP/2", are not valid.
	 */
	export function ParseHTTPVersion(vers: string): [number, boolean];
	/**
	 * NewRequest wraps [NewRequestWithContext] using [context.Background].
	 */
	export function NewRequest(method: string, url: string, body: io.Reader): Request;
	/**
	 * NewRequestWithContext returns a new [Request] given a method, URL, and
	 * optional body.
	 * 
	 * If the provided body is also an [io.Closer], the returned
	 * [Request.Body] is set to body and will be closed (possibly
	 * asynchronously) by the Client methods Do, Post, and PostForm,
	 * and [Transport.RoundTrip].
	 * 
	 * NewRequestWithContext returns a Request suitable for use with
	 * [Client.Do] or [Transport.RoundTrip]. To create a request for use with
	 * testing a Server Handler, either use the [net/http/httptest.NewRequest] function,
	 * use [ReadRequest], or manually update the Request fields.
	 * For an outgoing client request, the context
	 * controls the entire lifetime of a request and its response:
	 * obtaining a connection, sending the request, and reading the
	 * response headers and body. See the [Request] type's documentation for
	 * the difference between inbound and outbound request fields.
	 * 
	 * If body is of type [*bytes.Buffer], [*bytes.Reader], or
	 * [*strings.Reader], the returned request's ContentLength is set to its
	 * exact value (instead of -1), GetBody is populated (so 307 and 308
	 * redirects can replay the body), and Body is set to [NoBody] if the
	 * ContentLength is 0.
	 */
	export function NewRequestWithContext(ctx: context.Context, method: string, url: string, body: io.Reader): Request;
	/**
	 * ReadRequest reads and parses an incoming request from b.
	 * 
	 * ReadRequest is a low-level function and should only be used for
	 * specialized applications; most code should use the [Server] to read
	 * requests and handle them via the [Handler] interface. ReadRequest
	 * only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.
	 */
	export function ReadRequest(b: bufio.Reader): Request;
	/**
	 * MaxBytesReader is similar to [io.LimitReader] but is intended for
	 * limiting the size of incoming request bodies. In contrast to
	 * io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
	 * non-nil error of type [*MaxBytesError] for a Read beyond the limit,
	 * and closes the underlying reader when its Close method is called.
	 * 
	 * MaxBytesReader prevents clients from accidentally or maliciously
	 * sending a large request and wasting server resources. If possible,
	 * it tells the [ResponseWriter] to close the connection after the limit
	 * has been reached.
	 */
	export function MaxBytesReader(w: ResponseWriter, r: io.ReadCloser, n: number): io.ReadCloser;
	/**
	 * ReadResponse reads and returns an HTTP response from r.
	 * The req parameter optionally specifies the [Request] that corresponds
	 * to this [Response]. If nil, a GET request is assumed.
	 * Clients must call resp.Body.Close when finished reading resp.Body.
	 * After that call, clients can inspect resp.Trailer to find key/value
	 * pairs included in the response trailer.
	 */
	export function ReadResponse(r: bufio.Reader, req: Request): Response;
	/**
	 * NewResponseController creates a [ResponseController] for a request.
	 * 
	 * The ResponseWriter should be the original value passed to the [Handler.ServeHTTP] method,
	 * or have an Unwrap method returning the original ResponseWriter.
	 * 
	 * If the ResponseWriter implements any of the following methods, the ResponseController
	 * will call them as appropriate:
	 * 
	 * 	Flush()
	 * 	FlushError() error // alternative Flush returning an error
	 * 	Hijack() (net.Conn, *bufio.ReadWriter, error)
	 * 	SetReadDeadline(deadline time.Time) error
	 * 	SetWriteDeadline(deadline time.Time) error
	 * 	EnableFullDuplex() error
	 * 
	 * If the ResponseWriter does not support a method, ResponseController returns
	 * an error matching [ErrNotSupported].
	 */
	export function NewResponseController(rw: ResponseWriter): ResponseController;
	/**
	 * Error replies to the request with the specified error message and HTTP code.
	 * It does not otherwise end the request; the caller should ensure no further
	 * writes are done to w.
	 * The error message should be plain text.
	 * 
	 * Error deletes the Content-Length header,
	 * sets Content-Type to “text/plain; charset=utf-8”,
	 * and sets X-Content-Type-Options to “nosniff”.
	 * This configures the header properly for the error message,
	 * in case the caller had set it up expecting a successful output.
	 */
	export function Error(w: ResponseWriter, error: string, code: number): void;
	/**
	 * NotFound replies to the request with an HTTP 404 not found error.
	 */
	export function NotFound(w: ResponseWriter, r: Request): void;
	/**
	 * NotFoundHandler returns a simple request handler
	 * that replies to each request with a “404 page not found” reply.
	 */
	export function NotFoundHandler(): Handler;
	/**
	 * StripPrefix returns a handler that serves HTTP requests by removing the
	 * given prefix from the request URL's Path (and RawPath if set) and invoking
	 * the handler h. StripPrefix handles a request for a path that doesn't begin
	 * with prefix by replying with an HTTP 404 not found error. The prefix must
	 * match exactly: if the prefix in the request contains escaped characters
	 * the reply is also an HTTP 404 not found error.
	 */
	export function StripPrefix(prefix: string, h: Handler): Handler;
	/**
	 * Redirect replies to the request with a redirect to url,
	 * which may be a path relative to the request path.
	 * Any non-ASCII characters in url will be percent-encoded,
	 * but existing percent encodings will not be changed.
	 * 
	 * The provided code should be in the 3xx range and is usually
	 * [StatusMovedPermanently], [StatusFound] or [StatusSeeOther].
	 * 
	 * If the Content-Type header has not been set, [Redirect] sets it
	 * to "text/html; charset=utf-8" and writes a small HTML body.
	 * Setting the Content-Type header to any value, including nil,
	 * disables that behavior.
	 */
	export function Redirect(w: ResponseWriter, r: Request, url: string, code: number): void;
	/**
	 * RedirectHandler returns a request handler that redirects
	 * each request it receives to the given url using the given
	 * status code.
	 * 
	 * The provided code should be in the 3xx range and is usually
	 * [StatusMovedPermanently], [StatusFound] or [StatusSeeOther].
	 */
	export function RedirectHandler(url: string, code: number): Handler;
	/**
	 * NewServeMux allocates and returns a new [ServeMux].
	 */
	export function NewServeMux(): ServeMux;
	/**
	 * Handle registers the handler for the given pattern in [DefaultServeMux].
	 * The documentation for [ServeMux] explains how patterns are matched.
	 */
	export function Handle(pattern: string, handler: Handler): void;
	/**
	 * HandleFunc registers the handler function for the given pattern in [DefaultServeMux].
	 * The documentation for [ServeMux] explains how patterns are matched.
	 */
	export function HandleFunc(pattern: string, handler: (...args: unknown[]) => unknown): void;
	/**
	 * Serve accepts incoming HTTP connections on the listener l,
	 * creating a new service goroutine for each. The service goroutines
	 * read requests and then call handler to reply to them.
	 * 
	 * The handler is typically nil, in which case [DefaultServeMux] is used.
	 * 
	 * HTTP/2 support is only enabled if the Listener returns [*tls.Conn]
	 * connections and they were configured with "h2" in the TLS
	 * Config.NextProtos.
	 * 
	 * Serve always returns a non-nil error.
	 */
	export function Serve(l: net.Listener, handler: Handler): void;
	/**
	 * ServeTLS accepts incoming HTTPS connections on the listener l,
	 * creating a new service goroutine for each. The service goroutines
	 * read requests and then call handler to reply to them.
	 * 
	 * The handler is typically nil, in which case [DefaultServeMux] is used.
	 * 
	 * Additionally, files containing a certificate and matching private key
	 * for the server must be provided. If the certificate is signed by a
	 * certificate authority, the certFile should be the concatenation
	 * of the server's certificate, any intermediates, and the CA's certificate.
	 * 
	 * ServeTLS always returns a non-nil error.
	 */
	export function ServeTLS(l: net.Listener, handler: Handler, certFile: string, keyFile: string): void;
	/**
	 * AllowQuerySemicolons returns a handler that serves requests by converting any
	 * unescaped semicolons in the URL query to ampersands, and invoking the handler h.
	 * 
	 * This restores the pre-Go 1.17 behavior of splitting query parameters on both
	 * semicolons and ampersands. (See golang.org/issue/25192). Note that this
	 * behavior doesn't match that of many proxies, and the mismatch can lead to
	 * security issues.
	 * 
	 * AllowQuerySemicolons should be invoked before [Request.ParseForm] is called.
	 */
	export function AllowQuerySemicolons(h: Handler): Handler;
	/**
	 * ListenAndServe listens on the TCP network address addr and then calls
	 * [Serve] with handler to handle requests on incoming connections.
	 * Accepted connections are configured to enable TCP keep-alives.
	 * 
	 * The handler is typically nil, in which case [DefaultServeMux] is used.
	 * 
	 * ListenAndServe always returns a non-nil error.
	 */
	export function ListenAndServe(addr: string, handler: Handler): void;
	/**
	 * ListenAndServeTLS acts identically to [ListenAndServe], except that it
	 * expects HTTPS connections. Additionally, files containing a certificate and
	 * matching private key for the server must be provided. If the certificate
	 * is signed by a certificate authority, the certFile should be the concatenation
	 * of the server's certificate, any intermediates, and the CA's certificate.
	 */
	export function ListenAndServeTLS(addr: string, certFile: string, keyFile: string, handler: Handler): void;
	/**
	 * TimeoutHandler returns a [Handler] that runs h with the given time limit.
	 * 
	 * The new Handler calls h.ServeHTTP to handle each request, but if a
	 * call runs for longer than its time limit, the handler responds with
	 * a 503 Service Unavailable error and the given message in its body.
	 * (If msg is empty, a suitable default message will be sent.)
	 * After such a timeout, writes by h to its [ResponseWriter] will return
	 * [ErrHandlerTimeout].
	 * 
	 * TimeoutHandler supports the [Pusher] interface but does not support
	 * the [Hijacker] or [Flusher] interfaces.
	 */
	export function TimeoutHandler(h: Handler, dt: time.Duration, msg: string): Handler;
	/**
	 * MaxBytesHandler returns a [Handler] that runs h with its [ResponseWriter] and [Request.Body] wrapped by a MaxBytesReader.
	 */
	export function MaxBytesHandler(h: Handler, n: number): Handler;
	/**
	 * DetectContentType implements the algorithm described
	 * at https://mimesniff.spec.whatwg.org/ to determine the
	 * Content-Type of the given data. It considers at most the
	 * first 512 bytes of data. DetectContentType always returns
	 * a valid MIME type: if it cannot determine a more specific one, it
	 * returns "application/octet-stream".
	 */
	export function DetectContentType(data: byte[]): string;
	/**
	 * StatusText returns a text for the HTTP status code. It returns the empty
	 * string if the code is unknown.
	 */
	export function StatusText(code: number): string;
	/**
	 * ProxyFromEnvironment returns the URL of the proxy to use for a
	 * given request, as indicated by the environment variables
	 * HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions
	 * thereof). Requests use the proxy from the environment variable
	 * matching their scheme, unless excluded by NO_PROXY.
	 * 
	 * The environment values may be either a complete URL or a
	 * "host[:port]", in which case the "http" scheme is assumed.
	 * An error is returned if the value is a different form.
	 * 
	 * A nil URL and nil error are returned if no proxy is defined in the
	 * environment, or a proxy should not be used for the given request,
	 * as defined by NO_PROXY.
	 * 
	 * As a special case, if req.URL.Host is "localhost" (with or without
	 * a port number), then a nil URL and nil error will be returned.
	 */
	export function ProxyFromEnvironment(req: Request): url.URL;
	/**
	 * ProxyURL returns a proxy function (for use in a [Transport])
	 * that always returns the same URL.
	 */
	export function ProxyURL(fixedURL: url.URL): (...args: unknown[]) => unknown;
}
// END: go:go:net/http

// MODULE: go:go:os
declare module "go:go:os" {
	import { SysProcAttr } from "go:syscall";

	/**
	 * SyscallError records an error from a specific system call.
	 */
	export interface SyscallError {
		Syscall: string;
		Err: Error | null;
		Error(): string;
		Unwrap(): Error | null;
		/**
		 * Timeout reports whether this error represents a timeout.
		 */
		Timeout(): boolean;
	}

	/**
	 * Process stores the information about a process created by [StartProcess].
	 */
	export interface Process {
		Pid: number;
		/**
		 * Release releases any resources associated with the [Process] p,
		 * rendering it unusable in the future.
		 * Release only needs to be called if [Process.Wait] is not.
		 */
		Release(): Error | null;
		/**
		 * Kill causes the [Process] to exit immediately. Kill does not wait until
		 * the Process has actually exited. This only kills the Process itself,
		 * not any other processes it may have started.
		 */
		Kill(): Error | null;
		/**
		 * Wait waits for the [Process] to exit, and then returns a
		 * ProcessState describing its status and an error, if any.
		 * Wait releases any resources associated with the Process.
		 * On most operating systems, the Process must be a child
		 * of the current process or an error will be returned.
		 */
		Wait(): [ProcessState, Error | null];
		/**
		 * Signal sends a signal to the [Process].
		 * Sending [Interrupt] on Windows is not implemented.
		 */
		Signal(sig: Signal): Error | null;
	}

	/**
	 * ProcAttr holds the attributes that will be applied to a new process
	 * started by StartProcess.
	 */
	export interface ProcAttr {
		Dir: string;
		Env: string[];
		Files: File[];
		Sys: SysProcAttr;
	}

	/**
	 * ProcessState stores information about a process, as reported by Wait.
	 */
	export interface ProcessState {
		/**
		 * Pid returns the process id of the exited process.
		 */
		Pid(): number;
		String(): string;
		/**
		 * ExitCode returns the exit code of the exited process, or -1
		 * if the process hasn't exited or was terminated by a signal.
		 */
		ExitCode(): number;
	}

	/**
	 * LinkError records an error during a link or symlink or rename
	 * system call and the paths that caused it.
	 */
	export interface LinkError {
		Op: string;
		Old: string;
		New: string;
		Err: Error | null;
		Error(): string;
		Unwrap(): Error | null;
	}

	/**
	 * Root may be used to only access files within a single directory tree.
	 * 
	 * Methods on Root can only access files and directories beneath a root directory.
	 * If any component of a file name passed to a method of Root references a location
	 * outside the root, the method returns an error.
	 * File names may reference the directory itself (.).
	 * 
	 * Methods on Root will follow symbolic links, but symbolic links may not
	 * reference a location outside the root.
	 * Symbolic links must not be absolute.
	 * 
	 * Methods on Root do not prohibit traversal of filesystem boundaries,
	 * Linux bind mounts, /proc special files, or access to Unix device files.
	 * 
	 * Methods on Root are safe to be used from multiple goroutines simultaneously.
	 * 
	 * On most platforms, creating a Root opens a file descriptor or handle referencing
	 * the directory. If the directory is moved, methods on Root reference the original
	 * directory in its new location.
	 * 
	 * Root's behavior differs on some platforms:
	 * 
	 *   - When GOOS=windows, file names may not reference Windows reserved device names
	 *     such as NUL and COM1.
	 *   - On Unix, [Root.Chmod], [Root.Chown], and [Root.Chtimes] are vulnerable to a race condition.
	 *     If the target of the operation is changed from a regular file to a symlink
	 *     while the operation is in progress, the operation may be performed on the link
	 *     rather than the link target.
	 *   - When GOOS=js, Root is vulnerable to TOCTOU (time-of-check-time-of-use)
	 *     attacks in symlink validation, and cannot ensure that operations will not
	 *     escape the root.
	 *   - When GOOS=plan9 or GOOS=js, Root does not track directories across renames.
	 *     On these platforms, a Root references a directory name, not a file descriptor.
	 *   - WASI preview 1 (GOOS=wasip1) does not support [Root.Chmod].
	 */
	export interface Root {
		/**
		 * Name returns the name of the directory presented to OpenRoot.
		 * 
		 * It is safe to call Name after [Close].
		 */
		Name(): string;
		/**
		 * Close closes the Root.
		 * After Close is called, methods on Root return errors.
		 */
		Close(): Error | null;
		/**
		 * Open opens the named file in the root for reading.
		 * See [Open] for more details.
		 */
		Open(name: string): [File, Error | null];
		/**
		 * Create creates or truncates the named file in the root.
		 * See [Create] for more details.
		 */
		Create(name: string): [File, Error | null];
		/**
		 * OpenFile opens the named file in the root.
		 * See [OpenFile] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * OpenFile returns an error.
		 */
		OpenFile(name: string, flag: number, perm: FileMode): [File, Error | null];
		/**
		 * OpenRoot opens the named directory in the root.
		 * If there is an error, it will be of type [*PathError].
		 */
		OpenRoot(name: string): [Root, Error | null];
		/**
		 * Chmod changes the mode of the named file in the root to mode.
		 * See [Chmod] for more details.
		 */
		Chmod(name: string, mode: FileMode): Error | null;
		/**
		 * Mkdir creates a new directory in the root
		 * with the specified name and permission bits (before umask).
		 * See [Mkdir] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * Mkdir returns an error.
		 */
		Mkdir(name: string, perm: FileMode): Error | null;
		/**
		 * MkdirAll creates a new directory in the root, along with any necessary parents.
		 * See [MkdirAll] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * MkdirAll returns an error.
		 */
		MkdirAll(name: string, perm: FileMode): Error | null;
		/**
		 * Chown changes the numeric uid and gid of the named file in the root.
		 * See [Chown] for more details.
		 */
		Chown(name: string, uid: number, gid: number): Error | null;
		/**
		 * Lchown changes the numeric uid and gid of the named file in the root.
		 * See [Lchown] for more details.
		 */
		Lchown(name: string, uid: number, gid: number): Error | null;
		/**
		 * Chtimes changes the access and modification times of the named file in the root.
		 * See [Chtimes] for more details.
		 */
		Chtimes(name: string, atime: time.Time, mtime: time.Time): Error | null;
		/**
		 * Remove removes the named file or (empty) directory in the root.
		 * See [Remove] for more details.
		 */
		Remove(name: string): Error | null;
		/**
		 * RemoveAll removes the named file or directory and any children that it contains.
		 * See [RemoveAll] for more details.
		 */
		RemoveAll(name: string): Error | null;
		/**
		 * Stat returns a [FileInfo] describing the named file in the root.
		 * See [Stat] for more details.
		 */
		Stat(name: string): [FileInfo, Error | null];
		/**
		 * Lstat returns a [FileInfo] describing the named file in the root.
		 * If the file is a symbolic link, the returned FileInfo
		 * describes the symbolic link.
		 * See [Lstat] for more details.
		 */
		Lstat(name: string): [FileInfo, Error | null];
		/**
		 * Readlink returns the destination of the named symbolic link in the root.
		 * See [Readlink] for more details.
		 */
		Readlink(name: string): [string, Error | null];
		/**
		 * Rename renames (moves) oldname to newname.
		 * Both paths are relative to the root.
		 * See [Rename] for more details.
		 */
		Rename(oldname: string, newname: string): Error | null;
		/**
		 * Link creates newname as a hard link to the oldname file.
		 * Both paths are relative to the root.
		 * See [Link] for more details.
		 * 
		 * If oldname is a symbolic link, Link creates new link to oldname and not its target.
		 * This behavior may differ from that of [Link] on some platforms.
		 * 
		 * When GOOS=js, Link returns an error if oldname is a symbolic link.
		 */
		Link(oldname: string, newname: string): Error | null;
		/**
		 * Symlink creates newname as a symbolic link to oldname.
		 * See [Symlink] for more details.
		 * 
		 * Symlink does not validate oldname,
		 * which may reference a location outside the root.
		 * 
		 * On Windows, a directory link is created if oldname references
		 * a directory within the root. Otherwise a file link is created.
		 */
		Symlink(oldname: string, newname: string): Error | null;
		/**
		 * ReadFile reads the named file in the root and returns its contents.
		 * See [ReadFile] for more details.
		 */
		ReadFile(name: string): [byte[], Error | null];
		/**
		 * WriteFile writes data to the named file in the root, creating it if necessary.
		 * See [WriteFile] for more details.
		 */
		WriteFile(name: string, data: byte[], perm: FileMode): Error | null;
		/**
		 * FS returns a file system (an fs.FS) for the tree of files in the root.
		 * 
		 * The result implements [io/fs.StatFS], [io/fs.ReadFileFS],
		 * [io/fs.ReadDirFS], and [io/fs.ReadLinkFS].
		 */
		FS(): fs.FS;
	}

	/**
	 * File represents an open file descriptor.
	 * 
	 * The methods of File are safe for concurrent use.
	 */
	export interface File {
	}

	/**
	 * ReadDir reads the named directory,
	 * returning all its directory entries sorted by filename.
	 * If an error occurs reading the directory,
	 * ReadDir returns the entries it was able to read before the error,
	 * along with the error.
	 */
	export function ReadDir(name: string): DirEntry[];
	/**
	 * CopyFS copies the file system fsys into the directory dir,
	 * creating dir if necessary.
	 * 
	 * Files are created with mode 0o666 plus any execute permissions
	 * from the source, and directories are created with mode 0o777
	 * (before umask).
	 * 
	 * CopyFS will not overwrite existing files. If a file name in fsys
	 * already exists in the destination, CopyFS will return an error
	 * such that errors.Is(err, fs.ErrExist) will be true.
	 * 
	 * Symbolic links in dir are followed.
	 * 
	 * New files added to fsys (including if dir is a subdirectory of fsys)
	 * while CopyFS is running are not guaranteed to be copied.
	 * 
	 * Copying stops at and returns the first error encountered.
	 */
	export function CopyFS(dir: string, fsys: fs.FS): void;
	/**
	 * Expand replaces  or  in the string based on the mapping function.
	 * For example, [os.ExpandEnv](s) is equivalent to [os.Expand](s, [os.Getenv]).
	 */
	export function Expand(s: string, mapping: (...args: unknown[]) => unknown): string;
	/**
	 * ExpandEnv replaces  or  in the string according to the values
	 * of the current environment variables. References to undefined
	 * variables are replaced by the empty string.
	 */
	export function ExpandEnv(s: string): string;
	/**
	 * Getenv retrieves the value of the environment variable named by the key.
	 * It returns the value, which will be empty if the variable is not present.
	 * To distinguish between an empty value and an unset value, use [LookupEnv].
	 */
	export function Getenv(key: string): string;
	/**
	 * LookupEnv retrieves the value of the environment variable named
	 * by the key. If the variable is present in the environment the
	 * value (which may be empty) is returned and the boolean is true.
	 * Otherwise the returned value will be empty and the boolean will
	 * be false.
	 */
	export function LookupEnv(key: string): [string, boolean];
	/**
	 * Setenv sets the value of the environment variable named by the key.
	 * It returns an error, if any.
	 */
	export function Setenv(key: string, value: string): void;
	/**
	 * Unsetenv unsets a single environment variable.
	 */
	export function Unsetenv(key: string): void;
	/**
	 * Clearenv deletes all environment variables.
	 */
	export function Clearenv(): void;
	/**
	 * Environ returns a copy of strings representing the environment,
	 * in the form "key=value".
	 */
	export function Environ(): string[];
	/**
	 * NewSyscallError returns, as an error, a new [SyscallError]
	 * with the given system call name and error details.
	 * As a convenience, if err is nil, NewSyscallError returns nil.
	 */
	export function NewSyscallError(syscall: string, err: Error | null): void;
	/**
	 * IsExist returns a boolean indicating whether its argument is known to report
	 * that a file or directory already exists. It is satisfied by [ErrExist] as
	 * well as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrExist).
	 */
	export function IsExist(err: Error | null): boolean;
	/**
	 * IsNotExist returns a boolean indicating whether its argument is known to
	 * report that a file or directory does not exist. It is satisfied by
	 * [ErrNotExist] as well as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrNotExist).
	 */
	export function IsNotExist(err: Error | null): boolean;
	/**
	 * IsPermission returns a boolean indicating whether its argument is known to
	 * report that permission is denied. It is satisfied by [ErrPermission] as well
	 * as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrPermission).
	 */
	export function IsPermission(err: Error | null): boolean;
	/**
	 * IsTimeout returns a boolean indicating whether its argument is known
	 * to report that a timeout occurred.
	 * 
	 * This function predates [errors.Is], and the notion of whether an
	 * error indicates a timeout can be ambiguous. For example, the Unix
	 * error EWOULDBLOCK sometimes indicates a timeout and sometimes does not.
	 * New code should use errors.Is with a value appropriate to the call
	 * returning the error, such as [os.ErrDeadlineExceeded].
	 */
	export function IsTimeout(err: Error | null): boolean;
	/**
	 * Getpid returns the process id of the caller.
	 */
	export function Getpid(): number;
	/**
	 * Getppid returns the process id of the caller's parent.
	 */
	export function Getppid(): number;
	/**
	 * FindProcess looks for a running process by its pid.
	 * 
	 * The [Process] it returns can be used to obtain information
	 * about the underlying operating system process.
	 * 
	 * On Unix systems, FindProcess always succeeds and returns a Process
	 * for the given pid, regardless of whether the process exists. To test whether
	 * the process actually exists, see whether p.Signal(syscall.Signal(0)) reports
	 * an error.
	 */
	export function FindProcess(pid: number): Process;
	/**
	 * StartProcess starts a new process with the program, arguments and attributes
	 * specified by name, argv and attr. The argv slice will become [os.Args] in the
	 * new process, so it normally starts with the program name.
	 * 
	 * If the calling goroutine has locked the operating system thread
	 * with [runtime.LockOSThread] and modified any inheritable OS-level
	 * thread state (for example, Linux or Plan 9 name spaces), the new
	 * process will inherit the caller's thread state.
	 * 
	 * StartProcess is a low-level interface. The [os/exec] package provides
	 * higher-level interfaces.
	 * 
	 * If there is an error, it will be of type [*PathError].
	 */
	export function StartProcess(name: string, argv: string[], attr: ProcAttr): Process;
	/**
	 * Executable returns the path name for the executable that started
	 * the current process. There is no guarantee that the path is still
	 * pointing to the correct executable. If a symlink was used to start
	 * the process, depending on the operating system, the result might
	 * be the symlink or the path it pointed to. If a stable result is
	 * needed, [path/filepath.EvalSymlinks] might help.
	 * 
	 * Executable returns an absolute path unless an error occurred.
	 * 
	 * The main use case is finding resources located relative to an
	 * executable.
	 */
	export function Executable(): string;
	/**
	 * NewFile returns a new [File] with the given file descriptor and name.
	 * The returned value will be nil if fd is not a valid file descriptor.
	 * 
	 * NewFile's behavior differs on some platforms:
	 * 
	 *   - On Unix, if fd is in non-blocking mode, NewFile will attempt to return a pollable file.
	 *   - On Windows, if fd is opened for asynchronous I/O (that is, [syscall.FILE_FLAG_OVERLAPPED]
	 *     has been specified in the [syscall.CreateFile] call), NewFile will attempt to return a pollable
	 *     file by associating fd with the Go runtime I/O completion port.
	 *     The I/O operations will be performed synchronously if the association fails.
	 * 
	 * Only pollable files support [File.SetDeadline], [File.SetReadDeadline], and [File.SetWriteDeadline].
	 * 
	 * After passing it to NewFile, fd may become invalid under the same conditions described
	 * in the comments of [File.Fd], and the same constraints apply.
	 */
	export function NewFile(fd: uintptr, name: string): File;
	/**
	 * Mkdir creates a new directory with the specified name and permission
	 * bits (before umask).
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Mkdir(name: string, perm: FileMode): void;
	/**
	 * Chdir changes the current working directory to the named directory.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Chdir(dir: string): void;
	/**
	 * Open opens the named file for reading. If successful, methods on
	 * the returned file can be used for reading; the associated file
	 * descriptor has mode [O_RDONLY].
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Open(name: string): File;
	/**
	 * Create creates or truncates the named file. If the file already exists,
	 * it is truncated. If the file does not exist, it is created with mode 0o666
	 * (before umask). If successful, methods on the returned File can
	 * be used for I/O; the associated file descriptor has mode [O_RDWR].
	 * The directory containing the file must already exist.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Create(name: string): File;
	/**
	 * OpenFile is the generalized open call; most users will use Open
	 * or Create instead. It opens the named file with specified flag
	 * ([O_RDONLY] etc.). If the file does not exist, and the [O_CREATE] flag
	 * is passed, it is created with mode perm (before umask);
	 * the containing directory must exist. If successful,
	 * methods on the returned File can be used for I/O.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function OpenFile(name: string, flag: number, perm: FileMode): File;
	/**
	 * Rename renames (moves) oldpath to newpath.
	 * If newpath already exists and is not a directory, Rename replaces it.
	 * If newpath already exists and is a directory, Rename returns an error.
	 * OS-specific restrictions may apply when oldpath and newpath are in different directories.
	 * Even within the same directory, on non-Unix platforms Rename is not an atomic operation.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Rename(oldpath: string, newpath: string): void;
	/**
	 * Readlink returns the destination of the named symbolic link.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * If the link destination is relative, Readlink returns the relative path
	 * without resolving it to an absolute one.
	 */
	export function Readlink(name: string): string;
	/**
	 * TempDir returns the default directory to use for temporary files.
	 * 
	 * On Unix systems, it returns  if non-empty, else /tmp.
	 * On Windows, it uses GetTempPath, returning the first non-empty
	 * value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.
	 * On Plan 9, it returns /tmp.
	 * 
	 * The directory is neither guaranteed to exist nor have accessible
	 * permissions.
	 */
	export function TempDir(): string;
	/**
	 * UserCacheDir returns the default root directory to use for user-specific
	 * cached data. Users should create their own application-specific subdirectory
	 * within this one and use that.
	 * 
	 * On Unix systems, it returns  as specified by
	 * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
	 * non-empty, else /.cache.
	 * On Darwin, it returns /Library/Caches.
	 * On Windows, it returns %LocalAppData%.
	 * On Plan 9, it returns /lib/cache.
	 * 
	 * If the location cannot be determined (for example,  is not defined) or
	 * the path in  is relative, then it will return an error.
	 */
	export function UserCacheDir(): string;
	/**
	 * UserConfigDir returns the default root directory to use for user-specific
	 * configuration data. Users should create their own application-specific
	 * subdirectory within this one and use that.
	 * 
	 * On Unix systems, it returns  as specified by
	 * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
	 * non-empty, else /.config.
	 * On Darwin, it returns /Library/Application Support.
	 * On Windows, it returns %AppData%.
	 * On Plan 9, it returns /lib.
	 * 
	 * If the location cannot be determined (for example,  is not defined) or
	 * the path in  is relative, then it will return an error.
	 */
	export function UserConfigDir(): string;
	/**
	 * UserHomeDir returns the current user's home directory.
	 * 
	 * On Unix, including macOS, it returns the  environment variable.
	 * On Windows, it returns %USERPROFILE%.
	 * On Plan 9, it returns the  environment variable.
	 * 
	 * If the expected variable is not set in the environment, UserHomeDir
	 * returns either a platform-specific default value or a non-nil error.
	 */
	export function UserHomeDir(): string;
	/**
	 * Chmod changes the mode of the named file to mode.
	 * If the file is a symbolic link, it changes the mode of the link's target.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * A different subset of the mode bits are used, depending on the
	 * operating system.
	 * 
	 * On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and
	 * [ModeSticky] are used.
	 * 
	 * On Windows, only the 0o200 bit (owner writable) of mode is used; it
	 * controls whether the file's read-only attribute is set or cleared.
	 * The other bits are currently unused. For compatibility with Go 1.12
	 * and earlier, use a non-zero mode. Use mode 0o400 for a read-only
	 * file and 0o600 for a readable+writable file.
	 * 
	 * On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive],
	 * and [ModeTemporary] are used.
	 */
	export function Chmod(name: string, mode: FileMode): void;
	/**
	 * DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.
	 * 
	 * Note that DirFS("/prefix") only guarantees that the Open calls it makes to the
	 * operating system will begin with "/prefix": DirFS("/prefix").Open("file") is the
	 * same as os.Open("/prefix/file"). So if /prefix/file is a symbolic link pointing outside
	 * the /prefix tree, then using DirFS does not stop the access any more than using
	 * os.Open does. Additionally, the root of the fs.FS returned for a relative path,
	 * DirFS("prefix"), will be affected by later calls to Chdir. DirFS is therefore not
	 * a general substitute for a chroot-style security mechanism when the directory tree
	 * contains arbitrary content.
	 * 
	 * Use [Root.FS] to obtain a fs.FS that prevents escapes from the tree via symbolic links.
	 * 
	 * The directory dir must not be "".
	 * 
	 * The result implements [io/fs.StatFS], [io/fs.ReadFileFS], [io/fs.ReadDirFS], and
	 * [io/fs.ReadLinkFS].
	 */
	export function DirFS(dir: string): fs.FS;
	/**
	 * ReadFile reads the named file and returns the contents.
	 * A successful call returns err == nil, not err == EOF.
	 * Because ReadFile reads the whole file, it does not treat an EOF from Read
	 * as an error to be reported.
	 */
	export function ReadFile(name: string): byte[];
	/**
	 * WriteFile writes data to the named file, creating it if necessary.
	 * If the file does not exist, WriteFile creates it with permissions perm (before umask);
	 * otherwise WriteFile truncates it before writing, without changing permissions.
	 * Since WriteFile requires multiple system calls to complete, a failure mid-operation
	 * can leave the file in a partially written state.
	 */
	export function WriteFile(name: string, data: byte[], perm: FileMode): void;
	/**
	 * Chown changes the numeric uid and gid of the named file.
	 * If the file is a symbolic link, it changes the uid and gid of the link's target.
	 * A uid or gid of -1 means to not change that value.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or
	 * [syscall.EPLAN9] error, wrapped in [*PathError].
	 */
	export function Chown(name: string, uid: number, gid: number): void;
	/**
	 * Lchown changes the numeric uid and gid of the named file.
	 * If the file is a symbolic link, it changes the uid and gid of the link itself.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows, it always returns the [syscall.EWINDOWS] error, wrapped
	 * in [*PathError].
	 */
	export function Lchown(name: string, uid: number, gid: number): void;
	/**
	 * Chtimes changes the access and modification times of the named
	 * file, similar to the Unix utime() or utimes() functions.
	 * A zero [time.Time] value will leave the corresponding file time unchanged.
	 * 
	 * The underlying filesystem may truncate or round the values to a
	 * less precise time unit.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Chtimes(name: string, atime: time.Time, mtime: time.Time): void;
	/**
	 * Truncate changes the size of the named file.
	 * If the file is a symbolic link, it changes the size of the link's target.
	 */
	export function Truncate(name: string, size: number): void;
	/**
	 * Remove removes the named file or directory.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Remove(name: string): void;
	/**
	 * Pipe returns a connected pair of Files; reads from r return bytes written to w.
	 * It returns the files and an error, if any. The Windows handles underlying
	 * the returned files are marked as inheritable by child processes.
	 */
	export function Pipe(): [File, File];
	/**
	 * Link creates newname as a hard link to the oldname file.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Link(oldname: string, newname: string): void;
	/**
	 * Symlink creates newname as a symbolic link to oldname.
	 * On Windows, a symlink to a non-existent oldname creates a file symlink;
	 * if oldname is later created as a directory the symlink will not work.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Symlink(oldname: string, newname: string): void;
	/**
	 * Getwd returns an absolute path name corresponding to the
	 * current directory. If the current directory can be
	 * reached via multiple paths (due to symbolic links),
	 * Getwd may return any one of them.
	 * 
	 * On Unix platforms, if the environment variable PWD
	 * provides an absolute name, and it is a name of the
	 * current directory, it is returned.
	 */
	export function Getwd(): string;
	/**
	 * MkdirAll creates a directory named path,
	 * along with any necessary parents, and returns nil,
	 * or else returns an error.
	 * The permission bits perm (before umask) are used for all
	 * directories that MkdirAll creates.
	 * If path is already a directory, MkdirAll does nothing
	 * and returns nil.
	 */
	export function MkdirAll(path: string, perm: FileMode): void;
	/**
	 * RemoveAll removes path and any children it contains.
	 * It removes everything it can but returns the first error
	 * it encounters. If the path does not exist, RemoveAll
	 * returns nil (no error).
	 * If there is an error, it will be of type [*PathError].
	 */
	export function RemoveAll(path: string): void;
	/**
	 * IsPathSeparator reports whether c is a directory separator character.
	 */
	export function IsPathSeparator(c: number): boolean;
	/**
	 * Getuid returns the numeric user id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getuid(): number;
	/**
	 * Geteuid returns the numeric effective user id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Geteuid(): number;
	/**
	 * Getgid returns the numeric group id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getgid(): number;
	/**
	 * Getegid returns the numeric effective group id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getegid(): number;
	/**
	 * Getgroups returns a list of the numeric ids of groups that the caller belongs to.
	 * 
	 * On Windows, it returns [syscall.EWINDOWS]. See the [os/user] package
	 * for a possible alternative.
	 */
	export function Getgroups(): number[];
	/**
	 * Exit causes the current program to exit with the given status code.
	 * Conventionally, code zero indicates success, non-zero an error.
	 * The program terminates immediately; deferred functions are not run.
	 * 
	 * For portability, the status code should be in the range [0, 125].
	 */
	export function Exit(code: number): void;
	/**
	 * OpenInRoot opens the file name in the directory dir.
	 * It is equivalent to OpenRoot(dir) followed by opening the file in the root.
	 * 
	 * OpenInRoot returns an error if any component of the name
	 * references a location outside of dir.
	 * 
	 * See [Root] for details and limitations.
	 */
	export function OpenInRoot(dir: string, name: string): File;
	/**
	 * OpenRoot opens the named directory.
	 * It follows symbolic links in the directory name.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function OpenRoot(name: string): Root;
	/**
	 * Stat returns a [FileInfo] describing the named file.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Stat(name: string): FileInfo;
	/**
	 * Lstat returns a [FileInfo] describing the named file.
	 * If the file is a symbolic link, the returned FileInfo
	 * describes the symbolic link. Lstat makes no attempt to follow the link.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows, if the file is a reparse point that is a surrogate for another
	 * named entity (such as a symbolic link or mounted folder), the returned
	 * FileInfo describes the reparse point, and makes no attempt to resolve it.
	 */
	export function Lstat(name: string): FileInfo;
	/**
	 * Hostname returns the host name reported by the kernel.
	 */
	export function Hostname(): string;
	/**
	 * CreateTemp creates a new temporary file in the directory dir,
	 * opens the file for reading and writing, and returns the resulting file.
	 * The filename is generated by taking pattern and adding a random string to the end.
	 * If pattern includes a "*", the random string replaces the last "*".
	 * The file is created with mode 0o600 (before umask).
	 * If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
	 * Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
	 * The caller can use the file's Name method to find the pathname of the file.
	 * It is the caller's responsibility to remove the file when it is no longer needed.
	 */
	export function CreateTemp(dir: string, pattern: string): File;
	/**
	 * MkdirTemp creates a new temporary directory in the directory dir
	 * and returns the pathname of the new directory.
	 * The new directory's name is generated by adding a random string to the end of pattern.
	 * If pattern includes a "*", the random string replaces the last "*" instead.
	 * The directory is created with mode 0o700 (before umask).
	 * If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
	 * Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
	 * It is the caller's responsibility to remove the directory when it is no longer needed.
	 */
	export function MkdirTemp(dir: string, pattern: string): string;
	/**
	 * Getpagesize returns the underlying system's memory page size.
	 */
	export function Getpagesize(): number;
	/**
	 * SameFile reports whether fi1 and fi2 describe the same file.
	 * For example, on Unix this means that the device and inode fields
	 * of the two underlying structures are identical; on other systems
	 * the decision may be based on the path names.
	 * SameFile only applies to results returned by this package's [Stat].
	 * It returns false in other cases.
	 */
	export function SameFile(fi1: FileInfo, fi2: FileInfo): boolean;
}
// END: go:go:os

// MODULE: go:go:fmt
declare module "go:go:fmt" {
	/**
	 * Errorf formats according to a format specifier and returns the string as a
	 * value that satisfies error.
	 * 
	 * If the format specifier includes a %w verb with an error operand,
	 * the returned error will implement an Unwrap method returning the operand.
	 * If there is more than one %w verb, the returned error will implement an
	 * Unwrap method returning a []error containing all the %w operands in the
	 * order they appear in the arguments.
	 * It is invalid to supply the %w verb with an operand that does not implement
	 * the error interface. The %w verb is otherwise a synonym for %v.
	 */
	export function Errorf(format: string, ...a: any[]): void;
	/**
	 * FormatString returns a string representing the fully qualified formatting
	 * directive captured by the [State], followed by the argument verb. ([State] does not
	 * itself contain the verb.) The result has a leading percent sign followed by any
	 * flags, the width, and the precision. Missing flags, width, and precision are
	 * omitted. This function allows a [Formatter] to reconstruct the original
	 * directive triggering the call to Format.
	 */
	export function FormatString(state: State, verb: rune): string;
	/**
	 * Fprintf formats according to a format specifier and writes to w.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprintf(w: io.Writer, format: string, ...a: any[]): number;
	/**
	 * Printf formats according to a format specifier and writes to standard output.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Printf(format: string, ...a: any[]): number;
	/**
	 * Sprintf formats according to a format specifier and returns the resulting string.
	 */
	export function Sprintf(format: string, ...a: any[]): string;
	/**
	 * Appendf formats according to a format specifier, appends the result to the byte
	 * slice, and returns the updated slice.
	 */
	export function Appendf(b: byte[], format: string, ...a: any[]): byte[];
	/**
	 * Fprint formats using the default formats for its operands and writes to w.
	 * Spaces are added between operands when neither is a string.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprint(w: io.Writer, ...a: any[]): number;
	/**
	 * Print formats using the default formats for its operands and writes to standard output.
	 * Spaces are added between operands when neither is a string.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Print(...a: any[]): number;
	/**
	 * Sprint formats using the default formats for its operands and returns the resulting string.
	 * Spaces are added between operands when neither is a string.
	 */
	export function Sprint(...a: any[]): string;
	/**
	 * Append formats using the default formats for its operands, appends the result to
	 * the byte slice, and returns the updated slice.
	 */
	export function Append(b: byte[], ...a: any[]): byte[];
	/**
	 * Fprintln formats using the default formats for its operands and writes to w.
	 * Spaces are always added between operands and a newline is appended.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprintln(w: io.Writer, ...a: any[]): number;
	/**
	 * Println formats using the default formats for its operands and writes to standard output.
	 * Spaces are always added between operands and a newline is appended.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Println(...a: any[]): number;
	/**
	 * Sprintln formats using the default formats for its operands and returns the resulting string.
	 * Spaces are always added between operands and a newline is appended.
	 */
	export function Sprintln(...a: any[]): string;
	/**
	 * Appendln formats using the default formats for its operands, appends the result
	 * to the byte slice, and returns the updated slice. Spaces are always added
	 * between operands and a newline is appended.
	 */
	export function Appendln(b: byte[], ...a: any[]): byte[];
	/**
	 * Scan scans text read from standard input, storing successive
	 * space-separated values into successive arguments. Newlines count
	 * as space. It returns the number of items successfully scanned.
	 * If that is less than the number of arguments, err will report why.
	 */
	export function Scan(...a: any[]): number;
	/**
	 * Scanln is similar to [Scan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Scanln(...a: any[]): number;
	/**
	 * Scanf scans text read from standard input, storing successive
	 * space-separated values into successive arguments as determined by
	 * the format. It returns the number of items successfully scanned.
	 * If that is less than the number of arguments, err will report why.
	 * Newlines in the input must match newlines in the format.
	 * The one exception: the verb %c always scans the next rune in the
	 * input, even if it is a space (or tab etc.) or newline.
	 */
	export function Scanf(format: string, ...a: any[]): number;
	/**
	 * Sscan scans the argument string, storing successive space-separated
	 * values into successive arguments. Newlines count as space. It
	 * returns the number of items successfully scanned. If that is less
	 * than the number of arguments, err will report why.
	 */
	export function Sscan(str: string, ...a: any[]): number;
	/**
	 * Sscanln is similar to [Sscan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Sscanln(str: string, ...a: any[]): number;
	/**
	 * Sscanf scans the argument string, storing successive space-separated
	 * values into successive arguments as determined by the format. It
	 * returns the number of items successfully parsed.
	 * Newlines in the input must match newlines in the format.
	 */
	export function Sscanf(str: string, format: string, ...a: any[]): number;
	/**
	 * Fscan scans text read from r, storing successive space-separated
	 * values into successive arguments. Newlines count as space. It
	 * returns the number of items successfully scanned. If that is less
	 * than the number of arguments, err will report why.
	 */
	export function Fscan(r: io.Reader, ...a: any[]): number;
	/**
	 * Fscanln is similar to [Fscan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Fscanln(r: io.Reader, ...a: any[]): number;
	/**
	 * Fscanf scans text read from r, storing successive space-separated
	 * values into successive arguments as determined by the format. It
	 * returns the number of items successfully parsed.
	 * Newlines in the input must match newlines in the format.
	 */
	export function Fscanf(r: io.Reader, format: string, ...a: any[]): number;
}
// END: go:go:fmt

// MODULE: go:go:github.com/fatih/color
declare module "go:go:github.com/fatih/color" {
	/**
	 * Color defines a custom color object which is defined by SGR parameters.
	 */
	export interface Color {
		/**
		 * AddRGB is used to chain foreground RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddRGB(r: number, g: number, b: number): Color;
		/**
		 * AddRGB is used to chain background RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddBgRGB(r: number, g: number, b: number): Color;
		/**
		 * Set sets the SGR sequence.
		 */
		Set(): Color;
		/**
		 * SetWriter is used to set the SGR sequence with the given io.Writer. This is
		 * a low-level function, and users should use the higher-level functions, such
		 * as color.Fprint, color.Print, etc.
		 */
		SetWriter(w: io.Writer): Color;
		/**
		 * UnsetWriter resets all escape attributes and clears the output with the give
		 * io.Writer. Usually should be called after SetWriter().
		 */
		UnsetWriter(w: io.Writer): void;
		/**
		 * Add is used to chain SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: Add(color.FgRed, color.Underline).
		 */
		Add(...value: Attribute[]): Color;
		/**
		 * Fprint formats using the default formats for its operands and writes to w.
		 * Spaces are added between operands when neither is a string.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprint(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Print formats using the default formats for its operands and writes to
		 * standard output. Spaces are added between operands when neither is a
		 * string. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Print(...a: any[]): [number, Error | null];
		/**
		 * Fprintf formats according to a format specifier and writes to w.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintf(w: io.Writer, format: string, ...a: any[]): [number, Error | null];
		/**
		 * Printf formats according to a format specifier and writes to standard output.
		 * It returns the number of bytes written and any write error encountered.
		 * This is the standard fmt.Printf() method wrapped with the given color.
		 */
		Printf(format: string, ...a: any[]): [number, Error | null];
		/**
		 * Fprintln formats using the default formats for its operands and writes to w.
		 * Spaces are always added between operands and a newline is appended.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintln(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Println formats using the default formats for its operands and writes to
		 * standard output. Spaces are always added between operands and a newline is
		 * appended. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Println(...a: any[]): [number, Error | null];
		/**
		 * Sprint is just like Print, but returns a string instead of printing it.
		 */
		Sprint(...a: any[]): string;
		/**
		 * Sprintln is just like Println, but returns a string instead of printing it.
		 */
		Sprintln(...a: any[]): string;
		/**
		 * Sprintf is just like Printf, but returns a string instead of printing it.
		 */
		Sprintf(format: string, ...a: any[]): string;
		/**
		 * FprintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprint().
		 */
		FprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Print().
		 */
		PrintFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintf().
		 */
		FprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Printf().
		 */
		PrintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintln().
		 */
		FprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Println().
		 */
		PrintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprint(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output, example:
		 * 
		 * 	put := New(FgYellow).SprintFunc()
		 * 	fmt.Fprintf(color.Output, "This is a %s", put("warning"))
		 */
		SprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintfFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintf(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintlnFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintln(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * DisableColor disables the color output. Useful to not change any existing
		 * code and still being able to output. Can be used for flags like
		 * "--no-color". To enable back use EnableColor() method.
		 */
		DisableColor(): void;
		/**
		 * EnableColor enables the color output. Use it in conjunction with
		 * DisableColor(). Otherwise, this method has no side effects.
		 */
		EnableColor(): void;
		/**
		 * Equals returns a boolean value indicating whether two colors are equal.
		 */
		Equals(c2: Color): boolean;
	}

	/**
	 * New returns a newly created color object.
	 */
	export function New(...value: Attribute[]): Color;
	/**
	 * RGB returns a new foreground color in 24-bit RGB.
	 */
	export function RGB(r: number, g: number, b: number): Color;
	/**
	 * BgRGB returns a new background color in 24-bit RGB.
	 */
	export function BgRGB(r: number, g: number, b: number): Color;
	/**
	 * Set sets the given parameters immediately. It will change the color of
	 * output with the given SGR parameters until color.Unset() is called.
	 */
	export function Set(...p: Attribute[]): Color;
	/**
	 * Unset resets all escape attributes and clears the output. Usually should
	 * be called after Set().
	 */
	export function Unset(): void;
	/**
	 * Black is a convenient helper function to print with black foreground. A
	 * newline is appended to format by default.
	 */
	export function Black(format: string, ...a: any[]): void;
	/**
	 * Red is a convenient helper function to print with red foreground. A
	 * newline is appended to format by default.
	 */
	export function Red(format: string, ...a: any[]): void;
	/**
	 * Green is a convenient helper function to print with green foreground. A
	 * newline is appended to format by default.
	 */
	export function Green(format: string, ...a: any[]): void;
	/**
	 * Yellow is a convenient helper function to print with yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function Yellow(format: string, ...a: any[]): void;
	/**
	 * Blue is a convenient helper function to print with blue foreground. A
	 * newline is appended to format by default.
	 */
	export function Blue(format: string, ...a: any[]): void;
	/**
	 * Magenta is a convenient helper function to print with magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function Magenta(format: string, ...a: any[]): void;
	/**
	 * Cyan is a convenient helper function to print with cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function Cyan(format: string, ...a: any[]): void;
	/**
	 * White is a convenient helper function to print with white foreground. A
	 * newline is appended to format by default.
	 */
	export function White(format: string, ...a: any[]): void;
	/**
	 * BlackString is a convenient helper function to return a string with black
	 * foreground.
	 */
	export function BlackString(format: string, ...a: any[]): string;
	/**
	 * RedString is a convenient helper function to return a string with red
	 * foreground.
	 */
	export function RedString(format: string, ...a: any[]): string;
	/**
	 * GreenString is a convenient helper function to return a string with green
	 * foreground.
	 */
	export function GreenString(format: string, ...a: any[]): string;
	/**
	 * YellowString is a convenient helper function to return a string with yellow
	 * foreground.
	 */
	export function YellowString(format: string, ...a: any[]): string;
	/**
	 * BlueString is a convenient helper function to return a string with blue
	 * foreground.
	 */
	export function BlueString(format: string, ...a: any[]): string;
	/**
	 * MagentaString is a convenient helper function to return a string with magenta
	 * foreground.
	 */
	export function MagentaString(format: string, ...a: any[]): string;
	/**
	 * CyanString is a convenient helper function to return a string with cyan
	 * foreground.
	 */
	export function CyanString(format: string, ...a: any[]): string;
	/**
	 * WhiteString is a convenient helper function to return a string with white
	 * foreground.
	 */
	export function WhiteString(format: string, ...a: any[]): string;
	/**
	 * HiBlack is a convenient helper function to print with hi-intensity black foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlack(format: string, ...a: any[]): void;
	/**
	 * HiRed is a convenient helper function to print with hi-intensity red foreground. A
	 * newline is appended to format by default.
	 */
	export function HiRed(format: string, ...a: any[]): void;
	/**
	 * HiGreen is a convenient helper function to print with hi-intensity green foreground. A
	 * newline is appended to format by default.
	 */
	export function HiGreen(format: string, ...a: any[]): void;
	/**
	 * HiYellow is a convenient helper function to print with hi-intensity yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function HiYellow(format: string, ...a: any[]): void;
	/**
	 * HiBlue is a convenient helper function to print with hi-intensity blue foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlue(format: string, ...a: any[]): void;
	/**
	 * HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function HiMagenta(format: string, ...a: any[]): void;
	/**
	 * HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function HiCyan(format: string, ...a: any[]): void;
	/**
	 * HiWhite is a convenient helper function to print with hi-intensity white foreground. A
	 * newline is appended to format by default.
	 */
	export function HiWhite(format: string, ...a: any[]): void;
	/**
	 * HiBlackString is a convenient helper function to return a string with hi-intensity black
	 * foreground.
	 */
	export function HiBlackString(format: string, ...a: any[]): string;
	/**
	 * HiRedString is a convenient helper function to return a string with hi-intensity red
	 * foreground.
	 */
	export function HiRedString(format: string, ...a: any[]): string;
	/**
	 * HiGreenString is a convenient helper function to return a string with hi-intensity green
	 * foreground.
	 */
	export function HiGreenString(format: string, ...a: any[]): string;
	/**
	 * HiYellowString is a convenient helper function to return a string with hi-intensity yellow
	 * foreground.
	 */
	export function HiYellowString(format: string, ...a: any[]): string;
	/**
	 * HiBlueString is a convenient helper function to return a string with hi-intensity blue
	 * foreground.
	 */
	export function HiBlueString(format: string, ...a: any[]): string;
	/**
	 * HiMagentaString is a convenient helper function to return a string with hi-intensity magenta
	 * foreground.
	 */
	export function HiMagentaString(format: string, ...a: any[]): string;
	/**
	 * HiCyanString is a convenient helper function to return a string with hi-intensity cyan
	 * foreground.
	 */
	export function HiCyanString(format: string, ...a: any[]): string;
	/**
	 * HiWhiteString is a convenient helper function to return a string with hi-intensity white
	 * foreground.
	 */
	export function HiWhiteString(format: string, ...a: any[]): string;
}
// END: go:go:github.com/fatih/color

// MODULE: go:go:net/url
declare module "go:go:net/url" {
	import { Userinfo } from "go:net/url";

	/**
	 * Error reports an error and the operation and URL that caused it.
	 */
	export interface Error {
		Op: string;
		URL: string;
		Err: Error | null;
		Unwrap(): Error | null;
		Error(): string;
		Timeout(): boolean;
		Temporary(): boolean;
	}

	/**
	 * A URL represents a parsed URL (technically, a URI reference).
	 * 
	 * The general form represented is:
	 * 
	 * 	[scheme:][//[userinfo@]host][/]path[?query][#fragment]
	 * 
	 * URLs that do not start with a slash after the scheme are interpreted as:
	 * 
	 * 	scheme:opaque[?query][#fragment]
	 * 
	 * The Host field contains the host and port subcomponents of the URL.
	 * When the port is present, it is separated from the host with a colon.
	 * When the host is an IPv6 address, it must be enclosed in square brackets:
	 * "[fe80::1]:80". The [net.JoinHostPort] function combines a host and port
	 * into a string suitable for the Host field, adding square brackets to
	 * the host when necessary.
	 * 
	 * Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
	 * A consequence is that it is impossible to tell which slashes in the Path were
	 * slashes in the raw URL and which were %2f. This distinction is rarely important,
	 * but when it is, the code should use the [URL.EscapedPath] method, which preserves
	 * the original encoding of Path.
	 * 
	 * The RawPath field is an optional field which is only set when the default
	 * encoding of Path is different from the escaped path. See the EscapedPath method
	 * for more details.
	 * 
	 * URL's String method uses the EscapedPath method to obtain the path.
	 */
	export interface URL {
		Scheme: string;
		Opaque: string;
		User: Userinfo;
		Host: string;
		Path: string;
		RawPath: string;
		OmitHost: boolean;
		ForceQuery: boolean;
		RawQuery: string;
		Fragment: string;
		RawFragment: string;
		/**
		 * EscapedPath returns the escaped form of u.Path.
		 * In general there are multiple possible escaped forms of any path.
		 * EscapedPath returns u.RawPath when it is a valid escaping of u.Path.
		 * Otherwise EscapedPath ignores u.RawPath and computes an escaped
		 * form on its own.
		 * The [URL.String] and [URL.RequestURI] methods use EscapedPath to construct
		 * their results.
		 * In general, code should call EscapedPath instead of
		 * reading u.RawPath directly.
		 */
		EscapedPath(): string;
		/**
		 * EscapedFragment returns the escaped form of u.Fragment.
		 * In general there are multiple possible escaped forms of any fragment.
		 * EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment.
		 * Otherwise EscapedFragment ignores u.RawFragment and computes an escaped
		 * form on its own.
		 * The [URL.String] method uses EscapedFragment to construct its result.
		 * In general, code should call EscapedFragment instead of
		 * reading u.RawFragment directly.
		 */
		EscapedFragment(): string;
		/**
		 * String reassembles the [URL] into a valid URL string.
		 * The general form of the result is one of:
		 * 
		 * 	scheme:opaque?query#fragment
		 * 	scheme://userinfo@host/path?query#fragment
		 * 
		 * If u.Opaque is non-empty, String uses the first form;
		 * otherwise it uses the second form.
		 * Any non-ASCII characters in host are escaped.
		 * To obtain the path, String uses u.EscapedPath().
		 * 
		 * In the second form, the following rules apply:
		 *   - if u.Scheme is empty, scheme: is omitted.
		 *   - if u.User is nil, userinfo@ is omitted.
		 *   - if u.Host is empty, host/ is omitted.
		 *   - if u.Scheme and u.Host are empty and u.User is nil,
		 *     the entire scheme://userinfo@host/ is omitted.
		 *   - if u.Host is non-empty and u.Path begins with a /,
		 *     the form host/path does not add its own /.
		 *   - if u.RawQuery is empty, ?query is omitted.
		 *   - if u.Fragment is empty, #fragment is omitted.
		 */
		String(): string;
		/**
		 * Redacted is like [URL.String] but replaces any password with "xxxxx".
		 * Only the password in u.User is redacted.
		 */
		Redacted(): string;
		/**
		 * IsAbs reports whether the [URL] is absolute.
		 * Absolute means that it has a non-empty scheme.
		 */
		IsAbs(): boolean;
		/**
		 * Parse parses a [URL] in the context of the receiver. The provided URL
		 * may be relative or absolute. Parse returns nil, err on parse
		 * failure, otherwise its return value is the same as [URL.ResolveReference].
		 */
		Parse(ref: string): [URL, Error | null];
		/**
		 * ResolveReference resolves a URI reference to an absolute URI from
		 * an absolute base URI u, per RFC 3986 Section 5.2. The URI reference
		 * may be relative or absolute. ResolveReference always returns a new
		 * [URL] instance, even if the returned URL is identical to either the
		 * base or reference. If ref is an absolute URL, then ResolveReference
		 * ignores base and returns a copy of ref.
		 */
		ResolveReference(ref: URL): URL;
		/**
		 * Query parses RawQuery and returns the corresponding values.
		 * It silently discards malformed value pairs.
		 * To check errors use [ParseQuery].
		 */
		Query(): Values;
		/**
		 * RequestURI returns the encoded path?query or opaque?query
		 * string that would be used in an HTTP request for u.
		 */
		RequestURI(): string;
		/**
		 * Hostname returns u.Host, stripping any valid port number if present.
		 * 
		 * If the result is enclosed in square brackets, as literal IPv6 addresses are,
		 * the square brackets are removed from the result.
		 */
		Hostname(): string;
		/**
		 * Port returns the port part of u.Host, without the leading colon.
		 * 
		 * If u.Host doesn't contain a valid numeric port, Port returns an empty string.
		 */
		Port(): string;
		MarshalBinary(): [byte[], Error | null];
		AppendBinary(b: byte[]): [byte[], Error | null];
		UnmarshalBinary(text: byte[]): Error | null;
		/**
		 * JoinPath returns a new [URL] with the provided path elements joined to
		 * any existing path and the resulting path cleaned of any ./ or ../ elements.
		 * Any sequences of multiple / characters will be reduced to a single /.
		 */
		JoinPath(...elem: string[]): URL;
	}

	/**
	 * The Userinfo type is an immutable encapsulation of username and
	 * password details for a [URL]. An existing Userinfo value is guaranteed
	 * to have a username set (potentially empty, as allowed by RFC 2396),
	 * and optionally a password.
	 */
	export interface Userinfo {
		/**
		 * Username returns the username.
		 */
		Username(): string;
		/**
		 * Password returns the password in case it is set, and whether it is set.
		 */
		Password(): [string, boolean];
		/**
		 * String returns the encoded userinfo information in the standard form
		 * of "username[:password]".
		 */
		String(): string;
	}

	/**
	 * QueryUnescape does the inverse transformation of [QueryEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB.
	 * It returns an error if any % is not followed by two hexadecimal
	 * digits.
	 */
	export function QueryUnescape(s: string): string;
	/**
	 * PathUnescape does the inverse transformation of [PathEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB. It returns an error if any % is not followed
	 * by two hexadecimal digits.
	 * 
	 * PathUnescape is identical to [QueryUnescape] except that it does not
	 * unescape '+' to ' ' (space).
	 */
	export function PathUnescape(s: string): string;
	/**
	 * QueryEscape escapes the string so it can be safely placed
	 * inside a [URL] query.
	 */
	export function QueryEscape(s: string): string;
	/**
	 * PathEscape escapes the string so it can be safely placed inside a [URL] path segment,
	 * replacing special characters (including /) with %XX sequences as needed.
	 */
	export function PathEscape(s: string): string;
	/**
	 * User returns a [Userinfo] containing the provided username
	 * and no password set.
	 */
	export function User(username: string): Userinfo;
	/**
	 * UserPassword returns a [Userinfo] containing the provided username
	 * and password.
	 * 
	 * This functionality should only be used with legacy web sites.
	 * RFC 2396 warns that interpreting Userinfo this way
	 * “is NOT RECOMMENDED, because the passing of authentication
	 * information in clear text (such as URI) has proven to be a
	 * security risk in almost every case where it has been used.”
	 */
	export function UserPassword(username: string, password: string): Userinfo;
	/**
	 * Parse parses a raw url into a [URL] structure.
	 * 
	 * The url may be relative (a path, without a host) or absolute
	 * (starting with a scheme). Trying to parse a hostname and path
	 * without a scheme is invalid but may not necessarily return an
	 * error, due to parsing ambiguities.
	 */
	export function Parse(rawURL: string): URL;
	/**
	 * ParseRequestURI parses a raw url into a [URL] structure. It assumes that
	 * url was received in an HTTP request, so the url is interpreted
	 * only as an absolute URI or an absolute path.
	 * The string url is assumed not to have a #fragment suffix.
	 * (Web browsers strip #fragment before sending the URL to a web server.)
	 */
	export function ParseRequestURI(rawURL: string): URL;
	/**
	 * ParseQuery parses the URL-encoded query string and returns
	 * a map listing the values specified for each key.
	 * ParseQuery always returns a non-nil map containing all the
	 * valid query parameters found; err describes the first decoding error
	 * encountered, if any.
	 * 
	 * Query is expected to be a list of key=value settings separated by ampersands.
	 * A setting without an equals sign is interpreted as a key set to an empty
	 * value.
	 * Settings containing a non-URL-encoded semicolon are considered invalid.
	 */
	export function ParseQuery(query: string): Values;
	/**
	 * JoinPath returns a [URL] string with the provided path elements joined to
	 * the existing path of base and the resulting path cleaned of any ./ or ../ elements.
	 */
	export function JoinPath(base: string, ...elem: string[]): string;
}
// END: go:go:net/url

// MODULE: go:sync
declare module "go:sync" {
	export function Spawn(fn: () => void): void;
	export function Sleep(ms: number): Promise<void>;
	export function Chan<T = any>(buffer?: number): {
		Send(val: T): void;
		Recv(): T;
		TryRecv(): [T, boolean];
		Close(): void;
	};
}
// END: go:sync

// MODULE: typego:memory
declare module "typego:memory" {
	export function makeShared(name: string, size: number): { buffer: ArrayBuffer; mutex: any };
	export function stats(): { alloc: number; totalAlloc: number; sys: number; numGC: number };
	export function ptr(val: any): any;
}
// END: typego:memory

// MODULE: typego:worker
declare module "typego:worker" {
	export class Worker {
		constructor(scriptPath: string);
		postMessage(msg: any): void;
		terminate(): void;
		onmessage: (msg: { data: any }) => void;
	};
}
// END: typego:worker

// MODULE: go:memory
declare module "go:memory" {
	export function makeShared(name: string, size: number): { buffer: ArrayBuffer; mutex: any };
	export function Ptr(val: any): any;
}
// END: go:memory

// MODULE: go:fmt
declare module "go:fmt" {
	/**
	 * Errorf formats according to a format specifier and returns the string as a
	 * value that satisfies error.
	 * 
	 * If the format specifier includes a %w verb with an error operand,
	 * the returned error will implement an Unwrap method returning the operand.
	 * If there is more than one %w verb, the returned error will implement an
	 * Unwrap method returning a []error containing all the %w operands in the
	 * order they appear in the arguments.
	 * It is invalid to supply the %w verb with an operand that does not implement
	 * the error interface. The %w verb is otherwise a synonym for %v.
	 */
	export function Errorf(format: string, ...a: any[]): void;
	/**
	 * FormatString returns a string representing the fully qualified formatting
	 * directive captured by the [State], followed by the argument verb. ([State] does not
	 * itself contain the verb.) The result has a leading percent sign followed by any
	 * flags, the width, and the precision. Missing flags, width, and precision are
	 * omitted. This function allows a [Formatter] to reconstruct the original
	 * directive triggering the call to Format.
	 */
	export function FormatString(state: State, verb: rune): string;
	/**
	 * Fprintf formats according to a format specifier and writes to w.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprintf(w: io.Writer, format: string, ...a: any[]): number;
	/**
	 * Printf formats according to a format specifier and writes to standard output.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Printf(format: string, ...a: any[]): number;
	/**
	 * Sprintf formats according to a format specifier and returns the resulting string.
	 */
	export function Sprintf(format: string, ...a: any[]): string;
	/**
	 * Appendf formats according to a format specifier, appends the result to the byte
	 * slice, and returns the updated slice.
	 */
	export function Appendf(b: byte[], format: string, ...a: any[]): byte[];
	/**
	 * Fprint formats using the default formats for its operands and writes to w.
	 * Spaces are added between operands when neither is a string.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprint(w: io.Writer, ...a: any[]): number;
	/**
	 * Print formats using the default formats for its operands and writes to standard output.
	 * Spaces are added between operands when neither is a string.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Print(...a: any[]): number;
	/**
	 * Sprint formats using the default formats for its operands and returns the resulting string.
	 * Spaces are added between operands when neither is a string.
	 */
	export function Sprint(...a: any[]): string;
	/**
	 * Append formats using the default formats for its operands, appends the result to
	 * the byte slice, and returns the updated slice.
	 */
	export function Append(b: byte[], ...a: any[]): byte[];
	/**
	 * Fprintln formats using the default formats for its operands and writes to w.
	 * Spaces are always added between operands and a newline is appended.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprintln(w: io.Writer, ...a: any[]): number;
	/**
	 * Println formats using the default formats for its operands and writes to standard output.
	 * Spaces are always added between operands and a newline is appended.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Println(...a: any[]): number;
	/**
	 * Sprintln formats using the default formats for its operands and returns the resulting string.
	 * Spaces are always added between operands and a newline is appended.
	 */
	export function Sprintln(...a: any[]): string;
	/**
	 * Appendln formats using the default formats for its operands, appends the result
	 * to the byte slice, and returns the updated slice. Spaces are always added
	 * between operands and a newline is appended.
	 */
	export function Appendln(b: byte[], ...a: any[]): byte[];
	/**
	 * Scan scans text read from standard input, storing successive
	 * space-separated values into successive arguments. Newlines count
	 * as space. It returns the number of items successfully scanned.
	 * If that is less than the number of arguments, err will report why.
	 */
	export function Scan(...a: any[]): number;
	/**
	 * Scanln is similar to [Scan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Scanln(...a: any[]): number;
	/**
	 * Scanf scans text read from standard input, storing successive
	 * space-separated values into successive arguments as determined by
	 * the format. It returns the number of items successfully scanned.
	 * If that is less than the number of arguments, err will report why.
	 * Newlines in the input must match newlines in the format.
	 * The one exception: the verb %c always scans the next rune in the
	 * input, even if it is a space (or tab etc.) or newline.
	 */
	export function Scanf(format: string, ...a: any[]): number;
	/**
	 * Sscan scans the argument string, storing successive space-separated
	 * values into successive arguments. Newlines count as space. It
	 * returns the number of items successfully scanned. If that is less
	 * than the number of arguments, err will report why.
	 */
	export function Sscan(str: string, ...a: any[]): number;
	/**
	 * Sscanln is similar to [Sscan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Sscanln(str: string, ...a: any[]): number;
	/**
	 * Sscanf scans the argument string, storing successive space-separated
	 * values into successive arguments as determined by the format. It
	 * returns the number of items successfully parsed.
	 * Newlines in the input must match newlines in the format.
	 */
	export function Sscanf(str: string, format: string, ...a: any[]): number;
	/**
	 * Fscan scans text read from r, storing successive space-separated
	 * values into successive arguments. Newlines count as space. It
	 * returns the number of items successfully scanned. If that is less
	 * than the number of arguments, err will report why.
	 */
	export function Fscan(r: io.Reader, ...a: any[]): number;
	/**
	 * Fscanln is similar to [Fscan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Fscanln(r: io.Reader, ...a: any[]): number;
	/**
	 * Fscanf scans text read from r, storing successive space-separated
	 * values into successive arguments as determined by the format. It
	 * returns the number of items successfully parsed.
	 * Newlines in the input must match newlines in the format.
	 */
	export function Fscanf(r: io.Reader, format: string, ...a: any[]): number;
}
// END: go:fmt

// MODULE: go:net/http
declare module "go:net/http" {
	import { URL, Values } from "go:net/url";
	import { ReadCloser } from "go:io";
	import { Form } from "go:mime/multipart";
	import { ConnectionState, Config } from "go:crypto/tls";
	import { Logger } from "go:log";
	import { Duration, Time } from "go:time";

	/**
	 * A ResponseController is used by an HTTP handler to control the response.
	 * 
	 * A ResponseController may not be used after the [Handler.ServeHTTP] method has returned.
	 */
	export interface ResponseController {
		/**
		 * Flush flushes buffered data to the client.
		 */
		Flush(): Error | null;
		/**
		 * Hijack lets the caller take over the connection.
		 * See the [Hijacker] interface for details.
		 */
		Hijack(): [net.Conn, bufio.ReadWriter, Error | null];
		/**
		 * SetReadDeadline sets the deadline for reading the entire request, including the body.
		 * Reads from the request body after the deadline has been exceeded will return an error.
		 * A zero value means no deadline.
		 * 
		 * Setting the read deadline after it has been exceeded will not extend it.
		 */
		SetReadDeadline(deadline: time.Time): Error | null;
		/**
		 * SetWriteDeadline sets the deadline for writing the response.
		 * Writes to the response body after the deadline has been exceeded will not block,
		 * but may succeed if the data has been buffered.
		 * A zero value means no deadline.
		 * 
		 * Setting the write deadline after it has been exceeded will not extend it.
		 */
		SetWriteDeadline(deadline: time.Time): Error | null;
		/**
		 * EnableFullDuplex indicates that the request handler will interleave reads from [Request.Body]
		 * with writes to the [ResponseWriter].
		 * 
		 * For HTTP/1 requests, the Go HTTP server by default consumes any unread portion of
		 * the request body before beginning to write the response, preventing handlers from
		 * concurrently reading from the request and writing the response.
		 * Calling EnableFullDuplex disables this behavior and permits handlers to continue to read
		 * from the request while concurrently writing the response.
		 * 
		 * For HTTP/2 requests, the Go HTTP server always permits concurrent reads and responses.
		 */
		EnableFullDuplex(): Error | null;
	}

	/**
	 * ServeMux is an HTTP request multiplexer.
	 * It matches the URL of each incoming request against a list of registered
	 * patterns and calls the handler for the pattern that
	 * most closely matches the URL.
	 * 
	 * # Patterns
	 * 
	 * Patterns can match the method, host and path of a request.
	 * Some examples:
	 * 
	 *   - "/index.html" matches the path "/index.html" for any host and method.
	 *   - "GET /static/" matches a GET request whose path begins with "/static/".
	 *   - "example.com/" matches any request to the host "example.com".
	 *   - "example.com/{$}" matches requests with host "example.com" and path "/".
	 *   - "/b/{bucket}/o/{objectname...}" matches paths whose first segment is "b"
	 *     and whose third segment is "o". The name "bucket" denotes the second
	 *     segment and "objectname" denotes the remainder of the path.
	 * 
	 * In general, a pattern looks like
	 * 
	 * 	[METHOD ][HOST]/[PATH]
	 * 
	 * All three parts are optional; "/" is a valid pattern.
	 * If METHOD is present, it must be followed by at least one space or tab.
	 * 
	 * Literal (that is, non-wildcard) parts of a pattern match
	 * the corresponding parts of a request case-sensitively.
	 * 
	 * A pattern with no method matches every method. A pattern
	 * with the method GET matches both GET and HEAD requests.
	 * Otherwise, the method must match exactly.
	 * 
	 * A pattern with no host matches every host.
	 * A pattern with a host matches URLs on that host only.
	 * 
	 * A path can include wildcard segments of the form {NAME} or {NAME...}.
	 * For example, "/b/{bucket}/o/{objectname...}".
	 * The wildcard name must be a valid Go identifier.
	 * Wildcards must be full path segments: they must be preceded by a slash and followed by
	 * either a slash or the end of the string.
	 * For example, "/b_{bucket}" is not a valid pattern.
	 * 
	 * Normally a wildcard matches only a single path segment,
	 * ending at the next literal slash (not %2F) in the request URL.
	 * But if the "..." is present, then the wildcard matches the remainder of the URL path, including slashes.
	 * (Therefore it is invalid for a "..." wildcard to appear anywhere but at the end of a pattern.)
	 * The match for a wildcard can be obtained by calling [Request.PathValue] with the wildcard's name.
	 * A trailing slash in a path acts as an anonymous "..." wildcard.
	 * 
	 * The special wildcard {$} matches only the end of the URL.
	 * For example, the pattern "/{$}" matches only the path "/",
	 * whereas the pattern "/" matches every path.
	 * 
	 * For matching, both pattern paths and incoming request paths are unescaped segment by segment.
	 * So, for example, the path "/a%2Fb/100%25" is treated as having two segments, "a/b" and "100%".
	 * The pattern "/a%2fb/" matches it, but the pattern "/a/b/" does not.
	 * 
	 * # Precedence
	 * 
	 * If two or more patterns match a request, then the most specific pattern takes precedence.
	 * A pattern P1 is more specific than P2 if P1 matches a strict subset of P2’s requests;
	 * that is, if P2 matches all the requests of P1 and more.
	 * If neither is more specific, then the patterns conflict.
	 * There is one exception to this rule, for backwards compatibility:
	 * if two patterns would otherwise conflict and one has a host while the other does not,
	 * then the pattern with the host takes precedence.
	 * If a pattern passed to [ServeMux.Handle] or [ServeMux.HandleFunc] conflicts with
	 * another pattern that is already registered, those functions panic.
	 * 
	 * As an example of the general rule, "/images/thumbnails/" is more specific than "/images/",
	 * so both can be registered.
	 * The former matches paths beginning with "/images/thumbnails/"
	 * and the latter will match any other path in the "/images/" subtree.
	 * 
	 * As another example, consider the patterns "GET /" and "/index.html":
	 * both match a GET request for "/index.html", but the former pattern
	 * matches all other GET and HEAD requests, while the latter matches any
	 * request for "/index.html" that uses a different method.
	 * The patterns conflict.
	 * 
	 * # Trailing-slash redirection
	 * 
	 * Consider a [ServeMux] with a handler for a subtree, registered using a trailing slash or "..." wildcard.
	 * If the ServeMux receives a request for the subtree root without a trailing slash,
	 * it redirects the request by adding the trailing slash.
	 * This behavior can be overridden with a separate registration for the path without
	 * the trailing slash or "..." wildcard. For example, registering "/images/" causes ServeMux
	 * to redirect a request for "/images" to "/images/", unless "/images" has
	 * been registered separately.
	 * 
	 * # Request sanitizing
	 * 
	 * ServeMux also takes care of sanitizing the URL request path and the Host
	 * header, stripping the port number and redirecting any request containing . or
	 * .. segments or repeated slashes to an equivalent, cleaner URL.
	 * Escaped path elements such as "%2e" for "." and "%2f" for "/" are preserved
	 * and aren't considered separators for request routing.
	 * 
	 * # Compatibility
	 * 
	 * The pattern syntax and matching behavior of ServeMux changed significantly
	 * in Go 1.22. To restore the old behavior, set the GODEBUG environment variable
	 * to "httpmuxgo121=1". This setting is read once, at program startup; changes
	 * during execution will be ignored.
	 * 
	 * The backwards-incompatible changes include:
	 *   - Wildcards are just ordinary literal path segments in 1.21.
	 *     For example, the pattern "/{x}" will match only that path in 1.21,
	 *     but will match any one-segment path in 1.22.
	 *   - In 1.21, no pattern was rejected, unless it was empty or conflicted with an existing pattern.
	 *     In 1.22, syntactically invalid patterns will cause [ServeMux.Handle] and [ServeMux.HandleFunc] to panic.
	 *     For example, in 1.21, the patterns "/{"  and "/a{x}" match themselves,
	 *     but in 1.22 they are invalid and will cause a panic when registered.
	 *   - In 1.22, each segment of a pattern is unescaped; this was not done in 1.21.
	 *     For example, in 1.22 the pattern "/%61" matches the path "/a" ("%61" being the URL escape sequence for "a"),
	 *     but in 1.21 it would match only the path "/%2561" (where "%25" is the escape for the percent sign).
	 *   - When matching patterns to paths, in 1.22 each segment of the path is unescaped; in 1.21, the entire path is unescaped.
	 *     This change mostly affects how paths with %2F escapes adjacent to slashes are treated.
	 *     See https://go.dev/issue/21955 for details.
	 */
	export interface ServeMux {
		/**
		 * Handler returns the handler to use for the given request,
		 * consulting r.Method, r.Host, and r.URL.Path. It always returns
		 * a non-nil handler. If the path is not in its canonical form, the
		 * handler will be an internally-generated handler that redirects
		 * to the canonical path. If the host contains a port, it is ignored
		 * when matching handlers.
		 * 
		 * The path and host are used unchanged for CONNECT requests.
		 * 
		 * Handler also returns the registered pattern that matches the
		 * request or, in the case of internally-generated redirects,
		 * the path that will match after following the redirect.
		 * 
		 * If there is no registered handler that applies to the request,
		 * Handler returns a “page not found” or “method not supported”
		 * handler and an empty pattern.
		 * 
		 * Handler does not modify its argument. In particular, it does not
		 * populate named path wildcards, so r.PathValue will always return
		 * the empty string.
		 */
		Handler(r: Request): [Handler, string];
		/**
		 * ServeHTTP dispatches the request to the handler whose
		 * pattern most closely matches the request URL.
		 */
		ServeHTTP(w: ResponseWriter, r: Request): void;
		/**
		 * Handle registers the handler for the given pattern.
		 * If the given pattern conflicts with one that is already registered, Handle
		 * panics.
		 */
		Handle(pattern: string, handler: Handler): void;
		/**
		 * HandleFunc registers the handler function for the given pattern.
		 * If the given pattern conflicts with one that is already registered, HandleFunc
		 * panics.
		 */
		HandleFunc(pattern: string, handler: (...args: unknown[]) => unknown): void;
	}

	/**
	 * Protocols is a set of HTTP protocols.
	 * The zero value is an empty set of protocols.
	 * 
	 * The supported protocols are:
	 * 
	 *   - HTTP1 is the HTTP/1.0 and HTTP/1.1 protocols.
	 *     HTTP1 is supported on both unsecured TCP and secured TLS connections.
	 * 
	 *   - HTTP2 is the HTTP/2 protcol over a TLS connection.
	 * 
	 *   - UnencryptedHTTP2 is the HTTP/2 protocol over an unsecured TCP connection.
	 */
	export interface Protocols {
		/**
		 * HTTP1 reports whether p includes HTTP/1.
		 */
		HTTP1(): boolean;
		/**
		 * SetHTTP1 adds or removes HTTP/1 from p.
		 */
		SetHTTP1(ok: boolean): void;
		/**
		 * HTTP2 reports whether p includes HTTP/2.
		 */
		HTTP2(): boolean;
		/**
		 * SetHTTP2 adds or removes HTTP/2 from p.
		 */
		SetHTTP2(ok: boolean): void;
		/**
		 * UnencryptedHTTP2 reports whether p includes unencrypted HTTP/2.
		 */
		UnencryptedHTTP2(): boolean;
		/**
		 * SetUnencryptedHTTP2 adds or removes unencrypted HTTP/2 from p.
		 */
		SetUnencryptedHTTP2(ok: boolean): void;
		String(): string;
	}

	/**
	 * HTTP2Config defines HTTP/2 configuration parameters common to
	 * both [Transport] and [Server].
	 */
	export interface HTTP2Config {
		MaxConcurrentStreams: number;
		MaxDecoderHeaderTableSize: number;
		MaxEncoderHeaderTableSize: number;
		MaxReadFrameSize: number;
		MaxReceiveBufferPerConnection: number;
		MaxReceiveBufferPerStream: number;
		SendPingTimeout: Duration;
		PingTimeout: Duration;
		WriteByteTimeout: Duration;
		PermitProhibitedCipherSuites: boolean;
		CountError: (...args: unknown[]) => unknown;
	}

	/**
	 * A Request represents an HTTP request received by a server
	 * or to be sent by a client.
	 * 
	 * The field semantics differ slightly between client and server
	 * usage. In addition to the notes on the fields below, see the
	 * documentation for [Request.Write] and [RoundTripper].
	 */
	export interface Request {
		Method: string;
		URL: URL;
		Proto: string;
		ProtoMajor: number;
		ProtoMinor: number;
		Header: Header;
		Body: ReadCloser;
		GetBody: (...args: unknown[]) => unknown;
		ContentLength: number;
		TransferEncoding: string[];
		Close: boolean;
		Host: string;
		Form: Values;
		PostForm: Values;
		MultipartForm: Form;
		Trailer: Header;
		RemoteAddr: string;
		RequestURI: string;
		TLS: ConnectionState;
		Cancel: any;
		Response: Response;
		Pattern: string;
		/**
		 * Context returns the request's context. To change the context, use
		 * [Request.Clone] or [Request.WithContext].
		 * 
		 * The returned context is always non-nil; it defaults to the
		 * background context.
		 * 
		 * For outgoing client requests, the context controls cancellation.
		 * 
		 * For incoming server requests, the context is canceled when the
		 * client's connection closes, the request is canceled (with HTTP/2),
		 * or when the ServeHTTP method returns.
		 */
		Context(): context.Context;
		/**
		 * WithContext returns a shallow copy of r with its context changed
		 * to ctx. The provided ctx must be non-nil.
		 * 
		 * For outgoing client request, the context controls the entire
		 * lifetime of a request and its response: obtaining a connection,
		 * sending the request, and reading the response headers and body.
		 * 
		 * To create a new request with a context, use [NewRequestWithContext].
		 * To make a deep copy of a request with a new context, use [Request.Clone].
		 */
		WithContext(ctx: context.Context): Request;
		/**
		 * Clone returns a deep copy of r with its context changed to ctx.
		 * The provided ctx must be non-nil.
		 * 
		 * Clone only makes a shallow copy of the Body field.
		 * 
		 * For an outgoing client request, the context controls the entire
		 * lifetime of a request and its response: obtaining a connection,
		 * sending the request, and reading the response headers and body.
		 */
		Clone(ctx: context.Context): Request;
		/**
		 * ProtoAtLeast reports whether the HTTP protocol used
		 * in the request is at least major.minor.
		 */
		ProtoAtLeast(major: number, minor: number): boolean;
		/**
		 * UserAgent returns the client's User-Agent, if sent in the request.
		 */
		UserAgent(): string;
		/**
		 * Cookies parses and returns the HTTP cookies sent with the request.
		 */
		Cookies(): Cookie[];
		/**
		 * CookiesNamed parses and returns the named HTTP cookies sent with the request
		 * or an empty slice if none matched.
		 */
		CookiesNamed(name: string): Cookie[];
		/**
		 * Cookie returns the named cookie provided in the request or
		 * [ErrNoCookie] if not found.
		 * If multiple cookies match the given name, only one cookie will
		 * be returned.
		 */
		Cookie(name: string): [Cookie, Error | null];
		/**
		 * AddCookie adds a cookie to the request. Per RFC 6265 section 5.4,
		 * AddCookie does not attach more than one [Cookie] header field. That
		 * means all cookies, if any, are written into the same line,
		 * separated by semicolon.
		 * AddCookie only sanitizes c's name and value, and does not sanitize
		 * a Cookie header already present in the request.
		 */
		AddCookie(c: Cookie): void;
		/**
		 * Referer returns the referring URL, if sent in the request.
		 * 
		 * Referer is misspelled as in the request itself, a mistake from the
		 * earliest days of HTTP.  This value can also be fetched from the
		 * [Header] map as Header["Referer"]; the benefit of making it available
		 * as a method is that the compiler can diagnose programs that use the
		 * alternate (correct English) spelling req.Referrer() but cannot
		 * diagnose programs that use Header["Referrer"].
		 */
		Referer(): string;
		/**
		 * MultipartReader returns a MIME multipart reader if this is a
		 * multipart/form-data or a multipart/mixed POST request, else returns nil and an error.
		 * Use this function instead of [Request.ParseMultipartForm] to
		 * process the request body as a stream.
		 */
		MultipartReader(): [multipart.Reader, Error | null];
		/**
		 * Write writes an HTTP/1.1 request, which is the header and body, in wire format.
		 * This method consults the following fields of the request:
		 * 
		 * 	Host
		 * 	URL
		 * 	Method (defaults to "GET")
		 * 	Header
		 * 	ContentLength
		 * 	TransferEncoding
		 * 	Body
		 * 
		 * If Body is present, Content-Length is <= 0 and [Request.TransferEncoding]
		 * hasn't been set to "identity", Write adds "Transfer-Encoding:
		 * chunked" to the header. Body is closed after it is sent.
		 */
		Write(w: io.Writer): Error | null;
		/**
		 * WriteProxy is like [Request.Write] but writes the request in the form
		 * expected by an HTTP proxy. In particular, [Request.WriteProxy] writes the
		 * initial Request-URI line of the request with an absolute URI, per
		 * section 5.3 of RFC 7230, including the scheme and host.
		 * In either case, WriteProxy also writes a Host header, using
		 * either r.Host or r.URL.Host.
		 */
		WriteProxy(w: io.Writer): Error | null;
		/**
		 * BasicAuth returns the username and password provided in the request's
		 * Authorization header, if the request uses HTTP Basic Authentication.
		 * See RFC 2617, Section 2.
		 */
		BasicAuth(): [string, boolean];
		/**
		 * SetBasicAuth sets the request's Authorization header to use HTTP
		 * Basic Authentication with the provided username and password.
		 * 
		 * With HTTP Basic Authentication the provided username and password
		 * are not encrypted. It should generally only be used in an HTTPS
		 * request.
		 * 
		 * The username may not contain a colon. Some protocols may impose
		 * additional requirements on pre-escaping the username and
		 * password. For instance, when used with OAuth2, both arguments must
		 * be URL encoded first with [url.QueryEscape].
		 */
		SetBasicAuth(username: string, password: string): void;
		/**
		 * ParseForm populates r.Form and r.PostForm.
		 * 
		 * For all requests, ParseForm parses the raw query from the URL and updates
		 * r.Form.
		 * 
		 * For POST, PUT, and PATCH requests, it also reads the request body, parses it
		 * as a form and puts the results into both r.PostForm and r.Form. Request body
		 * parameters take precedence over URL query string values in r.Form.
		 * 
		 * If the request Body's size has not already been limited by [MaxBytesReader],
		 * the size is capped at 10MB.
		 * 
		 * For other HTTP methods, or when the Content-Type is not
		 * application/x-www-form-urlencoded, the request Body is not read, and
		 * r.PostForm is initialized to a non-nil, empty value.
		 * 
		 * [Request.ParseMultipartForm] calls ParseForm automatically.
		 * ParseForm is idempotent.
		 */
		ParseForm(): Error | null;
		/**
		 * ParseMultipartForm parses a request body as multipart/form-data.
		 * The whole request body is parsed and up to a total of maxMemory bytes of
		 * its file parts are stored in memory, with the remainder stored on
		 * disk in temporary files.
		 * ParseMultipartForm calls [Request.ParseForm] if necessary.
		 * If ParseForm returns an error, ParseMultipartForm returns it but also
		 * continues parsing the request body.
		 * After one call to ParseMultipartForm, subsequent calls have no effect.
		 */
		ParseMultipartForm(maxMemory: number): Error | null;
		/**
		 * FormValue returns the first value for the named component of the query.
		 * The precedence order:
		 *  1. application/x-www-form-urlencoded form body (POST, PUT, PATCH only)
		 *  2. query parameters (always)
		 *  3. multipart/form-data form body (always)
		 * 
		 * FormValue calls [Request.ParseMultipartForm] and [Request.ParseForm]
		 * if necessary and ignores any errors returned by these functions.
		 * If key is not present, FormValue returns the empty string.
		 * To access multiple values of the same key, call ParseForm and
		 * then inspect [Request.Form] directly.
		 */
		FormValue(key: string): string;
		/**
		 * PostFormValue returns the first value for the named component of the POST,
		 * PUT, or PATCH request body. URL query parameters are ignored.
		 * PostFormValue calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary and ignores
		 * any errors returned by these functions.
		 * If key is not present, PostFormValue returns the empty string.
		 */
		PostFormValue(key: string): string;
		/**
		 * FormFile returns the first file for the provided form key.
		 * FormFile calls [Request.ParseMultipartForm] and [Request.ParseForm] if necessary.
		 */
		FormFile(key: string): [multipart.File, multipart.FileHeader, Error | null];
		/**
		 * PathValue returns the value for the named path wildcard in the [ServeMux] pattern
		 * that matched the request.
		 * It returns the empty string if the request was not matched against a pattern
		 * or there is no such wildcard in the pattern.
		 */
		PathValue(name: string): string;
		/**
		 * SetPathValue sets name to value, so that subsequent calls to r.PathValue(name)
		 * return value.
		 */
		SetPathValue(name: string, value: string): void;
	}

	/**
	 * MaxBytesError is returned by [MaxBytesReader] when its read limit is exceeded.
	 */
	export interface MaxBytesError {
		Limit: number;
		Error(): string;
	}

	/**
	 * A Server defines parameters for running an HTTP server.
	 * The zero value for Server is a valid configuration.
	 */
	export interface Server {
		Addr: string;
		Handler: Handler;
		DisableGeneralOptionsHandler: boolean;
		TLSConfig: Config;
		ReadTimeout: Duration;
		ReadHeaderTimeout: Duration;
		WriteTimeout: Duration;
		IdleTimeout: Duration;
		MaxHeaderBytes: number;
		TLSNextProto: Record<string, unknown>;
		ConnState: (...args: unknown[]) => unknown;
		ErrorLog: Logger;
		BaseContext: (...args: unknown[]) => unknown;
		ConnContext: (...args: unknown[]) => unknown;
		HTTP2: HTTP2Config;
		Protocols: Protocols;
		/**
		 * Close immediately closes all active net.Listeners and any
		 * connections in state [StateNew], [StateActive], or [StateIdle]. For a
		 * graceful shutdown, use [Server.Shutdown].
		 * 
		 * Close does not attempt to close (and does not even know about)
		 * any hijacked connections, such as WebSockets.
		 * 
		 * Close returns any error returned from closing the [Server]'s
		 * underlying Listener(s).
		 */
		Close(): Error | null;
		/**
		 * Shutdown gracefully shuts down the server without interrupting any
		 * active connections. Shutdown works by first closing all open
		 * listeners, then closing all idle connections, and then waiting
		 * indefinitely for connections to return to idle and then shut down.
		 * If the provided context expires before the shutdown is complete,
		 * Shutdown returns the context's error, otherwise it returns any
		 * error returned from closing the [Server]'s underlying Listener(s).
		 * 
		 * When Shutdown is called, [Serve], [ServeTLS], [ListenAndServe], and
		 * [ListenAndServeTLS] immediately return [ErrServerClosed]. Make sure the
		 * program doesn't exit and waits instead for Shutdown to return.
		 * 
		 * Shutdown does not attempt to close nor wait for hijacked
		 * connections such as WebSockets. The caller of Shutdown should
		 * separately notify such long-lived connections of shutdown and wait
		 * for them to close, if desired. See [Server.RegisterOnShutdown] for a way to
		 * register shutdown notification functions.
		 * 
		 * Once Shutdown has been called on a server, it may not be reused;
		 * future calls to methods such as Serve will return ErrServerClosed.
		 */
		Shutdown(ctx: context.Context): Error | null;
		/**
		 * RegisterOnShutdown registers a function to call on [Server.Shutdown].
		 * This can be used to gracefully shutdown connections that have
		 * undergone ALPN protocol upgrade or that have been hijacked.
		 * This function should start protocol-specific graceful shutdown,
		 * but should not wait for shutdown to complete.
		 */
		RegisterOnShutdown(f: (...args: unknown[]) => unknown): void;
		/**
		 * ListenAndServe listens on the TCP network address s.Addr and then
		 * calls [Serve] to handle requests on incoming connections.
		 * Accepted connections are configured to enable TCP keep-alives.
		 * 
		 * If s.Addr is blank, ":http" is used.
		 * 
		 * ListenAndServe always returns a non-nil error. After [Server.Shutdown] or [Server.Close],
		 * the returned error is [ErrServerClosed].
		 */
		ListenAndServe(): Error | null;
		/**
		 * Serve accepts incoming connections on the Listener l, creating a
		 * new service goroutine for each. The service goroutines read requests and
		 * then call s.Handler to reply to them.
		 * 
		 * HTTP/2 support is only enabled if the Listener returns [*tls.Conn]
		 * connections and they were configured with "h2" in the TLS
		 * Config.NextProtos.
		 * 
		 * Serve always returns a non-nil error and closes l.
		 * After [Server.Shutdown] or [Server.Close], the returned error is [ErrServerClosed].
		 */
		Serve(l: net.Listener): Error | null;
		/**
		 * ServeTLS accepts incoming connections on the Listener l, creating a
		 * new service goroutine for each. The service goroutines perform TLS
		 * setup and then read requests, calling s.Handler to reply to them.
		 * 
		 * Files containing a certificate and matching private key for the
		 * server must be provided if neither the [Server]'s
		 * TLSConfig.Certificates, TLSConfig.GetCertificate nor
		 * config.GetConfigForClient are populated.
		 * If the certificate is signed by a certificate authority, the
		 * certFile should be the concatenation of the server's certificate,
		 * any intermediates, and the CA's certificate.
		 * 
		 * ServeTLS always returns a non-nil error. After [Server.Shutdown] or [Server.Close], the
		 * returned error is [ErrServerClosed].
		 */
		ServeTLS(l: net.Listener, certFile: string, keyFile: string): Error | null;
		/**
		 * SetKeepAlivesEnabled controls whether HTTP keep-alives are enabled.
		 * By default, keep-alives are always enabled. Only very
		 * resource-constrained environments or servers in the process of
		 * shutting down should disable them.
		 */
		SetKeepAlivesEnabled(v: boolean): void;
		/**
		 * ListenAndServeTLS listens on the TCP network address s.Addr and
		 * then calls [ServeTLS] to handle requests on incoming TLS connections.
		 * Accepted connections are configured to enable TCP keep-alives.
		 * 
		 * Filenames containing a certificate and matching private key for the
		 * server must be provided if neither the [Server]'s TLSConfig.Certificates
		 * nor TLSConfig.GetCertificate are populated. If the certificate is
		 * signed by a certificate authority, the certFile should be the
		 * concatenation of the server's certificate, any intermediates, and
		 * the CA's certificate.
		 * 
		 * If s.Addr is blank, ":https" is used.
		 * 
		 * ListenAndServeTLS always returns a non-nil error. After [Server.Shutdown] or
		 * [Server.Close], the returned error is [ErrServerClosed].
		 */
		ListenAndServeTLS(certFile: string, keyFile: string): Error | null;
	}

	/**
	 * Transport is an implementation of [RoundTripper] that supports HTTP,
	 * HTTPS, and HTTP proxies (for either HTTP or HTTPS with CONNECT).
	 * 
	 * By default, Transport caches connections for future re-use.
	 * This may leave many open connections when accessing many hosts.
	 * This behavior can be managed using [Transport.CloseIdleConnections] method
	 * and the [Transport.MaxIdleConnsPerHost] and [Transport.DisableKeepAlives] fields.
	 * 
	 * Transports should be reused instead of created as needed.
	 * Transports are safe for concurrent use by multiple goroutines.
	 * 
	 * A Transport is a low-level primitive for making HTTP and HTTPS requests.
	 * For high-level functionality, such as cookies and redirects, see [Client].
	 * 
	 * Transport uses HTTP/1.1 for HTTP URLs and either HTTP/1.1 or HTTP/2
	 * for HTTPS URLs, depending on whether the server supports HTTP/2,
	 * and how the Transport is configured. The [DefaultTransport] supports HTTP/2.
	 * To explicitly enable HTTP/2 on a transport, set [Transport.Protocols].
	 * 
	 * Responses with status codes in the 1xx range are either handled
	 * automatically (100 expect-continue) or ignored. The one
	 * exception is HTTP status code 101 (Switching Protocols), which is
	 * considered a terminal status and returned by [Transport.RoundTrip]. To see the
	 * ignored 1xx responses, use the httptrace trace package's
	 * ClientTrace.Got1xxResponse.
	 * 
	 * Transport only retries a request upon encountering a network error
	 * if the connection has been already been used successfully and if the
	 * request is idempotent and either has no body or has its [Request.GetBody]
	 * defined. HTTP requests are considered idempotent if they have HTTP methods
	 * GET, HEAD, OPTIONS, or TRACE; or if their [Header] map contains an
	 * "Idempotency-Key" or "X-Idempotency-Key" entry. If the idempotency key
	 * value is a zero-length slice, the request is treated as idempotent but the
	 * header is not sent on the wire.
	 */
	export interface Transport {
		Proxy: (...args: unknown[]) => unknown;
		OnProxyConnectResponse: (...args: unknown[]) => unknown;
		DialContext: (...args: unknown[]) => unknown;
		Dial: (...args: unknown[]) => unknown;
		DialTLSContext: (...args: unknown[]) => unknown;
		DialTLS: (...args: unknown[]) => unknown;
		TLSClientConfig: Config;
		TLSHandshakeTimeout: Duration;
		DisableKeepAlives: boolean;
		DisableCompression: boolean;
		MaxIdleConns: number;
		MaxIdleConnsPerHost: number;
		MaxConnsPerHost: number;
		IdleConnTimeout: Duration;
		ResponseHeaderTimeout: Duration;
		ExpectContinueTimeout: Duration;
		TLSNextProto: Record<string, unknown>;
		ProxyConnectHeader: Header;
		GetProxyConnectHeader: (...args: unknown[]) => unknown;
		MaxResponseHeaderBytes: number;
		WriteBufferSize: number;
		ReadBufferSize: number;
		ForceAttemptHTTP2: boolean;
		HTTP2: HTTP2Config;
		Protocols: Protocols;
		/**
		 * Clone returns a deep copy of t's exported fields.
		 */
		Clone(): Transport;
		/**
		 * RegisterProtocol registers a new protocol with scheme.
		 * The [Transport] will pass requests using the given scheme to rt.
		 * It is rt's responsibility to simulate HTTP request semantics.
		 * 
		 * RegisterProtocol can be used by other packages to provide
		 * implementations of protocol schemes like "ftp" or "file".
		 * 
		 * If rt.RoundTrip returns [ErrSkipAltProtocol], the Transport will
		 * handle the [Transport.RoundTrip] itself for that one request, as if the
		 * protocol were not registered.
		 */
		RegisterProtocol(scheme: string, rt: RoundTripper): void;
		/**
		 * CloseIdleConnections closes any connections which were previously
		 * connected from previous requests but are now sitting idle in
		 * a "keep-alive" state. It does not interrupt any connections currently
		 * in use.
		 */
		CloseIdleConnections(): void;
		/**
		 * CancelRequest cancels an in-flight request by closing its connection.
		 * CancelRequest should only be called after [Transport.RoundTrip] has returned.
		 * 
		 * Deprecated: Use [Request.WithContext] to create a request with a
		 * cancelable context instead. CancelRequest cannot cancel HTTP/2
		 * requests. This may become a no-op in a future release of Go.
		 */
		CancelRequest(req: Request): void;
	}

	/**
	 * A Client is an HTTP client. Its zero value ([DefaultClient]) is a
	 * usable client that uses [DefaultTransport].
	 * 
	 * The [Client.Transport] typically has internal state (cached TCP
	 * connections), so Clients should be reused instead of created as
	 * needed. Clients are safe for concurrent use by multiple goroutines.
	 * 
	 * A Client is higher-level than a [RoundTripper] (such as [Transport])
	 * and additionally handles HTTP details such as cookies and
	 * redirects.
	 * 
	 * When following redirects, the Client will forward all headers set on the
	 * initial [Request] except:
	 * 
	 *   - when forwarding sensitive headers like "Authorization",
	 *     "WWW-Authenticate", and "Cookie" to untrusted targets.
	 *     These headers will be ignored when following a redirect to a domain
	 *     that is not a subdomain match or exact match of the initial domain.
	 *     For example, a redirect from "foo.com" to either "foo.com" or "sub.foo.com"
	 *     will forward the sensitive headers, but a redirect to "bar.com" will not.
	 *   - when forwarding the "Cookie" header with a non-nil cookie Jar.
	 *     Since each redirect may mutate the state of the cookie jar,
	 *     a redirect may possibly alter a cookie set in the initial request.
	 *     When forwarding the "Cookie" header, any mutated cookies will be omitted,
	 *     with the expectation that the Jar will insert those mutated cookies
	 *     with the updated values (assuming the origin matches).
	 *     If Jar is nil, the initial cookies are forwarded without change.
	 */
	export interface Client {
		Transport: RoundTripper;
		CheckRedirect: (...args: unknown[]) => unknown;
		Jar: CookieJar;
		Timeout: Duration;
		/**
		 * Get issues a GET to the specified URL. If the response is one of the
		 * following redirect codes, Get follows the redirect after calling the
		 * [Client.CheckRedirect] function:
		 * 
		 * 	301 (Moved Permanently)
		 * 	302 (Found)
		 * 	303 (See Other)
		 * 	307 (Temporary Redirect)
		 * 	308 (Permanent Redirect)
		 * 
		 * An error is returned if the [Client.CheckRedirect] function fails
		 * or if there was an HTTP protocol error. A non-2xx response doesn't
		 * cause an error. Any returned error will be of type [*url.Error]. The
		 * url.Error value's Timeout method will report true if the request
		 * timed out.
		 * 
		 * When err is nil, resp always contains a non-nil resp.Body.
		 * Caller should close resp.Body when done reading from it.
		 * 
		 * To make a request with custom headers, use [NewRequest] and [Client.Do].
		 * 
		 * To make a request with a specified context.Context, use [NewRequestWithContext]
		 * and Client.Do.
		 */
		Get(url: string): [Response, Error | null];
		/**
		 * Do sends an HTTP request and returns an HTTP response, following
		 * policy (such as redirects, cookies, auth) as configured on the
		 * client.
		 * 
		 * An error is returned if caused by client policy (such as
		 * CheckRedirect), or failure to speak HTTP (such as a network
		 * connectivity problem). A non-2xx status code doesn't cause an
		 * error.
		 * 
		 * If the returned error is nil, the [Response] will contain a non-nil
		 * Body which the user is expected to close. If the Body is not both
		 * read to EOF and closed, the [Client]'s underlying [RoundTripper]
		 * (typically [Transport]) may not be able to re-use a persistent TCP
		 * connection to the server for a subsequent "keep-alive" request.
		 * 
		 * The request Body, if non-nil, will be closed by the underlying
		 * Transport, even on errors. The Body may be closed asynchronously after
		 * Do returns.
		 * 
		 * On error, any Response can be ignored. A non-nil Response with a
		 * non-nil error only occurs when CheckRedirect fails, and even then
		 * the returned [Response.Body] is already closed.
		 * 
		 * Generally [Get], [Post], or [PostForm] will be used instead of Do.
		 * 
		 * If the server replies with a redirect, the Client first uses the
		 * CheckRedirect function to determine whether the redirect should be
		 * followed. If permitted, a 301, 302, or 303 redirect causes
		 * subsequent requests to use HTTP method GET
		 * (or HEAD if the original request was HEAD), with no body.
		 * A 307 or 308 redirect preserves the original HTTP method and body,
		 * provided that the [Request.GetBody] function is defined.
		 * The [NewRequest] function automatically sets GetBody for common
		 * standard library body types.
		 * 
		 * Any returned error will be of type [*url.Error]. The url.Error
		 * value's Timeout method will report true if the request timed out.
		 */
		Do(req: Request): [Response, Error | null];
		/**
		 * Post issues a POST to the specified URL.
		 * 
		 * Caller should close resp.Body when done reading from it.
		 * 
		 * If the provided body is an [io.Closer], it is closed after the
		 * request.
		 * 
		 * To set custom headers, use [NewRequest] and [Client.Do].
		 * 
		 * To make a request with a specified context.Context, use [NewRequestWithContext]
		 * and [Client.Do].
		 * 
		 * See the [Client.Do] method documentation for details on how redirects
		 * are handled.
		 */
		Post(url: string, contentType: string, body: io.Reader): [Response, Error | null];
		/**
		 * PostForm issues a POST to the specified URL,
		 * with data's keys and values URL-encoded as the request body.
		 * 
		 * The Content-Type header is set to application/x-www-form-urlencoded.
		 * To set other headers, use [NewRequest] and [Client.Do].
		 * 
		 * When err is nil, resp always contains a non-nil resp.Body.
		 * Caller should close resp.Body when done reading from it.
		 * 
		 * See the [Client.Do] method documentation for details on how redirects
		 * are handled.
		 * 
		 * To make a request with a specified context.Context, use [NewRequestWithContext]
		 * and Client.Do.
		 */
		PostForm(url: string, data: url.Values): [Response, Error | null];
		/**
		 * Head issues a HEAD to the specified URL. If the response is one of the
		 * following redirect codes, Head follows the redirect after calling the
		 * [Client.CheckRedirect] function:
		 * 
		 * 	301 (Moved Permanently)
		 * 	302 (Found)
		 * 	303 (See Other)
		 * 	307 (Temporary Redirect)
		 * 	308 (Permanent Redirect)
		 * 
		 * To make a request with a specified [context.Context], use [NewRequestWithContext]
		 * and [Client.Do].
		 */
		Head(url: string): [Response, Error | null];
		/**
		 * CloseIdleConnections closes any connections on its [Transport] which
		 * were previously connected from previous requests but are now
		 * sitting idle in a "keep-alive" state. It does not interrupt any
		 * connections currently in use.
		 * 
		 * If [Client.Transport] does not have a [Client.CloseIdleConnections] method
		 * then this method does nothing.
		 */
		CloseIdleConnections(): void;
	}

	/**
	 * A Cookie represents an HTTP cookie as sent in the Set-Cookie header of an
	 * HTTP response or the Cookie header of an HTTP request.
	 * 
	 * See https://tools.ietf.org/html/rfc6265 for details.
	 */
	export interface Cookie {
		Name: string;
		Value: string;
		Quoted: boolean;
		Path: string;
		Domain: string;
		Expires: Time;
		RawExpires: string;
		MaxAge: number;
		Secure: boolean;
		HttpOnly: boolean;
		SameSite: SameSite;
		Partitioned: boolean;
		Raw: string;
		Unparsed: string[];
		/**
		 * String returns the serialization of the cookie for use in a [Cookie]
		 * header (if only Name and Value are set) or a Set-Cookie response
		 * header (if other fields are set).
		 * If c is nil or c.Name is invalid, the empty string is returned.
		 */
		String(): string;
		/**
		 * Valid reports whether the cookie is valid.
		 */
		Valid(): Error | null;
	}

	/**
	 * CrossOriginProtection implements protections against [Cross-Site Request
	 * Forgery (CSRF)] by rejecting non-safe cross-origin browser requests.
	 * 
	 * Cross-origin requests are currently detected with the [Sec-Fetch-Site]
	 * header, available in all browsers since 2023, or by comparing the hostname of
	 * the [Origin] header with the Host header.
	 * 
	 * The GET, HEAD, and OPTIONS methods are [safe methods] and are always allowed.
	 * It's important that applications do not perform any state changing actions
	 * due to requests with safe methods.
	 * 
	 * Requests without Sec-Fetch-Site or Origin headers are currently assumed to be
	 * either same-origin or non-browser requests, and are allowed.
	 * 
	 * The zero value of CrossOriginProtection is valid and has no trusted origins
	 * or bypass patterns.
	 * 
	 * [Sec-Fetch-Site]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Sec-Fetch-Site
	 * [Origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin
	 * [Cross-Site Request Forgery (CSRF)]: https://developer.mozilla.org/en-US/docs/Web/Security/Attacks/CSRF
	 * [safe methods]: https://developer.mozilla.org/en-US/docs/Glossary/Safe/HTTP
	 */
	export interface CrossOriginProtection {
		/**
		 * AddTrustedOrigin allows all requests with an [Origin] header
		 * which exactly matches the given value.
		 * 
		 * Origin header values are of the form "scheme://host[:port]".
		 * 
		 * AddTrustedOrigin can be called concurrently with other methods
		 * or request handling, and applies to future requests.
		 * 
		 * [Origin]: https://developer.mozilla.org/en-US/docs/Web/HTTP/Headers/Origin
		 */
		AddTrustedOrigin(origin: string): Error | null;
		/**
		 * AddInsecureBypassPattern permits all requests that match the given pattern.
		 * 
		 * The pattern syntax and precedence rules are the same as [ServeMux]. Only
		 * requests that match the pattern directly are permitted. Those that ServeMux
		 * would redirect to a pattern (e.g. after cleaning the path or adding a
		 * trailing slash) are not.
		 * 
		 * AddInsecureBypassPattern can be called concurrently with other methods or
		 * request handling, and applies to future requests.
		 */
		AddInsecureBypassPattern(pattern: string): void;
		/**
		 * SetDenyHandler sets a handler to invoke when a request is rejected.
		 * The default error handler responds with a 403 Forbidden status.
		 * 
		 * SetDenyHandler can be called concurrently with other methods
		 * or request handling, and applies to future requests.
		 * 
		 * Check does not call the error handler.
		 */
		SetDenyHandler(h: Handler): void;
		/**
		 * Check applies cross-origin checks to a request.
		 * It returns an error if the request should be rejected.
		 */
		Check(req: Request): Error | null;
		/**
		 * Handler returns a handler that applies cross-origin checks
		 * before invoking the handler h.
		 * 
		 * If a request fails cross-origin checks, the request is rejected
		 * with a 403 Forbidden status or handled with the handler passed
		 * to [CrossOriginProtection.SetDenyHandler].
		 */
		Handler(h: Handler): Handler;
	}

	/**
	 * PushOptions describes options for [Pusher.Push].
	 */
	export interface PushOptions {
		Method: string;
		Header: Header;
	}

	/**
	 * ProtocolError represents an HTTP protocol error.
	 * 
	 * Deprecated: Not all errors in the http package related to protocol errors
	 * are of type ProtocolError.
	 */
	export interface ProtocolError {
		ErrorString: string;
		Error(): string;
		/**
		 * Is lets http.ErrNotSupported match errors.ErrUnsupported.
		 */
		Is(err: Error | null): boolean;
	}

	/**
	 * Response represents the response from an HTTP request.
	 * 
	 * The [Client] and [Transport] return Responses from servers once
	 * the response headers have been received. The response body
	 * is streamed on demand as the Body field is read.
	 */
	export interface Response {
		Status: string;
		StatusCode: number;
		Proto: string;
		ProtoMajor: number;
		ProtoMinor: number;
		Header: Header;
		Body: ReadCloser;
		ContentLength: number;
		TransferEncoding: string[];
		Close: boolean;
		Uncompressed: boolean;
		Trailer: Header;
		Request: Request;
		TLS: ConnectionState;
		/**
		 * Cookies parses and returns the cookies set in the Set-Cookie headers.
		 */
		Cookies(): Cookie[];
		/**
		 * Location returns the URL of the response's "Location" header,
		 * if present. Relative redirects are resolved relative to
		 * [Response.Request]. [ErrNoLocation] is returned if no
		 * Location header is present.
		 */
		Location(): [url.URL, Error | null];
		/**
		 * ProtoAtLeast reports whether the HTTP protocol used
		 * in the response is at least major.minor.
		 */
		ProtoAtLeast(major: number, minor: number): boolean;
		/**
		 * Write writes r to w in the HTTP/1.x server response format,
		 * including the status line, headers, body, and optional trailer.
		 * 
		 * This method consults the following fields of the response r:
		 * 
		 * 	StatusCode
		 * 	ProtoMajor
		 * 	ProtoMinor
		 * 	Request.Method
		 * 	TransferEncoding
		 * 	Trailer
		 * 	Body
		 * 	ContentLength
		 * 	Header, values for non-canonical keys will have unpredictable behavior
		 * 
		 * The Response Body is closed after it is sent.
		 */
		Write(w: io.Writer): Error | null;
	}

	/**
	 * Get issues a GET to the specified URL. If the response is one of
	 * the following redirect codes, Get follows the redirect, up to a
	 * maximum of 10 redirects:
	 * 
	 * 	301 (Moved Permanently)
	 * 	302 (Found)
	 * 	303 (See Other)
	 * 	307 (Temporary Redirect)
	 * 	308 (Permanent Redirect)
	 * 
	 * An error is returned if there were too many redirects or if there
	 * was an HTTP protocol error. A non-2xx response doesn't cause an
	 * error. Any returned error will be of type [*url.Error]. The url.Error
	 * value's Timeout method will report true if the request timed out.
	 * 
	 * When err is nil, resp always contains a non-nil resp.Body.
	 * Caller should close resp.Body when done reading from it.
	 * 
	 * Get is a wrapper around DefaultClient.Get.
	 * 
	 * To make a request with custom headers, use [NewRequest] and
	 * DefaultClient.Do.
	 * 
	 * To make a request with a specified context.Context, use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function Get(url: string): Response;
	/**
	 * Post issues a POST to the specified URL.
	 * 
	 * Caller should close resp.Body when done reading from it.
	 * 
	 * If the provided body is an [io.Closer], it is closed after the
	 * request.
	 * 
	 * Post is a wrapper around DefaultClient.Post.
	 * 
	 * To set custom headers, use [NewRequest] and DefaultClient.Do.
	 * 
	 * See the [Client.Do] method documentation for details on how redirects
	 * are handled.
	 * 
	 * To make a request with a specified context.Context, use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function Post(url: string, contentType: string, body: io.Reader): Response;
	/**
	 * PostForm issues a POST to the specified URL, with data's keys and
	 * values URL-encoded as the request body.
	 * 
	 * The Content-Type header is set to application/x-www-form-urlencoded.
	 * To set other headers, use [NewRequest] and DefaultClient.Do.
	 * 
	 * When err is nil, resp always contains a non-nil resp.Body.
	 * Caller should close resp.Body when done reading from it.
	 * 
	 * PostForm is a wrapper around DefaultClient.PostForm.
	 * 
	 * See the [Client.Do] method documentation for details on how redirects
	 * are handled.
	 * 
	 * To make a request with a specified [context.Context], use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function PostForm(url: string, data: url.Values): Response;
	/**
	 * Head issues a HEAD to the specified URL. If the response is one of
	 * the following redirect codes, Head follows the redirect, up to a
	 * maximum of 10 redirects:
	 * 
	 * 	301 (Moved Permanently)
	 * 	302 (Found)
	 * 	303 (See Other)
	 * 	307 (Temporary Redirect)
	 * 	308 (Permanent Redirect)
	 * 
	 * Head is a wrapper around DefaultClient.Head.
	 * 
	 * To make a request with a specified [context.Context], use [NewRequestWithContext]
	 * and DefaultClient.Do.
	 */
	export function Head(url: string): Response;
	/**
	 * ParseCookie parses a Cookie header value and returns all the cookies
	 * which were set in it. Since the same cookie name can appear multiple times
	 * the returned Values can contain more than one value for a given key.
	 */
	export function ParseCookie(line: string): Cookie[];
	/**
	 * ParseSetCookie parses a Set-Cookie header value and returns a cookie.
	 * It returns an error on syntax error.
	 */
	export function ParseSetCookie(line: string): Cookie;
	/**
	 * SetCookie adds a Set-Cookie header to the provided [ResponseWriter]'s headers.
	 * The provided cookie must have a valid Name. Invalid cookies may be
	 * silently dropped.
	 */
	export function SetCookie(w: ResponseWriter, cookie: Cookie): void;
	/**
	 * NewCrossOriginProtection returns a new [CrossOriginProtection] value.
	 */
	export function NewCrossOriginProtection(): CrossOriginProtection;
	/**
	 * NewFileTransport returns a new [RoundTripper], serving the provided
	 * [FileSystem]. The returned RoundTripper ignores the URL host in its
	 * incoming requests, as well as most other properties of the
	 * request.
	 * 
	 * The typical use case for NewFileTransport is to register the "file"
	 * protocol with a [Transport], as in:
	 * 
	 * 	t := &http.Transport{}
	 * 	t.RegisterProtocol("file", http.NewFileTransport(http.Dir("/")))
	 * 	c := &http.Client{Transport: t}
	 * 	res, err := c.Get("file:///etc/passwd")
	 * 	...
	 */
	export function NewFileTransport(fs: FileSystem): RoundTripper;
	/**
	 * NewFileTransportFS returns a new [RoundTripper], serving the provided
	 * file system fsys. The returned RoundTripper ignores the URL host in its
	 * incoming requests, as well as most other properties of the
	 * request. The files provided by fsys must implement [io.Seeker].
	 * 
	 * The typical use case for NewFileTransportFS is to register the "file"
	 * protocol with a [Transport], as in:
	 * 
	 * 	fsys := os.DirFS("/")
	 * 	t := &http.Transport{}
	 * 	t.RegisterProtocol("file", http.NewFileTransportFS(fsys))
	 * 	c := &http.Client{Transport: t}
	 * 	res, err := c.Get("file:///etc/passwd")
	 * 	...
	 */
	export function NewFileTransportFS(fsys: fs.FS): RoundTripper;
	/**
	 * ServeContent replies to the request using the content in the
	 * provided ReadSeeker. The main benefit of ServeContent over [io.Copy]
	 * is that it handles Range requests properly, sets the MIME type, and
	 * handles If-Match, If-Unmodified-Since, If-None-Match, If-Modified-Since,
	 * and If-Range requests.
	 * 
	 * If the response's Content-Type header is not set, ServeContent
	 * first tries to deduce the type from name's file extension and,
	 * if that fails, falls back to reading the first block of the content
	 * and passing it to [DetectContentType].
	 * The name is otherwise unused; in particular it can be empty and is
	 * never sent in the response.
	 * 
	 * If modtime is not the zero time or Unix epoch, ServeContent
	 * includes it in a Last-Modified header in the response. If the
	 * request includes an If-Modified-Since header, ServeContent uses
	 * modtime to decide whether the content needs to be sent at all.
	 * 
	 * The content's Seek method must work: ServeContent uses
	 * a seek to the end of the content to determine its size.
	 * Note that [*os.File] implements the [io.ReadSeeker] interface.
	 * 
	 * If the caller has set w's ETag header formatted per RFC 7232, section 2.3,
	 * ServeContent uses it to handle requests using If-Match, If-None-Match, or If-Range.
	 * 
	 * If an error occurs when serving the request (for example, when
	 * handling an invalid range request), ServeContent responds with an
	 * error message. By default, ServeContent strips the Cache-Control,
	 * Content-Encoding, ETag, and Last-Modified headers from error responses.
	 * The GODEBUG setting httpservecontentkeepheaders=1 causes ServeContent
	 * to preserve these headers.
	 */
	export function ServeContent(w: ResponseWriter, req: Request, name: string, modtime: time.Time, content: io.ReadSeeker): void;
	/**
	 * ServeFile replies to the request with the contents of the named
	 * file or directory.
	 * 
	 * If the provided file or directory name is a relative path, it is
	 * interpreted relative to the current directory and may ascend to
	 * parent directories. If the provided name is constructed from user
	 * input, it should be sanitized before calling [ServeFile].
	 * 
	 * As a precaution, ServeFile will reject requests where r.URL.Path
	 * contains a ".." path element; this protects against callers who
	 * might unsafely use [filepath.Join] on r.URL.Path without sanitizing
	 * it and then use that filepath.Join result as the name argument.
	 * 
	 * As another special case, ServeFile redirects any request where r.URL.Path
	 * ends in "/index.html" to the same path, without the final
	 * "index.html". To avoid such redirects either modify the path or
	 * use [ServeContent].
	 * 
	 * Outside of those two special cases, ServeFile does not use
	 * r.URL.Path for selecting the file or directory to serve; only the
	 * file or directory provided in the name argument is used.
	 */
	export function ServeFile(w: ResponseWriter, r: Request, name: string): void;
	/**
	 * ServeFileFS replies to the request with the contents
	 * of the named file or directory from the file system fsys.
	 * The files provided by fsys must implement [io.Seeker].
	 * 
	 * If the provided name is constructed from user input, it should be
	 * sanitized before calling [ServeFileFS].
	 * 
	 * As a precaution, ServeFileFS will reject requests where r.URL.Path
	 * contains a ".." path element; this protects against callers who
	 * might unsafely use [filepath.Join] on r.URL.Path without sanitizing
	 * it and then use that filepath.Join result as the name argument.
	 * 
	 * As another special case, ServeFileFS redirects any request where r.URL.Path
	 * ends in "/index.html" to the same path, without the final
	 * "index.html". To avoid such redirects either modify the path or
	 * use [ServeContent].
	 * 
	 * Outside of those two special cases, ServeFileFS does not use
	 * r.URL.Path for selecting the file or directory to serve; only the
	 * file or directory provided in the name argument is used.
	 */
	export function ServeFileFS(w: ResponseWriter, r: Request, fsys: fs.FS, name: string): void;
	/**
	 * FS converts fsys to a [FileSystem] implementation,
	 * for use with [FileServer] and [NewFileTransport].
	 * The files provided by fsys must implement [io.Seeker].
	 */
	export function FS(fsys: fs.FS): FileSystem;
	/**
	 * FileServer returns a handler that serves HTTP requests
	 * with the contents of the file system rooted at root.
	 * 
	 * As a special case, the returned file server redirects any request
	 * ending in "/index.html" to the same path, without the final
	 * "index.html".
	 * 
	 * To use the operating system's file system implementation,
	 * use [http.Dir]:
	 * 
	 * 	http.Handle("/", http.FileServer(http.Dir("/tmp")))
	 * 
	 * To use an [fs.FS] implementation, use [http.FileServerFS] instead.
	 */
	export function FileServer(root: FileSystem): Handler;
	/**
	 * FileServerFS returns a handler that serves HTTP requests
	 * with the contents of the file system fsys.
	 * The files provided by fsys must implement [io.Seeker].
	 * 
	 * As a special case, the returned file server redirects any request
	 * ending in "/index.html" to the same path, without the final
	 * "index.html".
	 * 
	 * 	http.Handle("/", http.FileServerFS(fsys))
	 */
	export function FileServerFS(root: fs.FS): Handler;
	/**
	 * ParseTime parses a time header (such as the Date: header),
	 * trying each of the three formats allowed by HTTP/1.1:
	 * [TimeFormat], [time.RFC850], and [time.ANSIC].
	 */
	export function ParseTime(text: string): time.Time;
	/**
	 * CanonicalHeaderKey returns the canonical format of the
	 * header key s. The canonicalization converts the first
	 * letter and any letter following a hyphen to upper case;
	 * the rest are converted to lowercase. For example, the
	 * canonical key for "accept-encoding" is "Accept-Encoding".
	 * If s contains a space or invalid header field bytes, it is
	 * returned without modifications.
	 */
	export function CanonicalHeaderKey(s: string): string;
	/**
	 * ParseHTTPVersion parses an HTTP version string according to RFC 7230, section 2.6.
	 * "HTTP/1.0" returns (1, 0, true). Note that strings without
	 * a minor version, such as "HTTP/2", are not valid.
	 */
	export function ParseHTTPVersion(vers: string): [number, boolean];
	/**
	 * NewRequest wraps [NewRequestWithContext] using [context.Background].
	 */
	export function NewRequest(method: string, url: string, body: io.Reader): Request;
	/**
	 * NewRequestWithContext returns a new [Request] given a method, URL, and
	 * optional body.
	 * 
	 * If the provided body is also an [io.Closer], the returned
	 * [Request.Body] is set to body and will be closed (possibly
	 * asynchronously) by the Client methods Do, Post, and PostForm,
	 * and [Transport.RoundTrip].
	 * 
	 * NewRequestWithContext returns a Request suitable for use with
	 * [Client.Do] or [Transport.RoundTrip]. To create a request for use with
	 * testing a Server Handler, either use the [net/http/httptest.NewRequest] function,
	 * use [ReadRequest], or manually update the Request fields.
	 * For an outgoing client request, the context
	 * controls the entire lifetime of a request and its response:
	 * obtaining a connection, sending the request, and reading the
	 * response headers and body. See the [Request] type's documentation for
	 * the difference between inbound and outbound request fields.
	 * 
	 * If body is of type [*bytes.Buffer], [*bytes.Reader], or
	 * [*strings.Reader], the returned request's ContentLength is set to its
	 * exact value (instead of -1), GetBody is populated (so 307 and 308
	 * redirects can replay the body), and Body is set to [NoBody] if the
	 * ContentLength is 0.
	 */
	export function NewRequestWithContext(ctx: context.Context, method: string, url: string, body: io.Reader): Request;
	/**
	 * ReadRequest reads and parses an incoming request from b.
	 * 
	 * ReadRequest is a low-level function and should only be used for
	 * specialized applications; most code should use the [Server] to read
	 * requests and handle them via the [Handler] interface. ReadRequest
	 * only supports HTTP/1.x requests. For HTTP/2, use golang.org/x/net/http2.
	 */
	export function ReadRequest(b: bufio.Reader): Request;
	/**
	 * MaxBytesReader is similar to [io.LimitReader] but is intended for
	 * limiting the size of incoming request bodies. In contrast to
	 * io.LimitReader, MaxBytesReader's result is a ReadCloser, returns a
	 * non-nil error of type [*MaxBytesError] for a Read beyond the limit,
	 * and closes the underlying reader when its Close method is called.
	 * 
	 * MaxBytesReader prevents clients from accidentally or maliciously
	 * sending a large request and wasting server resources. If possible,
	 * it tells the [ResponseWriter] to close the connection after the limit
	 * has been reached.
	 */
	export function MaxBytesReader(w: ResponseWriter, r: io.ReadCloser, n: number): io.ReadCloser;
	/**
	 * ReadResponse reads and returns an HTTP response from r.
	 * The req parameter optionally specifies the [Request] that corresponds
	 * to this [Response]. If nil, a GET request is assumed.
	 * Clients must call resp.Body.Close when finished reading resp.Body.
	 * After that call, clients can inspect resp.Trailer to find key/value
	 * pairs included in the response trailer.
	 */
	export function ReadResponse(r: bufio.Reader, req: Request): Response;
	/**
	 * NewResponseController creates a [ResponseController] for a request.
	 * 
	 * The ResponseWriter should be the original value passed to the [Handler.ServeHTTP] method,
	 * or have an Unwrap method returning the original ResponseWriter.
	 * 
	 * If the ResponseWriter implements any of the following methods, the ResponseController
	 * will call them as appropriate:
	 * 
	 * 	Flush()
	 * 	FlushError() error // alternative Flush returning an error
	 * 	Hijack() (net.Conn, *bufio.ReadWriter, error)
	 * 	SetReadDeadline(deadline time.Time) error
	 * 	SetWriteDeadline(deadline time.Time) error
	 * 	EnableFullDuplex() error
	 * 
	 * If the ResponseWriter does not support a method, ResponseController returns
	 * an error matching [ErrNotSupported].
	 */
	export function NewResponseController(rw: ResponseWriter): ResponseController;
	/**
	 * Error replies to the request with the specified error message and HTTP code.
	 * It does not otherwise end the request; the caller should ensure no further
	 * writes are done to w.
	 * The error message should be plain text.
	 * 
	 * Error deletes the Content-Length header,
	 * sets Content-Type to “text/plain; charset=utf-8”,
	 * and sets X-Content-Type-Options to “nosniff”.
	 * This configures the header properly for the error message,
	 * in case the caller had set it up expecting a successful output.
	 */
	export function Error(w: ResponseWriter, error: string, code: number): void;
	/**
	 * NotFound replies to the request with an HTTP 404 not found error.
	 */
	export function NotFound(w: ResponseWriter, r: Request): void;
	/**
	 * NotFoundHandler returns a simple request handler
	 * that replies to each request with a “404 page not found” reply.
	 */
	export function NotFoundHandler(): Handler;
	/**
	 * StripPrefix returns a handler that serves HTTP requests by removing the
	 * given prefix from the request URL's Path (and RawPath if set) and invoking
	 * the handler h. StripPrefix handles a request for a path that doesn't begin
	 * with prefix by replying with an HTTP 404 not found error. The prefix must
	 * match exactly: if the prefix in the request contains escaped characters
	 * the reply is also an HTTP 404 not found error.
	 */
	export function StripPrefix(prefix: string, h: Handler): Handler;
	/**
	 * Redirect replies to the request with a redirect to url,
	 * which may be a path relative to the request path.
	 * Any non-ASCII characters in url will be percent-encoded,
	 * but existing percent encodings will not be changed.
	 * 
	 * The provided code should be in the 3xx range and is usually
	 * [StatusMovedPermanently], [StatusFound] or [StatusSeeOther].
	 * 
	 * If the Content-Type header has not been set, [Redirect] sets it
	 * to "text/html; charset=utf-8" and writes a small HTML body.
	 * Setting the Content-Type header to any value, including nil,
	 * disables that behavior.
	 */
	export function Redirect(w: ResponseWriter, r: Request, url: string, code: number): void;
	/**
	 * RedirectHandler returns a request handler that redirects
	 * each request it receives to the given url using the given
	 * status code.
	 * 
	 * The provided code should be in the 3xx range and is usually
	 * [StatusMovedPermanently], [StatusFound] or [StatusSeeOther].
	 */
	export function RedirectHandler(url: string, code: number): Handler;
	/**
	 * NewServeMux allocates and returns a new [ServeMux].
	 */
	export function NewServeMux(): ServeMux;
	/**
	 * Handle registers the handler for the given pattern in [DefaultServeMux].
	 * The documentation for [ServeMux] explains how patterns are matched.
	 */
	export function Handle(pattern: string, handler: Handler): void;
	/**
	 * HandleFunc registers the handler function for the given pattern in [DefaultServeMux].
	 * The documentation for [ServeMux] explains how patterns are matched.
	 */
	export function HandleFunc(pattern: string, handler: (...args: unknown[]) => unknown): void;
	/**
	 * Serve accepts incoming HTTP connections on the listener l,
	 * creating a new service goroutine for each. The service goroutines
	 * read requests and then call handler to reply to them.
	 * 
	 * The handler is typically nil, in which case [DefaultServeMux] is used.
	 * 
	 * HTTP/2 support is only enabled if the Listener returns [*tls.Conn]
	 * connections and they were configured with "h2" in the TLS
	 * Config.NextProtos.
	 * 
	 * Serve always returns a non-nil error.
	 */
	export function Serve(l: net.Listener, handler: Handler): void;
	/**
	 * ServeTLS accepts incoming HTTPS connections on the listener l,
	 * creating a new service goroutine for each. The service goroutines
	 * read requests and then call handler to reply to them.
	 * 
	 * The handler is typically nil, in which case [DefaultServeMux] is used.
	 * 
	 * Additionally, files containing a certificate and matching private key
	 * for the server must be provided. If the certificate is signed by a
	 * certificate authority, the certFile should be the concatenation
	 * of the server's certificate, any intermediates, and the CA's certificate.
	 * 
	 * ServeTLS always returns a non-nil error.
	 */
	export function ServeTLS(l: net.Listener, handler: Handler, certFile: string, keyFile: string): void;
	/**
	 * AllowQuerySemicolons returns a handler that serves requests by converting any
	 * unescaped semicolons in the URL query to ampersands, and invoking the handler h.
	 * 
	 * This restores the pre-Go 1.17 behavior of splitting query parameters on both
	 * semicolons and ampersands. (See golang.org/issue/25192). Note that this
	 * behavior doesn't match that of many proxies, and the mismatch can lead to
	 * security issues.
	 * 
	 * AllowQuerySemicolons should be invoked before [Request.ParseForm] is called.
	 */
	export function AllowQuerySemicolons(h: Handler): Handler;
	/**
	 * ListenAndServe listens on the TCP network address addr and then calls
	 * [Serve] with handler to handle requests on incoming connections.
	 * Accepted connections are configured to enable TCP keep-alives.
	 * 
	 * The handler is typically nil, in which case [DefaultServeMux] is used.
	 * 
	 * ListenAndServe always returns a non-nil error.
	 */
	export function ListenAndServe(addr: string, handler: Handler): void;
	/**
	 * ListenAndServeTLS acts identically to [ListenAndServe], except that it
	 * expects HTTPS connections. Additionally, files containing a certificate and
	 * matching private key for the server must be provided. If the certificate
	 * is signed by a certificate authority, the certFile should be the concatenation
	 * of the server's certificate, any intermediates, and the CA's certificate.
	 */
	export function ListenAndServeTLS(addr: string, certFile: string, keyFile: string, handler: Handler): void;
	/**
	 * TimeoutHandler returns a [Handler] that runs h with the given time limit.
	 * 
	 * The new Handler calls h.ServeHTTP to handle each request, but if a
	 * call runs for longer than its time limit, the handler responds with
	 * a 503 Service Unavailable error and the given message in its body.
	 * (If msg is empty, a suitable default message will be sent.)
	 * After such a timeout, writes by h to its [ResponseWriter] will return
	 * [ErrHandlerTimeout].
	 * 
	 * TimeoutHandler supports the [Pusher] interface but does not support
	 * the [Hijacker] or [Flusher] interfaces.
	 */
	export function TimeoutHandler(h: Handler, dt: time.Duration, msg: string): Handler;
	/**
	 * MaxBytesHandler returns a [Handler] that runs h with its [ResponseWriter] and [Request.Body] wrapped by a MaxBytesReader.
	 */
	export function MaxBytesHandler(h: Handler, n: number): Handler;
	/**
	 * DetectContentType implements the algorithm described
	 * at https://mimesniff.spec.whatwg.org/ to determine the
	 * Content-Type of the given data. It considers at most the
	 * first 512 bytes of data. DetectContentType always returns
	 * a valid MIME type: if it cannot determine a more specific one, it
	 * returns "application/octet-stream".
	 */
	export function DetectContentType(data: byte[]): string;
	/**
	 * StatusText returns a text for the HTTP status code. It returns the empty
	 * string if the code is unknown.
	 */
	export function StatusText(code: number): string;
	/**
	 * ProxyFromEnvironment returns the URL of the proxy to use for a
	 * given request, as indicated by the environment variables
	 * HTTP_PROXY, HTTPS_PROXY and NO_PROXY (or the lowercase versions
	 * thereof). Requests use the proxy from the environment variable
	 * matching their scheme, unless excluded by NO_PROXY.
	 * 
	 * The environment values may be either a complete URL or a
	 * "host[:port]", in which case the "http" scheme is assumed.
	 * An error is returned if the value is a different form.
	 * 
	 * A nil URL and nil error are returned if no proxy is defined in the
	 * environment, or a proxy should not be used for the given request,
	 * as defined by NO_PROXY.
	 * 
	 * As a special case, if req.URL.Host is "localhost" (with or without
	 * a port number), then a nil URL and nil error will be returned.
	 */
	export function ProxyFromEnvironment(req: Request): url.URL;
	/**
	 * ProxyURL returns a proxy function (for use in a [Transport])
	 * that always returns the same URL.
	 */
	export function ProxyURL(fixedURL: url.URL): (...args: unknown[]) => unknown;
}
// END: go:net/http

// MODULE: go:os
declare module "go:os" {
	import { SysProcAttr } from "go:syscall";

	/**
	 * ProcAttr holds the attributes that will be applied to a new process
	 * started by StartProcess.
	 */
	export interface ProcAttr {
		Dir: string;
		Env: string[];
		Files: File[];
		Sys: SysProcAttr;
	}

	/**
	 * ProcessState stores information about a process, as reported by Wait.
	 */
	export interface ProcessState {
		/**
		 * Pid returns the process id of the exited process.
		 */
		Pid(): number;
		String(): string;
		/**
		 * ExitCode returns the exit code of the exited process, or -1
		 * if the process hasn't exited or was terminated by a signal.
		 */
		ExitCode(): number;
	}

	/**
	 * LinkError records an error during a link or symlink or rename
	 * system call and the paths that caused it.
	 */
	export interface LinkError {
		Op: string;
		Old: string;
		New: string;
		Err: Error | null;
		Error(): string;
		Unwrap(): Error | null;
	}

	/**
	 * Root may be used to only access files within a single directory tree.
	 * 
	 * Methods on Root can only access files and directories beneath a root directory.
	 * If any component of a file name passed to a method of Root references a location
	 * outside the root, the method returns an error.
	 * File names may reference the directory itself (.).
	 * 
	 * Methods on Root will follow symbolic links, but symbolic links may not
	 * reference a location outside the root.
	 * Symbolic links must not be absolute.
	 * 
	 * Methods on Root do not prohibit traversal of filesystem boundaries,
	 * Linux bind mounts, /proc special files, or access to Unix device files.
	 * 
	 * Methods on Root are safe to be used from multiple goroutines simultaneously.
	 * 
	 * On most platforms, creating a Root opens a file descriptor or handle referencing
	 * the directory. If the directory is moved, methods on Root reference the original
	 * directory in its new location.
	 * 
	 * Root's behavior differs on some platforms:
	 * 
	 *   - When GOOS=windows, file names may not reference Windows reserved device names
	 *     such as NUL and COM1.
	 *   - On Unix, [Root.Chmod], [Root.Chown], and [Root.Chtimes] are vulnerable to a race condition.
	 *     If the target of the operation is changed from a regular file to a symlink
	 *     while the operation is in progress, the operation may be performed on the link
	 *     rather than the link target.
	 *   - When GOOS=js, Root is vulnerable to TOCTOU (time-of-check-time-of-use)
	 *     attacks in symlink validation, and cannot ensure that operations will not
	 *     escape the root.
	 *   - When GOOS=plan9 or GOOS=js, Root does not track directories across renames.
	 *     On these platforms, a Root references a directory name, not a file descriptor.
	 *   - WASI preview 1 (GOOS=wasip1) does not support [Root.Chmod].
	 */
	export interface Root {
		/**
		 * Name returns the name of the directory presented to OpenRoot.
		 * 
		 * It is safe to call Name after [Close].
		 */
		Name(): string;
		/**
		 * Close closes the Root.
		 * After Close is called, methods on Root return errors.
		 */
		Close(): Error | null;
		/**
		 * Open opens the named file in the root for reading.
		 * See [Open] for more details.
		 */
		Open(name: string): [File, Error | null];
		/**
		 * Create creates or truncates the named file in the root.
		 * See [Create] for more details.
		 */
		Create(name: string): [File, Error | null];
		/**
		 * OpenFile opens the named file in the root.
		 * See [OpenFile] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * OpenFile returns an error.
		 */
		OpenFile(name: string, flag: number, perm: FileMode): [File, Error | null];
		/**
		 * OpenRoot opens the named directory in the root.
		 * If there is an error, it will be of type [*PathError].
		 */
		OpenRoot(name: string): [Root, Error | null];
		/**
		 * Chmod changes the mode of the named file in the root to mode.
		 * See [Chmod] for more details.
		 */
		Chmod(name: string, mode: FileMode): Error | null;
		/**
		 * Mkdir creates a new directory in the root
		 * with the specified name and permission bits (before umask).
		 * See [Mkdir] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * Mkdir returns an error.
		 */
		Mkdir(name: string, perm: FileMode): Error | null;
		/**
		 * MkdirAll creates a new directory in the root, along with any necessary parents.
		 * See [MkdirAll] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * MkdirAll returns an error.
		 */
		MkdirAll(name: string, perm: FileMode): Error | null;
		/**
		 * Chown changes the numeric uid and gid of the named file in the root.
		 * See [Chown] for more details.
		 */
		Chown(name: string, uid: number, gid: number): Error | null;
		/**
		 * Lchown changes the numeric uid and gid of the named file in the root.
		 * See [Lchown] for more details.
		 */
		Lchown(name: string, uid: number, gid: number): Error | null;
		/**
		 * Chtimes changes the access and modification times of the named file in the root.
		 * See [Chtimes] for more details.
		 */
		Chtimes(name: string, atime: time.Time, mtime: time.Time): Error | null;
		/**
		 * Remove removes the named file or (empty) directory in the root.
		 * See [Remove] for more details.
		 */
		Remove(name: string): Error | null;
		/**
		 * RemoveAll removes the named file or directory and any children that it contains.
		 * See [RemoveAll] for more details.
		 */
		RemoveAll(name: string): Error | null;
		/**
		 * Stat returns a [FileInfo] describing the named file in the root.
		 * See [Stat] for more details.
		 */
		Stat(name: string): [FileInfo, Error | null];
		/**
		 * Lstat returns a [FileInfo] describing the named file in the root.
		 * If the file is a symbolic link, the returned FileInfo
		 * describes the symbolic link.
		 * See [Lstat] for more details.
		 */
		Lstat(name: string): [FileInfo, Error | null];
		/**
		 * Readlink returns the destination of the named symbolic link in the root.
		 * See [Readlink] for more details.
		 */
		Readlink(name: string): [string, Error | null];
		/**
		 * Rename renames (moves) oldname to newname.
		 * Both paths are relative to the root.
		 * See [Rename] for more details.
		 */
		Rename(oldname: string, newname: string): Error | null;
		/**
		 * Link creates newname as a hard link to the oldname file.
		 * Both paths are relative to the root.
		 * See [Link] for more details.
		 * 
		 * If oldname is a symbolic link, Link creates new link to oldname and not its target.
		 * This behavior may differ from that of [Link] on some platforms.
		 * 
		 * When GOOS=js, Link returns an error if oldname is a symbolic link.
		 */
		Link(oldname: string, newname: string): Error | null;
		/**
		 * Symlink creates newname as a symbolic link to oldname.
		 * See [Symlink] for more details.
		 * 
		 * Symlink does not validate oldname,
		 * which may reference a location outside the root.
		 * 
		 * On Windows, a directory link is created if oldname references
		 * a directory within the root. Otherwise a file link is created.
		 */
		Symlink(oldname: string, newname: string): Error | null;
		/**
		 * ReadFile reads the named file in the root and returns its contents.
		 * See [ReadFile] for more details.
		 */
		ReadFile(name: string): [byte[], Error | null];
		/**
		 * WriteFile writes data to the named file in the root, creating it if necessary.
		 * See [WriteFile] for more details.
		 */
		WriteFile(name: string, data: byte[], perm: FileMode): Error | null;
		/**
		 * FS returns a file system (an fs.FS) for the tree of files in the root.
		 * 
		 * The result implements [io/fs.StatFS], [io/fs.ReadFileFS],
		 * [io/fs.ReadDirFS], and [io/fs.ReadLinkFS].
		 */
		FS(): fs.FS;
	}

	/**
	 * File represents an open file descriptor.
	 * 
	 * The methods of File are safe for concurrent use.
	 */
	export interface File {
	}

	/**
	 * SyscallError records an error from a specific system call.
	 */
	export interface SyscallError {
		Syscall: string;
		Err: Error | null;
		Error(): string;
		Unwrap(): Error | null;
		/**
		 * Timeout reports whether this error represents a timeout.
		 */
		Timeout(): boolean;
	}

	/**
	 * Process stores the information about a process created by [StartProcess].
	 */
	export interface Process {
		Pid: number;
		/**
		 * Release releases any resources associated with the [Process] p,
		 * rendering it unusable in the future.
		 * Release only needs to be called if [Process.Wait] is not.
		 */
		Release(): Error | null;
		/**
		 * Kill causes the [Process] to exit immediately. Kill does not wait until
		 * the Process has actually exited. This only kills the Process itself,
		 * not any other processes it may have started.
		 */
		Kill(): Error | null;
		/**
		 * Wait waits for the [Process] to exit, and then returns a
		 * ProcessState describing its status and an error, if any.
		 * Wait releases any resources associated with the Process.
		 * On most operating systems, the Process must be a child
		 * of the current process or an error will be returned.
		 */
		Wait(): [ProcessState, Error | null];
		/**
		 * Signal sends a signal to the [Process].
		 * Sending [Interrupt] on Windows is not implemented.
		 */
		Signal(sig: Signal): Error | null;
	}

	/**
	 * ReadDir reads the named directory,
	 * returning all its directory entries sorted by filename.
	 * If an error occurs reading the directory,
	 * ReadDir returns the entries it was able to read before the error,
	 * along with the error.
	 */
	export function ReadDir(name: string): DirEntry[];
	/**
	 * CopyFS copies the file system fsys into the directory dir,
	 * creating dir if necessary.
	 * 
	 * Files are created with mode 0o666 plus any execute permissions
	 * from the source, and directories are created with mode 0o777
	 * (before umask).
	 * 
	 * CopyFS will not overwrite existing files. If a file name in fsys
	 * already exists in the destination, CopyFS will return an error
	 * such that errors.Is(err, fs.ErrExist) will be true.
	 * 
	 * Symbolic links in dir are followed.
	 * 
	 * New files added to fsys (including if dir is a subdirectory of fsys)
	 * while CopyFS is running are not guaranteed to be copied.
	 * 
	 * Copying stops at and returns the first error encountered.
	 */
	export function CopyFS(dir: string, fsys: fs.FS): void;
	/**
	 * Expand replaces ${var} or $var in the string based on the mapping function.
	 * For example, [os.ExpandEnv](s) is equivalent to [os.Expand](s, [os.Getenv]).
	 */
	export function Expand(s: string, mapping: (...args: unknown[]) => unknown): string;
	/**
	 * ExpandEnv replaces ${var} or $var in the string according to the values
	 * of the current environment variables. References to undefined
	 * variables are replaced by the empty string.
	 */
	export function ExpandEnv(s: string): string;
	/**
	 * Getenv retrieves the value of the environment variable named by the key.
	 * It returns the value, which will be empty if the variable is not present.
	 * To distinguish between an empty value and an unset value, use [LookupEnv].
	 */
	export function Getenv(key: string): string;
	/**
	 * LookupEnv retrieves the value of the environment variable named
	 * by the key. If the variable is present in the environment the
	 * value (which may be empty) is returned and the boolean is true.
	 * Otherwise the returned value will be empty and the boolean will
	 * be false.
	 */
	export function LookupEnv(key: string): [string, boolean];
	/**
	 * Setenv sets the value of the environment variable named by the key.
	 * It returns an error, if any.
	 */
	export function Setenv(key: string, value: string): void;
	/**
	 * Unsetenv unsets a single environment variable.
	 */
	export function Unsetenv(key: string): void;
	/**
	 * Clearenv deletes all environment variables.
	 */
	export function Clearenv(): void;
	/**
	 * Environ returns a copy of strings representing the environment,
	 * in the form "key=value".
	 */
	export function Environ(): string[];
	/**
	 * NewSyscallError returns, as an error, a new [SyscallError]
	 * with the given system call name and error details.
	 * As a convenience, if err is nil, NewSyscallError returns nil.
	 */
	export function NewSyscallError(syscall: string, err: Error | null): void;
	/**
	 * IsExist returns a boolean indicating whether its argument is known to report
	 * that a file or directory already exists. It is satisfied by [ErrExist] as
	 * well as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrExist).
	 */
	export function IsExist(err: Error | null): boolean;
	/**
	 * IsNotExist returns a boolean indicating whether its argument is known to
	 * report that a file or directory does not exist. It is satisfied by
	 * [ErrNotExist] as well as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrNotExist).
	 */
	export function IsNotExist(err: Error | null): boolean;
	/**
	 * IsPermission returns a boolean indicating whether its argument is known to
	 * report that permission is denied. It is satisfied by [ErrPermission] as well
	 * as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrPermission).
	 */
	export function IsPermission(err: Error | null): boolean;
	/**
	 * IsTimeout returns a boolean indicating whether its argument is known
	 * to report that a timeout occurred.
	 * 
	 * This function predates [errors.Is], and the notion of whether an
	 * error indicates a timeout can be ambiguous. For example, the Unix
	 * error EWOULDBLOCK sometimes indicates a timeout and sometimes does not.
	 * New code should use errors.Is with a value appropriate to the call
	 * returning the error, such as [os.ErrDeadlineExceeded].
	 */
	export function IsTimeout(err: Error | null): boolean;
	/**
	 * Getpid returns the process id of the caller.
	 */
	export function Getpid(): number;
	/**
	 * Getppid returns the process id of the caller's parent.
	 */
	export function Getppid(): number;
	/**
	 * FindProcess looks for a running process by its pid.
	 * 
	 * The [Process] it returns can be used to obtain information
	 * about the underlying operating system process.
	 * 
	 * On Unix systems, FindProcess always succeeds and returns a Process
	 * for the given pid, regardless of whether the process exists. To test whether
	 * the process actually exists, see whether p.Signal(syscall.Signal(0)) reports
	 * an error.
	 */
	export function FindProcess(pid: number): Process;
	/**
	 * StartProcess starts a new process with the program, arguments and attributes
	 * specified by name, argv and attr. The argv slice will become [os.Args] in the
	 * new process, so it normally starts with the program name.
	 * 
	 * If the calling goroutine has locked the operating system thread
	 * with [runtime.LockOSThread] and modified any inheritable OS-level
	 * thread state (for example, Linux or Plan 9 name spaces), the new
	 * process will inherit the caller's thread state.
	 * 
	 * StartProcess is a low-level interface. The [os/exec] package provides
	 * higher-level interfaces.
	 * 
	 * If there is an error, it will be of type [*PathError].
	 */
	export function StartProcess(name: string, argv: string[], attr: ProcAttr): Process;
	/**
	 * Executable returns the path name for the executable that started
	 * the current process. There is no guarantee that the path is still
	 * pointing to the correct executable. If a symlink was used to start
	 * the process, depending on the operating system, the result might
	 * be the symlink or the path it pointed to. If a stable result is
	 * needed, [path/filepath.EvalSymlinks] might help.
	 * 
	 * Executable returns an absolute path unless an error occurred.
	 * 
	 * The main use case is finding resources located relative to an
	 * executable.
	 */
	export function Executable(): string;
	/**
	 * NewFile returns a new [File] with the given file descriptor and name.
	 * The returned value will be nil if fd is not a valid file descriptor.
	 * 
	 * NewFile's behavior differs on some platforms:
	 * 
	 *   - On Unix, if fd is in non-blocking mode, NewFile will attempt to return a pollable file.
	 *   - On Windows, if fd is opened for asynchronous I/O (that is, [syscall.FILE_FLAG_OVERLAPPED]
	 *     has been specified in the [syscall.CreateFile] call), NewFile will attempt to return a pollable
	 *     file by associating fd with the Go runtime I/O completion port.
	 *     The I/O operations will be performed synchronously if the association fails.
	 * 
	 * Only pollable files support [File.SetDeadline], [File.SetReadDeadline], and [File.SetWriteDeadline].
	 * 
	 * After passing it to NewFile, fd may become invalid under the same conditions described
	 * in the comments of [File.Fd], and the same constraints apply.
	 */
	export function NewFile(fd: uintptr, name: string): File;
	/**
	 * Mkdir creates a new directory with the specified name and permission
	 * bits (before umask).
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Mkdir(name: string, perm: FileMode): void;
	/**
	 * Chdir changes the current working directory to the named directory.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Chdir(dir: string): void;
	/**
	 * Open opens the named file for reading. If successful, methods on
	 * the returned file can be used for reading; the associated file
	 * descriptor has mode [O_RDONLY].
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Open(name: string): File;
	/**
	 * Create creates or truncates the named file. If the file already exists,
	 * it is truncated. If the file does not exist, it is created with mode 0o666
	 * (before umask). If successful, methods on the returned File can
	 * be used for I/O; the associated file descriptor has mode [O_RDWR].
	 * The directory containing the file must already exist.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Create(name: string): File;
	/**
	 * OpenFile is the generalized open call; most users will use Open
	 * or Create instead. It opens the named file with specified flag
	 * ([O_RDONLY] etc.). If the file does not exist, and the [O_CREATE] flag
	 * is passed, it is created with mode perm (before umask);
	 * the containing directory must exist. If successful,
	 * methods on the returned File can be used for I/O.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function OpenFile(name: string, flag: number, perm: FileMode): File;
	/**
	 * Rename renames (moves) oldpath to newpath.
	 * If newpath already exists and is not a directory, Rename replaces it.
	 * If newpath already exists and is a directory, Rename returns an error.
	 * OS-specific restrictions may apply when oldpath and newpath are in different directories.
	 * Even within the same directory, on non-Unix platforms Rename is not an atomic operation.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Rename(oldpath: string, newpath: string): void;
	/**
	 * Readlink returns the destination of the named symbolic link.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * If the link destination is relative, Readlink returns the relative path
	 * without resolving it to an absolute one.
	 */
	export function Readlink(name: string): string;
	/**
	 * TempDir returns the default directory to use for temporary files.
	 * 
	 * On Unix systems, it returns $TMPDIR if non-empty, else /tmp.
	 * On Windows, it uses GetTempPath, returning the first non-empty
	 * value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.
	 * On Plan 9, it returns /tmp.
	 * 
	 * The directory is neither guaranteed to exist nor have accessible
	 * permissions.
	 */
	export function TempDir(): string;
	/**
	 * UserCacheDir returns the default root directory to use for user-specific
	 * cached data. Users should create their own application-specific subdirectory
	 * within this one and use that.
	 * 
	 * On Unix systems, it returns $XDG_CACHE_HOME as specified by
	 * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
	 * non-empty, else $HOME/.cache.
	 * On Darwin, it returns $HOME/Library/Caches.
	 * On Windows, it returns %LocalAppData%.
	 * On Plan 9, it returns $home/lib/cache.
	 * 
	 * If the location cannot be determined (for example, $HOME is not defined) or
	 * the path in $XDG_CACHE_HOME is relative, then it will return an error.
	 */
	export function UserCacheDir(): string;
	/**
	 * UserConfigDir returns the default root directory to use for user-specific
	 * configuration data. Users should create their own application-specific
	 * subdirectory within this one and use that.
	 * 
	 * On Unix systems, it returns $XDG_CONFIG_HOME as specified by
	 * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
	 * non-empty, else $HOME/.config.
	 * On Darwin, it returns $HOME/Library/Application Support.
	 * On Windows, it returns %AppData%.
	 * On Plan 9, it returns $home/lib.
	 * 
	 * If the location cannot be determined (for example, $HOME is not defined) or
	 * the path in $XDG_CONFIG_HOME is relative, then it will return an error.
	 */
	export function UserConfigDir(): string;
	/**
	 * UserHomeDir returns the current user's home directory.
	 * 
	 * On Unix, including macOS, it returns the $HOME environment variable.
	 * On Windows, it returns %USERPROFILE%.
	 * On Plan 9, it returns the $home environment variable.
	 * 
	 * If the expected variable is not set in the environment, UserHomeDir
	 * returns either a platform-specific default value or a non-nil error.
	 */
	export function UserHomeDir(): string;
	/**
	 * Chmod changes the mode of the named file to mode.
	 * If the file is a symbolic link, it changes the mode of the link's target.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * A different subset of the mode bits are used, depending on the
	 * operating system.
	 * 
	 * On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and
	 * [ModeSticky] are used.
	 * 
	 * On Windows, only the 0o200 bit (owner writable) of mode is used; it
	 * controls whether the file's read-only attribute is set or cleared.
	 * The other bits are currently unused. For compatibility with Go 1.12
	 * and earlier, use a non-zero mode. Use mode 0o400 for a read-only
	 * file and 0o600 for a readable+writable file.
	 * 
	 * On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive],
	 * and [ModeTemporary] are used.
	 */
	export function Chmod(name: string, mode: FileMode): void;
	/**
	 * DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.
	 * 
	 * Note that DirFS("/prefix") only guarantees that the Open calls it makes to the
	 * operating system will begin with "/prefix": DirFS("/prefix").Open("file") is the
	 * same as os.Open("/prefix/file"). So if /prefix/file is a symbolic link pointing outside
	 * the /prefix tree, then using DirFS does not stop the access any more than using
	 * os.Open does. Additionally, the root of the fs.FS returned for a relative path,
	 * DirFS("prefix"), will be affected by later calls to Chdir. DirFS is therefore not
	 * a general substitute for a chroot-style security mechanism when the directory tree
	 * contains arbitrary content.
	 * 
	 * Use [Root.FS] to obtain a fs.FS that prevents escapes from the tree via symbolic links.
	 * 
	 * The directory dir must not be "".
	 * 
	 * The result implements [io/fs.StatFS], [io/fs.ReadFileFS], [io/fs.ReadDirFS], and
	 * [io/fs.ReadLinkFS].
	 */
	export function DirFS(dir: string): fs.FS;
	/**
	 * ReadFile reads the named file and returns the contents.
	 * A successful call returns err == nil, not err == EOF.
	 * Because ReadFile reads the whole file, it does not treat an EOF from Read
	 * as an error to be reported.
	 */
	export function ReadFile(name: string): byte[];
	/**
	 * WriteFile writes data to the named file, creating it if necessary.
	 * If the file does not exist, WriteFile creates it with permissions perm (before umask);
	 * otherwise WriteFile truncates it before writing, without changing permissions.
	 * Since WriteFile requires multiple system calls to complete, a failure mid-operation
	 * can leave the file in a partially written state.
	 */
	export function WriteFile(name: string, data: byte[], perm: FileMode): void;
	/**
	 * Chown changes the numeric uid and gid of the named file.
	 * If the file is a symbolic link, it changes the uid and gid of the link's target.
	 * A uid or gid of -1 means to not change that value.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or
	 * [syscall.EPLAN9] error, wrapped in [*PathError].
	 */
	export function Chown(name: string, uid: number, gid: number): void;
	/**
	 * Lchown changes the numeric uid and gid of the named file.
	 * If the file is a symbolic link, it changes the uid and gid of the link itself.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows, it always returns the [syscall.EWINDOWS] error, wrapped
	 * in [*PathError].
	 */
	export function Lchown(name: string, uid: number, gid: number): void;
	/**
	 * Chtimes changes the access and modification times of the named
	 * file, similar to the Unix utime() or utimes() functions.
	 * A zero [time.Time] value will leave the corresponding file time unchanged.
	 * 
	 * The underlying filesystem may truncate or round the values to a
	 * less precise time unit.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Chtimes(name: string, atime: time.Time, mtime: time.Time): void;
	/**
	 * Truncate changes the size of the named file.
	 * If the file is a symbolic link, it changes the size of the link's target.
	 */
	export function Truncate(name: string, size: number): void;
	/**
	 * Remove removes the named file or directory.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Remove(name: string): void;
	/**
	 * Pipe returns a connected pair of Files; reads from r return bytes written to w.
	 * It returns the files and an error, if any. The Windows handles underlying
	 * the returned files are marked as inheritable by child processes.
	 */
	export function Pipe(): [File, File];
	/**
	 * Link creates newname as a hard link to the oldname file.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Link(oldname: string, newname: string): void;
	/**
	 * Symlink creates newname as a symbolic link to oldname.
	 * On Windows, a symlink to a non-existent oldname creates a file symlink;
	 * if oldname is later created as a directory the symlink will not work.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Symlink(oldname: string, newname: string): void;
	/**
	 * Getwd returns an absolute path name corresponding to the
	 * current directory. If the current directory can be
	 * reached via multiple paths (due to symbolic links),
	 * Getwd may return any one of them.
	 * 
	 * On Unix platforms, if the environment variable PWD
	 * provides an absolute name, and it is a name of the
	 * current directory, it is returned.
	 */
	export function Getwd(): string;
	/**
	 * MkdirAll creates a directory named path,
	 * along with any necessary parents, and returns nil,
	 * or else returns an error.
	 * The permission bits perm (before umask) are used for all
	 * directories that MkdirAll creates.
	 * If path is already a directory, MkdirAll does nothing
	 * and returns nil.
	 */
	export function MkdirAll(path: string, perm: FileMode): void;
	/**
	 * RemoveAll removes path and any children it contains.
	 * It removes everything it can but returns the first error
	 * it encounters. If the path does not exist, RemoveAll
	 * returns nil (no error).
	 * If there is an error, it will be of type [*PathError].
	 */
	export function RemoveAll(path: string): void;
	/**
	 * IsPathSeparator reports whether c is a directory separator character.
	 */
	export function IsPathSeparator(c: number): boolean;
	/**
	 * Getuid returns the numeric user id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getuid(): number;
	/**
	 * Geteuid returns the numeric effective user id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Geteuid(): number;
	/**
	 * Getgid returns the numeric group id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getgid(): number;
	/**
	 * Getegid returns the numeric effective group id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getegid(): number;
	/**
	 * Getgroups returns a list of the numeric ids of groups that the caller belongs to.
	 * 
	 * On Windows, it returns [syscall.EWINDOWS]. See the [os/user] package
	 * for a possible alternative.
	 */
	export function Getgroups(): number[];
	/**
	 * Exit causes the current program to exit with the given status code.
	 * Conventionally, code zero indicates success, non-zero an error.
	 * The program terminates immediately; deferred functions are not run.
	 * 
	 * For portability, the status code should be in the range [0, 125].
	 */
	export function Exit(code: number): void;
	/**
	 * OpenInRoot opens the file name in the directory dir.
	 * It is equivalent to OpenRoot(dir) followed by opening the file in the root.
	 * 
	 * OpenInRoot returns an error if any component of the name
	 * references a location outside of dir.
	 * 
	 * See [Root] for details and limitations.
	 */
	export function OpenInRoot(dir: string, name: string): File;
	/**
	 * OpenRoot opens the named directory.
	 * It follows symbolic links in the directory name.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function OpenRoot(name: string): Root;
	/**
	 * Stat returns a [FileInfo] describing the named file.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Stat(name: string): FileInfo;
	/**
	 * Lstat returns a [FileInfo] describing the named file.
	 * If the file is a symbolic link, the returned FileInfo
	 * describes the symbolic link. Lstat makes no attempt to follow the link.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows, if the file is a reparse point that is a surrogate for another
	 * named entity (such as a symbolic link or mounted folder), the returned
	 * FileInfo describes the reparse point, and makes no attempt to resolve it.
	 */
	export function Lstat(name: string): FileInfo;
	/**
	 * Hostname returns the host name reported by the kernel.
	 */
	export function Hostname(): string;
	/**
	 * CreateTemp creates a new temporary file in the directory dir,
	 * opens the file for reading and writing, and returns the resulting file.
	 * The filename is generated by taking pattern and adding a random string to the end.
	 * If pattern includes a "*", the random string replaces the last "*".
	 * The file is created with mode 0o600 (before umask).
	 * If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
	 * Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
	 * The caller can use the file's Name method to find the pathname of the file.
	 * It is the caller's responsibility to remove the file when it is no longer needed.
	 */
	export function CreateTemp(dir: string, pattern: string): File;
	/**
	 * MkdirTemp creates a new temporary directory in the directory dir
	 * and returns the pathname of the new directory.
	 * The new directory's name is generated by adding a random string to the end of pattern.
	 * If pattern includes a "*", the random string replaces the last "*" instead.
	 * The directory is created with mode 0o700 (before umask).
	 * If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
	 * Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
	 * It is the caller's responsibility to remove the directory when it is no longer needed.
	 */
	export function MkdirTemp(dir: string, pattern: string): string;
	/**
	 * Getpagesize returns the underlying system's memory page size.
	 */
	export function Getpagesize(): number;
	/**
	 * SameFile reports whether fi1 and fi2 describe the same file.
	 * For example, on Unix this means that the device and inode fields
	 * of the two underlying structures are identical; on other systems
	 * the decision may be based on the path names.
	 * SameFile only applies to results returned by this package's [Stat].
	 * It returns false in other cases.
	 */
	export function SameFile(fi1: FileInfo, fi2: FileInfo): boolean;
}
// END: go:os

// MODULE: go:net/url
declare module "go:net/url" {
	/**
	 * Error reports an error and the operation and URL that caused it.
	 */
	export interface Error {
		Op: string;
		URL: string;
		Err: Error | null;
		Unwrap(): Error | null;
		Error(): string;
		Timeout(): boolean;
		Temporary(): boolean;
	}

	/**
	 * A URL represents a parsed URL (technically, a URI reference).
	 * 
	 * The general form represented is:
	 * 
	 * 	[scheme:][//[userinfo@]host][/]path[?query][#fragment]
	 * 
	 * URLs that do not start with a slash after the scheme are interpreted as:
	 * 
	 * 	scheme:opaque[?query][#fragment]
	 * 
	 * The Host field contains the host and port subcomponents of the URL.
	 * When the port is present, it is separated from the host with a colon.
	 * When the host is an IPv6 address, it must be enclosed in square brackets:
	 * "[fe80::1]:80". The [net.JoinHostPort] function combines a host and port
	 * into a string suitable for the Host field, adding square brackets to
	 * the host when necessary.
	 * 
	 * Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
	 * A consequence is that it is impossible to tell which slashes in the Path were
	 * slashes in the raw URL and which were %2f. This distinction is rarely important,
	 * but when it is, the code should use the [URL.EscapedPath] method, which preserves
	 * the original encoding of Path.
	 * 
	 * The RawPath field is an optional field which is only set when the default
	 * encoding of Path is different from the escaped path. See the EscapedPath method
	 * for more details.
	 * 
	 * URL's String method uses the EscapedPath method to obtain the path.
	 */
	export interface URL {
		Scheme: string;
		Opaque: string;
		User: Userinfo;
		Host: string;
		Path: string;
		RawPath: string;
		OmitHost: boolean;
		ForceQuery: boolean;
		RawQuery: string;
		Fragment: string;
		RawFragment: string;
		/**
		 * EscapedPath returns the escaped form of u.Path.
		 * In general there are multiple possible escaped forms of any path.
		 * EscapedPath returns u.RawPath when it is a valid escaping of u.Path.
		 * Otherwise EscapedPath ignores u.RawPath and computes an escaped
		 * form on its own.
		 * The [URL.String] and [URL.RequestURI] methods use EscapedPath to construct
		 * their results.
		 * In general, code should call EscapedPath instead of
		 * reading u.RawPath directly.
		 */
		EscapedPath(): string;
		/**
		 * EscapedFragment returns the escaped form of u.Fragment.
		 * In general there are multiple possible escaped forms of any fragment.
		 * EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment.
		 * Otherwise EscapedFragment ignores u.RawFragment and computes an escaped
		 * form on its own.
		 * The [URL.String] method uses EscapedFragment to construct its result.
		 * In general, code should call EscapedFragment instead of
		 * reading u.RawFragment directly.
		 */
		EscapedFragment(): string;
		/**
		 * String reassembles the [URL] into a valid URL string.
		 * The general form of the result is one of:
		 * 
		 * 	scheme:opaque?query#fragment
		 * 	scheme://userinfo@host/path?query#fragment
		 * 
		 * If u.Opaque is non-empty, String uses the first form;
		 * otherwise it uses the second form.
		 * Any non-ASCII characters in host are escaped.
		 * To obtain the path, String uses u.EscapedPath().
		 * 
		 * In the second form, the following rules apply:
		 *   - if u.Scheme is empty, scheme: is omitted.
		 *   - if u.User is nil, userinfo@ is omitted.
		 *   - if u.Host is empty, host/ is omitted.
		 *   - if u.Scheme and u.Host are empty and u.User is nil,
		 *     the entire scheme://userinfo@host/ is omitted.
		 *   - if u.Host is non-empty and u.Path begins with a /,
		 *     the form host/path does not add its own /.
		 *   - if u.RawQuery is empty, ?query is omitted.
		 *   - if u.Fragment is empty, #fragment is omitted.
		 */
		String(): string;
		/**
		 * Redacted is like [URL.String] but replaces any password with "xxxxx".
		 * Only the password in u.User is redacted.
		 */
		Redacted(): string;
		/**
		 * IsAbs reports whether the [URL] is absolute.
		 * Absolute means that it has a non-empty scheme.
		 */
		IsAbs(): boolean;
		/**
		 * Parse parses a [URL] in the context of the receiver. The provided URL
		 * may be relative or absolute. Parse returns nil, err on parse
		 * failure, otherwise its return value is the same as [URL.ResolveReference].
		 */
		Parse(ref: string): [URL, Error | null];
		/**
		 * ResolveReference resolves a URI reference to an absolute URI from
		 * an absolute base URI u, per RFC 3986 Section 5.2. The URI reference
		 * may be relative or absolute. ResolveReference always returns a new
		 * [URL] instance, even if the returned URL is identical to either the
		 * base or reference. If ref is an absolute URL, then ResolveReference
		 * ignores base and returns a copy of ref.
		 */
		ResolveReference(ref: URL): URL;
		/**
		 * Query parses RawQuery and returns the corresponding values.
		 * It silently discards malformed value pairs.
		 * To check errors use [ParseQuery].
		 */
		Query(): Values;
		/**
		 * RequestURI returns the encoded path?query or opaque?query
		 * string that would be used in an HTTP request for u.
		 */
		RequestURI(): string;
		/**
		 * Hostname returns u.Host, stripping any valid port number if present.
		 * 
		 * If the result is enclosed in square brackets, as literal IPv6 addresses are,
		 * the square brackets are removed from the result.
		 */
		Hostname(): string;
		/**
		 * Port returns the port part of u.Host, without the leading colon.
		 * 
		 * If u.Host doesn't contain a valid numeric port, Port returns an empty string.
		 */
		Port(): string;
		MarshalBinary(): [byte[], Error | null];
		AppendBinary(b: byte[]): [byte[], Error | null];
		UnmarshalBinary(text: byte[]): Error | null;
		/**
		 * JoinPath returns a new [URL] with the provided path elements joined to
		 * any existing path and the resulting path cleaned of any ./ or ../ elements.
		 * Any sequences of multiple / characters will be reduced to a single /.
		 */
		JoinPath(...elem: string[]): URL;
	}

	/**
	 * The Userinfo type is an immutable encapsulation of username and
	 * password details for a [URL]. An existing Userinfo value is guaranteed
	 * to have a username set (potentially empty, as allowed by RFC 2396),
	 * and optionally a password.
	 */
	export interface Userinfo {
		/**
		 * Username returns the username.
		 */
		Username(): string;
		/**
		 * Password returns the password in case it is set, and whether it is set.
		 */
		Password(): [string, boolean];
		/**
		 * String returns the encoded userinfo information in the standard form
		 * of "username[:password]".
		 */
		String(): string;
	}

	/**
	 * QueryUnescape does the inverse transformation of [QueryEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB.
	 * It returns an error if any % is not followed by two hexadecimal
	 * digits.
	 */
	export function QueryUnescape(s: string): string;
	/**
	 * PathUnescape does the inverse transformation of [PathEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB. It returns an error if any % is not followed
	 * by two hexadecimal digits.
	 * 
	 * PathUnescape is identical to [QueryUnescape] except that it does not
	 * unescape '+' to ' ' (space).
	 */
	export function PathUnescape(s: string): string;
	/**
	 * QueryEscape escapes the string so it can be safely placed
	 * inside a [URL] query.
	 */
	export function QueryEscape(s: string): string;
	/**
	 * PathEscape escapes the string so it can be safely placed inside a [URL] path segment,
	 * replacing special characters (including /) with %XX sequences as needed.
	 */
	export function PathEscape(s: string): string;
	/**
	 * User returns a [Userinfo] containing the provided username
	 * and no password set.
	 */
	export function User(username: string): Userinfo;
	/**
	 * UserPassword returns a [Userinfo] containing the provided username
	 * and password.
	 * 
	 * This functionality should only be used with legacy web sites.
	 * RFC 2396 warns that interpreting Userinfo this way
	 * “is NOT RECOMMENDED, because the passing of authentication
	 * information in clear text (such as URI) has proven to be a
	 * security risk in almost every case where it has been used.”
	 */
	export function UserPassword(username: string, password: string): Userinfo;
	/**
	 * Parse parses a raw url into a [URL] structure.
	 * 
	 * The url may be relative (a path, without a host) or absolute
	 * (starting with a scheme). Trying to parse a hostname and path
	 * without a scheme is invalid but may not necessarily return an
	 * error, due to parsing ambiguities.
	 */
	export function Parse(rawURL: string): URL;
	/**
	 * ParseRequestURI parses a raw url into a [URL] structure. It assumes that
	 * url was received in an HTTP request, so the url is interpreted
	 * only as an absolute URI or an absolute path.
	 * The string url is assumed not to have a #fragment suffix.
	 * (Web browsers strip #fragment before sending the URL to a web server.)
	 */
	export function ParseRequestURI(rawURL: string): URL;
	/**
	 * ParseQuery parses the URL-encoded query string and returns
	 * a map listing the values specified for each key.
	 * ParseQuery always returns a non-nil map containing all the
	 * valid query parameters found; err describes the first decoding error
	 * encountered, if any.
	 * 
	 * Query is expected to be a list of key=value settings separated by ampersands.
	 * A setting without an equals sign is interpreted as a key set to an empty
	 * value.
	 * Settings containing a non-URL-encoded semicolon are considered invalid.
	 */
	export function ParseQuery(query: string): Values;
	/**
	 * JoinPath returns a [URL] string with the provided path elements joined to
	 * the existing path of base and the resulting path cleaned of any ./ or ../ elements.
	 */
	export function JoinPath(base: string, ...elem: string[]): string;
}
// END: go:net/url

// MODULE: go:github.com/fatih/color
declare module "go:github.com/fatih/color" {
	/**
	 * Color defines a custom color object which is defined by SGR parameters.
	 */
	export interface Color {
		/**
		 * AddRGB is used to chain foreground RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddRGB(r: number, g: number, b: number): Color;
		/**
		 * AddRGB is used to chain background RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddBgRGB(r: number, g: number, b: number): Color;
		/**
		 * Set sets the SGR sequence.
		 */
		Set(): Color;
		/**
		 * SetWriter is used to set the SGR sequence with the given io.Writer. This is
		 * a low-level function, and users should use the higher-level functions, such
		 * as color.Fprint, color.Print, etc.
		 */
		SetWriter(w: io.Writer): Color;
		/**
		 * UnsetWriter resets all escape attributes and clears the output with the give
		 * io.Writer. Usually should be called after SetWriter().
		 */
		UnsetWriter(w: io.Writer): void;
		/**
		 * Add is used to chain SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: Add(color.FgRed, color.Underline).
		 */
		Add(...value: Attribute[]): Color;
		/**
		 * Fprint formats using the default formats for its operands and writes to w.
		 * Spaces are added between operands when neither is a string.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprint(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Print formats using the default formats for its operands and writes to
		 * standard output. Spaces are added between operands when neither is a
		 * string. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Print(...a: any[]): [number, Error | null];
		/**
		 * Fprintf formats according to a format specifier and writes to w.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintf(w: io.Writer, format: string, ...a: any[]): [number, Error | null];
		/**
		 * Printf formats according to a format specifier and writes to standard output.
		 * It returns the number of bytes written and any write error encountered.
		 * This is the standard fmt.Printf() method wrapped with the given color.
		 */
		Printf(format: string, ...a: any[]): [number, Error | null];
		/**
		 * Fprintln formats using the default formats for its operands and writes to w.
		 * Spaces are always added between operands and a newline is appended.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintln(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Println formats using the default formats for its operands and writes to
		 * standard output. Spaces are always added between operands and a newline is
		 * appended. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Println(...a: any[]): [number, Error | null];
		/**
		 * Sprint is just like Print, but returns a string instead of printing it.
		 */
		Sprint(...a: any[]): string;
		/**
		 * Sprintln is just like Println, but returns a string instead of printing it.
		 */
		Sprintln(...a: any[]): string;
		/**
		 * Sprintf is just like Printf, but returns a string instead of printing it.
		 */
		Sprintf(format: string, ...a: any[]): string;
		/**
		 * FprintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprint().
		 */
		FprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Print().
		 */
		PrintFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintf().
		 */
		FprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Printf().
		 */
		PrintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintln().
		 */
		FprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Println().
		 */
		PrintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprint(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output, example:
		 * 
		 * 	put := New(FgYellow).SprintFunc()
		 * 	fmt.Fprintf(color.Output, "This is a %s", put("warning"))
		 */
		SprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintfFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintf(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintlnFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintln(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * DisableColor disables the color output. Useful to not change any existing
		 * code and still being able to output. Can be used for flags like
		 * "--no-color". To enable back use EnableColor() method.
		 */
		DisableColor(): void;
		/**
		 * EnableColor enables the color output. Use it in conjunction with
		 * DisableColor(). Otherwise, this method has no side effects.
		 */
		EnableColor(): void;
		/**
		 * Equals returns a boolean value indicating whether two colors are equal.
		 */
		Equals(c2: Color): boolean;
	}

	/**
	 * New returns a newly created color object.
	 */
	export function New(...value: Attribute[]): Color;
	/**
	 * RGB returns a new foreground color in 24-bit RGB.
	 */
	export function RGB(r: number, g: number, b: number): Color;
	/**
	 * BgRGB returns a new background color in 24-bit RGB.
	 */
	export function BgRGB(r: number, g: number, b: number): Color;
	/**
	 * Set sets the given parameters immediately. It will change the color of
	 * output with the given SGR parameters until color.Unset() is called.
	 */
	export function Set(...p: Attribute[]): Color;
	/**
	 * Unset resets all escape attributes and clears the output. Usually should
	 * be called after Set().
	 */
	export function Unset(): void;
	/**
	 * Black is a convenient helper function to print with black foreground. A
	 * newline is appended to format by default.
	 */
	export function Black(format: string, ...a: any[]): void;
	/**
	 * Red is a convenient helper function to print with red foreground. A
	 * newline is appended to format by default.
	 */
	export function Red(format: string, ...a: any[]): void;
	/**
	 * Green is a convenient helper function to print with green foreground. A
	 * newline is appended to format by default.
	 */
	export function Green(format: string, ...a: any[]): void;
	/**
	 * Yellow is a convenient helper function to print with yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function Yellow(format: string, ...a: any[]): void;
	/**
	 * Blue is a convenient helper function to print with blue foreground. A
	 * newline is appended to format by default.
	 */
	export function Blue(format: string, ...a: any[]): void;
	/**
	 * Magenta is a convenient helper function to print with magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function Magenta(format: string, ...a: any[]): void;
	/**
	 * Cyan is a convenient helper function to print with cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function Cyan(format: string, ...a: any[]): void;
	/**
	 * White is a convenient helper function to print with white foreground. A
	 * newline is appended to format by default.
	 */
	export function White(format: string, ...a: any[]): void;
	/**
	 * BlackString is a convenient helper function to return a string with black
	 * foreground.
	 */
	export function BlackString(format: string, ...a: any[]): string;
	/**
	 * RedString is a convenient helper function to return a string with red
	 * foreground.
	 */
	export function RedString(format: string, ...a: any[]): string;
	/**
	 * GreenString is a convenient helper function to return a string with green
	 * foreground.
	 */
	export function GreenString(format: string, ...a: any[]): string;
	/**
	 * YellowString is a convenient helper function to return a string with yellow
	 * foreground.
	 */
	export function YellowString(format: string, ...a: any[]): string;
	/**
	 * BlueString is a convenient helper function to return a string with blue
	 * foreground.
	 */
	export function BlueString(format: string, ...a: any[]): string;
	/**
	 * MagentaString is a convenient helper function to return a string with magenta
	 * foreground.
	 */
	export function MagentaString(format: string, ...a: any[]): string;
	/**
	 * CyanString is a convenient helper function to return a string with cyan
	 * foreground.
	 */
	export function CyanString(format: string, ...a: any[]): string;
	/**
	 * WhiteString is a convenient helper function to return a string with white
	 * foreground.
	 */
	export function WhiteString(format: string, ...a: any[]): string;
	/**
	 * HiBlack is a convenient helper function to print with hi-intensity black foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlack(format: string, ...a: any[]): void;
	/**
	 * HiRed is a convenient helper function to print with hi-intensity red foreground. A
	 * newline is appended to format by default.
	 */
	export function HiRed(format: string, ...a: any[]): void;
	/**
	 * HiGreen is a convenient helper function to print with hi-intensity green foreground. A
	 * newline is appended to format by default.
	 */
	export function HiGreen(format: string, ...a: any[]): void;
	/**
	 * HiYellow is a convenient helper function to print with hi-intensity yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function HiYellow(format: string, ...a: any[]): void;
	/**
	 * HiBlue is a convenient helper function to print with hi-intensity blue foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlue(format: string, ...a: any[]): void;
	/**
	 * HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function HiMagenta(format: string, ...a: any[]): void;
	/**
	 * HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function HiCyan(format: string, ...a: any[]): void;
	/**
	 * HiWhite is a convenient helper function to print with hi-intensity white foreground. A
	 * newline is appended to format by default.
	 */
	export function HiWhite(format: string, ...a: any[]): void;
	/**
	 * HiBlackString is a convenient helper function to return a string with hi-intensity black
	 * foreground.
	 */
	export function HiBlackString(format: string, ...a: any[]): string;
	/**
	 * HiRedString is a convenient helper function to return a string with hi-intensity red
	 * foreground.
	 */
	export function HiRedString(format: string, ...a: any[]): string;
	/**
	 * HiGreenString is a convenient helper function to return a string with hi-intensity green
	 * foreground.
	 */
	export function HiGreenString(format: string, ...a: any[]): string;
	/**
	 * HiYellowString is a convenient helper function to return a string with hi-intensity yellow
	 * foreground.
	 */
	export function HiYellowString(format: string, ...a: any[]): string;
	/**
	 * HiBlueString is a convenient helper function to return a string with hi-intensity blue
	 * foreground.
	 */
	export function HiBlueString(format: string, ...a: any[]): string;
	/**
	 * HiMagentaString is a convenient helper function to return a string with hi-intensity magenta
	 * foreground.
	 */
	export function HiMagentaString(format: string, ...a: any[]): string;
	/**
	 * HiCyanString is a convenient helper function to return a string with hi-intensity cyan
	 * foreground.
	 */
	export function HiCyanString(format: string, ...a: any[]): string;
	/**
	 * HiWhiteString is a convenient helper function to return a string with hi-intensity white
	 * foreground.
	 */
	export function HiWhiteString(format: string, ...a: any[]): string;
}
// END: go:github.com/fatih/color

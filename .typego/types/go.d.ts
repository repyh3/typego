// TypeGo Type Definitions
// Auto-generated by typego types

// Helper for handling Go errors in catch blocks
declare function isGoError(e: unknown): e is Error;


// MODULE: go:fmt
declare module "go:fmt" {
	/**
	 * Errorf formats according to a format specifier and returns the string as a
	 * value that satisfies error.
	 * 
	 * If the format specifier includes a %w verb with an error operand,
	 * the returned error will implement an Unwrap method returning the operand.
	 * If there is more than one %w verb, the returned error will implement an
	 * Unwrap method returning a []error containing all the %w operands in the
	 * order they appear in the arguments.
	 * It is invalid to supply the %w verb with an operand that does not implement
	 * the error interface. The %w verb is otherwise a synonym for %v.
	 */
	export function Errorf(format: string, ...a: any[]): void;
	/**
	 * FormatString returns a string representing the fully qualified formatting
	 * directive captured by the [State], followed by the argument verb. ([State] does not
	 * itself contain the verb.) The result has a leading percent sign followed by any
	 * flags, the width, and the precision. Missing flags, width, and precision are
	 * omitted. This function allows a [Formatter] to reconstruct the original
	 * directive triggering the call to Format.
	 */
	export function FormatString(state: State, verb: rune): string;
	/**
	 * Fprintf formats according to a format specifier and writes to w.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprintf(w: io.Writer, format: string, ...a: any[]): number;
	/**
	 * Printf formats according to a format specifier and writes to standard output.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Printf(format: string, ...a: any[]): number;
	/**
	 * Sprintf formats according to a format specifier and returns the resulting string.
	 */
	export function Sprintf(format: string, ...a: any[]): string;
	/**
	 * Appendf formats according to a format specifier, appends the result to the byte
	 * slice, and returns the updated slice.
	 */
	export function Appendf(b: byte[], format: string, ...a: any[]): byte[];
	/**
	 * Fprint formats using the default formats for its operands and writes to w.
	 * Spaces are added between operands when neither is a string.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprint(w: io.Writer, ...a: any[]): number;
	/**
	 * Print formats using the default formats for its operands and writes to standard output.
	 * Spaces are added between operands when neither is a string.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Print(...a: any[]): number;
	/**
	 * Sprint formats using the default formats for its operands and returns the resulting string.
	 * Spaces are added between operands when neither is a string.
	 */
	export function Sprint(...a: any[]): string;
	/**
	 * Append formats using the default formats for its operands, appends the result to
	 * the byte slice, and returns the updated slice.
	 */
	export function Append(b: byte[], ...a: any[]): byte[];
	/**
	 * Fprintln formats using the default formats for its operands and writes to w.
	 * Spaces are always added between operands and a newline is appended.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Fprintln(w: io.Writer, ...a: any[]): number;
	/**
	 * Println formats using the default formats for its operands and writes to standard output.
	 * Spaces are always added between operands and a newline is appended.
	 * It returns the number of bytes written and any write error encountered.
	 */
	export function Println(...a: any[]): number;
	/**
	 * Sprintln formats using the default formats for its operands and returns the resulting string.
	 * Spaces are always added between operands and a newline is appended.
	 */
	export function Sprintln(...a: any[]): string;
	/**
	 * Appendln formats using the default formats for its operands, appends the result
	 * to the byte slice, and returns the updated slice. Spaces are always added
	 * between operands and a newline is appended.
	 */
	export function Appendln(b: byte[], ...a: any[]): byte[];
	/**
	 * Scan scans text read from standard input, storing successive
	 * space-separated values into successive arguments. Newlines count
	 * as space. It returns the number of items successfully scanned.
	 * If that is less than the number of arguments, err will report why.
	 */
	export function Scan(...a: any[]): number;
	/**
	 * Scanln is similar to [Scan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Scanln(...a: any[]): number;
	/**
	 * Scanf scans text read from standard input, storing successive
	 * space-separated values into successive arguments as determined by
	 * the format. It returns the number of items successfully scanned.
	 * If that is less than the number of arguments, err will report why.
	 * Newlines in the input must match newlines in the format.
	 * The one exception: the verb %c always scans the next rune in the
	 * input, even if it is a space (or tab etc.) or newline.
	 */
	export function Scanf(format: string, ...a: any[]): number;
	/**
	 * Sscan scans the argument string, storing successive space-separated
	 * values into successive arguments. Newlines count as space. It
	 * returns the number of items successfully scanned. If that is less
	 * than the number of arguments, err will report why.
	 */
	export function Sscan(str: string, ...a: any[]): number;
	/**
	 * Sscanln is similar to [Sscan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Sscanln(str: string, ...a: any[]): number;
	/**
	 * Sscanf scans the argument string, storing successive space-separated
	 * values into successive arguments as determined by the format. It
	 * returns the number of items successfully parsed.
	 * Newlines in the input must match newlines in the format.
	 */
	export function Sscanf(str: string, format: string, ...a: any[]): number;
	/**
	 * Fscan scans text read from r, storing successive space-separated
	 * values into successive arguments. Newlines count as space. It
	 * returns the number of items successfully scanned. If that is less
	 * than the number of arguments, err will report why.
	 */
	export function Fscan(r: io.Reader, ...a: any[]): number;
	/**
	 * Fscanln is similar to [Fscan], but stops scanning at a newline and
	 * after the final item there must be a newline or EOF.
	 */
	export function Fscanln(r: io.Reader, ...a: any[]): number;
	/**
	 * Fscanf scans text read from r, storing successive space-separated
	 * values into successive arguments as determined by the format. It
	 * returns the number of items successfully parsed.
	 * Newlines in the input must match newlines in the format.
	 */
	export function Fscanf(r: io.Reader, format: string, ...a: any[]): number;
}
// END: go:fmt

// MODULE: go:os
declare module "go:os" {
	import { SysProcAttr } from "go:syscall";

	/**
	 * File represents an open file descriptor.
	 * 
	 * The methods of File are safe for concurrent use.
	 */
	export interface File {
	}

	/**
	 * SyscallError records an error from a specific system call.
	 */
	export interface SyscallError {
		Syscall: string;
		Err: Error | null;
		Error(): string;
		Unwrap(): Error | null;
		/**
		 * Timeout reports whether this error represents a timeout.
		 */
		Timeout(): boolean;
	}

	/**
	 * Process stores the information about a process created by [StartProcess].
	 */
	export interface Process {
		Pid: number;
		/**
		 * Release releases any resources associated with the [Process] p,
		 * rendering it unusable in the future.
		 * Release only needs to be called if [Process.Wait] is not.
		 */
		Release(): Error | null;
		/**
		 * Kill causes the [Process] to exit immediately. Kill does not wait until
		 * the Process has actually exited. This only kills the Process itself,
		 * not any other processes it may have started.
		 */
		Kill(): Error | null;
		/**
		 * Wait waits for the [Process] to exit, and then returns a
		 * ProcessState describing its status and an error, if any.
		 * Wait releases any resources associated with the Process.
		 * On most operating systems, the Process must be a child
		 * of the current process or an error will be returned.
		 */
		Wait(): [ProcessState, Error | null];
		/**
		 * Signal sends a signal to the [Process].
		 * Sending [Interrupt] on Windows is not implemented.
		 */
		Signal(sig: Signal): Error | null;
	}

	/**
	 * ProcAttr holds the attributes that will be applied to a new process
	 * started by StartProcess.
	 */
	export interface ProcAttr {
		Dir: string;
		Env: string[];
		Files: File[];
		Sys: SysProcAttr;
	}

	/**
	 * ProcessState stores information about a process, as reported by Wait.
	 */
	export interface ProcessState {
		/**
		 * Pid returns the process id of the exited process.
		 */
		Pid(): number;
		String(): string;
		/**
		 * ExitCode returns the exit code of the exited process, or -1
		 * if the process hasn't exited or was terminated by a signal.
		 */
		ExitCode(): number;
	}

	/**
	 * LinkError records an error during a link or symlink or rename
	 * system call and the paths that caused it.
	 */
	export interface LinkError {
		Op: string;
		Old: string;
		New: string;
		Err: Error | null;
		Error(): string;
		Unwrap(): Error | null;
	}

	/**
	 * Root may be used to only access files within a single directory tree.
	 * 
	 * Methods on Root can only access files and directories beneath a root directory.
	 * If any component of a file name passed to a method of Root references a location
	 * outside the root, the method returns an error.
	 * File names may reference the directory itself (.).
	 * 
	 * Methods on Root will follow symbolic links, but symbolic links may not
	 * reference a location outside the root.
	 * Symbolic links must not be absolute.
	 * 
	 * Methods on Root do not prohibit traversal of filesystem boundaries,
	 * Linux bind mounts, /proc special files, or access to Unix device files.
	 * 
	 * Methods on Root are safe to be used from multiple goroutines simultaneously.
	 * 
	 * On most platforms, creating a Root opens a file descriptor or handle referencing
	 * the directory. If the directory is moved, methods on Root reference the original
	 * directory in its new location.
	 * 
	 * Root's behavior differs on some platforms:
	 * 
	 *   - When GOOS=windows, file names may not reference Windows reserved device names
	 *     such as NUL and COM1.
	 *   - On Unix, [Root.Chmod], [Root.Chown], and [Root.Chtimes] are vulnerable to a race condition.
	 *     If the target of the operation is changed from a regular file to a symlink
	 *     while the operation is in progress, the operation may be performed on the link
	 *     rather than the link target.
	 *   - When GOOS=js, Root is vulnerable to TOCTOU (time-of-check-time-of-use)
	 *     attacks in symlink validation, and cannot ensure that operations will not
	 *     escape the root.
	 *   - When GOOS=plan9 or GOOS=js, Root does not track directories across renames.
	 *     On these platforms, a Root references a directory name, not a file descriptor.
	 *   - WASI preview 1 (GOOS=wasip1) does not support [Root.Chmod].
	 */
	export interface Root {
		/**
		 * Name returns the name of the directory presented to OpenRoot.
		 * 
		 * It is safe to call Name after [Close].
		 */
		Name(): string;
		/**
		 * Close closes the Root.
		 * After Close is called, methods on Root return errors.
		 */
		Close(): Error | null;
		/**
		 * Open opens the named file in the root for reading.
		 * See [Open] for more details.
		 */
		Open(name: string): [File, Error | null];
		/**
		 * Create creates or truncates the named file in the root.
		 * See [Create] for more details.
		 */
		Create(name: string): [File, Error | null];
		/**
		 * OpenFile opens the named file in the root.
		 * See [OpenFile] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * OpenFile returns an error.
		 */
		OpenFile(name: string, flag: number, perm: FileMode): [File, Error | null];
		/**
		 * OpenRoot opens the named directory in the root.
		 * If there is an error, it will be of type [*PathError].
		 */
		OpenRoot(name: string): [Root, Error | null];
		/**
		 * Chmod changes the mode of the named file in the root to mode.
		 * See [Chmod] for more details.
		 */
		Chmod(name: string, mode: FileMode): Error | null;
		/**
		 * Mkdir creates a new directory in the root
		 * with the specified name and permission bits (before umask).
		 * See [Mkdir] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * Mkdir returns an error.
		 */
		Mkdir(name: string, perm: FileMode): Error | null;
		/**
		 * MkdirAll creates a new directory in the root, along with any necessary parents.
		 * See [MkdirAll] for more details.
		 * 
		 * If perm contains bits other than the nine least-significant bits (0o777),
		 * MkdirAll returns an error.
		 */
		MkdirAll(name: string, perm: FileMode): Error | null;
		/**
		 * Chown changes the numeric uid and gid of the named file in the root.
		 * See [Chown] for more details.
		 */
		Chown(name: string, uid: number, gid: number): Error | null;
		/**
		 * Lchown changes the numeric uid and gid of the named file in the root.
		 * See [Lchown] for more details.
		 */
		Lchown(name: string, uid: number, gid: number): Error | null;
		/**
		 * Chtimes changes the access and modification times of the named file in the root.
		 * See [Chtimes] for more details.
		 */
		Chtimes(name: string, atime: time.Time, mtime: time.Time): Error | null;
		/**
		 * Remove removes the named file or (empty) directory in the root.
		 * See [Remove] for more details.
		 */
		Remove(name: string): Error | null;
		/**
		 * RemoveAll removes the named file or directory and any children that it contains.
		 * See [RemoveAll] for more details.
		 */
		RemoveAll(name: string): Error | null;
		/**
		 * Stat returns a [FileInfo] describing the named file in the root.
		 * See [Stat] for more details.
		 */
		Stat(name: string): [FileInfo, Error | null];
		/**
		 * Lstat returns a [FileInfo] describing the named file in the root.
		 * If the file is a symbolic link, the returned FileInfo
		 * describes the symbolic link.
		 * See [Lstat] for more details.
		 */
		Lstat(name: string): [FileInfo, Error | null];
		/**
		 * Readlink returns the destination of the named symbolic link in the root.
		 * See [Readlink] for more details.
		 */
		Readlink(name: string): [string, Error | null];
		/**
		 * Rename renames (moves) oldname to newname.
		 * Both paths are relative to the root.
		 * See [Rename] for more details.
		 */
		Rename(oldname: string, newname: string): Error | null;
		/**
		 * Link creates newname as a hard link to the oldname file.
		 * Both paths are relative to the root.
		 * See [Link] for more details.
		 * 
		 * If oldname is a symbolic link, Link creates new link to oldname and not its target.
		 * This behavior may differ from that of [Link] on some platforms.
		 * 
		 * When GOOS=js, Link returns an error if oldname is a symbolic link.
		 */
		Link(oldname: string, newname: string): Error | null;
		/**
		 * Symlink creates newname as a symbolic link to oldname.
		 * See [Symlink] for more details.
		 * 
		 * Symlink does not validate oldname,
		 * which may reference a location outside the root.
		 * 
		 * On Windows, a directory link is created if oldname references
		 * a directory within the root. Otherwise a file link is created.
		 */
		Symlink(oldname: string, newname: string): Error | null;
		/**
		 * ReadFile reads the named file in the root and returns its contents.
		 * See [ReadFile] for more details.
		 */
		ReadFile(name: string): [byte[], Error | null];
		/**
		 * WriteFile writes data to the named file in the root, creating it if necessary.
		 * See [WriteFile] for more details.
		 */
		WriteFile(name: string, data: byte[], perm: FileMode): Error | null;
		/**
		 * FS returns a file system (an fs.FS) for the tree of files in the root.
		 * 
		 * The result implements [io/fs.StatFS], [io/fs.ReadFileFS],
		 * [io/fs.ReadDirFS], and [io/fs.ReadLinkFS].
		 */
		FS(): fs.FS;
	}

	/**
	 * ReadDir reads the named directory,
	 * returning all its directory entries sorted by filename.
	 * If an error occurs reading the directory,
	 * ReadDir returns the entries it was able to read before the error,
	 * along with the error.
	 */
	export function ReadDir(name: string): DirEntry[];
	/**
	 * CopyFS copies the file system fsys into the directory dir,
	 * creating dir if necessary.
	 * 
	 * Files are created with mode 0o666 plus any execute permissions
	 * from the source, and directories are created with mode 0o777
	 * (before umask).
	 * 
	 * CopyFS will not overwrite existing files. If a file name in fsys
	 * already exists in the destination, CopyFS will return an error
	 * such that errors.Is(err, fs.ErrExist) will be true.
	 * 
	 * Symbolic links in dir are followed.
	 * 
	 * New files added to fsys (including if dir is a subdirectory of fsys)
	 * while CopyFS is running are not guaranteed to be copied.
	 * 
	 * Copying stops at and returns the first error encountered.
	 */
	export function CopyFS(dir: string, fsys: fs.FS): void;
	/**
	 * Expand replaces ${var} or $var in the string based on the mapping function.
	 * For example, [os.ExpandEnv](s) is equivalent to [os.Expand](s, [os.Getenv]).
	 */
	export function Expand(s: string, mapping: (...args: unknown[]) => unknown): string;
	/**
	 * ExpandEnv replaces ${var} or $var in the string according to the values
	 * of the current environment variables. References to undefined
	 * variables are replaced by the empty string.
	 */
	export function ExpandEnv(s: string): string;
	/**
	 * Getenv retrieves the value of the environment variable named by the key.
	 * It returns the value, which will be empty if the variable is not present.
	 * To distinguish between an empty value and an unset value, use [LookupEnv].
	 */
	export function Getenv(key: string): string;
	/**
	 * LookupEnv retrieves the value of the environment variable named
	 * by the key. If the variable is present in the environment the
	 * value (which may be empty) is returned and the boolean is true.
	 * Otherwise the returned value will be empty and the boolean will
	 * be false.
	 */
	export function LookupEnv(key: string): [string, boolean];
	/**
	 * Setenv sets the value of the environment variable named by the key.
	 * It returns an error, if any.
	 */
	export function Setenv(key: string, value: string): void;
	/**
	 * Unsetenv unsets a single environment variable.
	 */
	export function Unsetenv(key: string): void;
	/**
	 * Clearenv deletes all environment variables.
	 */
	export function Clearenv(): void;
	/**
	 * Environ returns a copy of strings representing the environment,
	 * in the form "key=value".
	 */
	export function Environ(): string[];
	/**
	 * NewSyscallError returns, as an error, a new [SyscallError]
	 * with the given system call name and error details.
	 * As a convenience, if err is nil, NewSyscallError returns nil.
	 */
	export function NewSyscallError(syscall: string, err: Error | null): void;
	/**
	 * IsExist returns a boolean indicating whether its argument is known to report
	 * that a file or directory already exists. It is satisfied by [ErrExist] as
	 * well as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrExist).
	 */
	export function IsExist(err: Error | null): boolean;
	/**
	 * IsNotExist returns a boolean indicating whether its argument is known to
	 * report that a file or directory does not exist. It is satisfied by
	 * [ErrNotExist] as well as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrNotExist).
	 */
	export function IsNotExist(err: Error | null): boolean;
	/**
	 * IsPermission returns a boolean indicating whether its argument is known to
	 * report that permission is denied. It is satisfied by [ErrPermission] as well
	 * as some syscall errors.
	 * 
	 * This function predates [errors.Is]. It only supports errors returned by
	 * the os package. New code should use errors.Is(err, fs.ErrPermission).
	 */
	export function IsPermission(err: Error | null): boolean;
	/**
	 * IsTimeout returns a boolean indicating whether its argument is known
	 * to report that a timeout occurred.
	 * 
	 * This function predates [errors.Is], and the notion of whether an
	 * error indicates a timeout can be ambiguous. For example, the Unix
	 * error EWOULDBLOCK sometimes indicates a timeout and sometimes does not.
	 * New code should use errors.Is with a value appropriate to the call
	 * returning the error, such as [os.ErrDeadlineExceeded].
	 */
	export function IsTimeout(err: Error | null): boolean;
	/**
	 * Getpid returns the process id of the caller.
	 */
	export function Getpid(): number;
	/**
	 * Getppid returns the process id of the caller's parent.
	 */
	export function Getppid(): number;
	/**
	 * FindProcess looks for a running process by its pid.
	 * 
	 * The [Process] it returns can be used to obtain information
	 * about the underlying operating system process.
	 * 
	 * On Unix systems, FindProcess always succeeds and returns a Process
	 * for the given pid, regardless of whether the process exists. To test whether
	 * the process actually exists, see whether p.Signal(syscall.Signal(0)) reports
	 * an error.
	 */
	export function FindProcess(pid: number): Process;
	/**
	 * StartProcess starts a new process with the program, arguments and attributes
	 * specified by name, argv and attr. The argv slice will become [os.Args] in the
	 * new process, so it normally starts with the program name.
	 * 
	 * If the calling goroutine has locked the operating system thread
	 * with [runtime.LockOSThread] and modified any inheritable OS-level
	 * thread state (for example, Linux or Plan 9 name spaces), the new
	 * process will inherit the caller's thread state.
	 * 
	 * StartProcess is a low-level interface. The [os/exec] package provides
	 * higher-level interfaces.
	 * 
	 * If there is an error, it will be of type [*PathError].
	 */
	export function StartProcess(name: string, argv: string[], attr: ProcAttr): Process;
	/**
	 * Executable returns the path name for the executable that started
	 * the current process. There is no guarantee that the path is still
	 * pointing to the correct executable. If a symlink was used to start
	 * the process, depending on the operating system, the result might
	 * be the symlink or the path it pointed to. If a stable result is
	 * needed, [path/filepath.EvalSymlinks] might help.
	 * 
	 * Executable returns an absolute path unless an error occurred.
	 * 
	 * The main use case is finding resources located relative to an
	 * executable.
	 */
	export function Executable(): string;
	/**
	 * NewFile returns a new [File] with the given file descriptor and name.
	 * The returned value will be nil if fd is not a valid file descriptor.
	 * 
	 * NewFile's behavior differs on some platforms:
	 * 
	 *   - On Unix, if fd is in non-blocking mode, NewFile will attempt to return a pollable file.
	 *   - On Windows, if fd is opened for asynchronous I/O (that is, [syscall.FILE_FLAG_OVERLAPPED]
	 *     has been specified in the [syscall.CreateFile] call), NewFile will attempt to return a pollable
	 *     file by associating fd with the Go runtime I/O completion port.
	 *     The I/O operations will be performed synchronously if the association fails.
	 * 
	 * Only pollable files support [File.SetDeadline], [File.SetReadDeadline], and [File.SetWriteDeadline].
	 * 
	 * After passing it to NewFile, fd may become invalid under the same conditions described
	 * in the comments of [File.Fd], and the same constraints apply.
	 */
	export function NewFile(fd: uintptr, name: string): File;
	/**
	 * Mkdir creates a new directory with the specified name and permission
	 * bits (before umask).
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Mkdir(name: string, perm: FileMode): void;
	/**
	 * Chdir changes the current working directory to the named directory.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Chdir(dir: string): void;
	/**
	 * Open opens the named file for reading. If successful, methods on
	 * the returned file can be used for reading; the associated file
	 * descriptor has mode [O_RDONLY].
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Open(name: string): File;
	/**
	 * Create creates or truncates the named file. If the file already exists,
	 * it is truncated. If the file does not exist, it is created with mode 0o666
	 * (before umask). If successful, methods on the returned File can
	 * be used for I/O; the associated file descriptor has mode [O_RDWR].
	 * The directory containing the file must already exist.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Create(name: string): File;
	/**
	 * OpenFile is the generalized open call; most users will use Open
	 * or Create instead. It opens the named file with specified flag
	 * ([O_RDONLY] etc.). If the file does not exist, and the [O_CREATE] flag
	 * is passed, it is created with mode perm (before umask);
	 * the containing directory must exist. If successful,
	 * methods on the returned File can be used for I/O.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function OpenFile(name: string, flag: number, perm: FileMode): File;
	/**
	 * Rename renames (moves) oldpath to newpath.
	 * If newpath already exists and is not a directory, Rename replaces it.
	 * If newpath already exists and is a directory, Rename returns an error.
	 * OS-specific restrictions may apply when oldpath and newpath are in different directories.
	 * Even within the same directory, on non-Unix platforms Rename is not an atomic operation.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Rename(oldpath: string, newpath: string): void;
	/**
	 * Readlink returns the destination of the named symbolic link.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * If the link destination is relative, Readlink returns the relative path
	 * without resolving it to an absolute one.
	 */
	export function Readlink(name: string): string;
	/**
	 * TempDir returns the default directory to use for temporary files.
	 * 
	 * On Unix systems, it returns $TMPDIR if non-empty, else /tmp.
	 * On Windows, it uses GetTempPath, returning the first non-empty
	 * value from %TMP%, %TEMP%, %USERPROFILE%, or the Windows directory.
	 * On Plan 9, it returns /tmp.
	 * 
	 * The directory is neither guaranteed to exist nor have accessible
	 * permissions.
	 */
	export function TempDir(): string;
	/**
	 * UserCacheDir returns the default root directory to use for user-specific
	 * cached data. Users should create their own application-specific subdirectory
	 * within this one and use that.
	 * 
	 * On Unix systems, it returns $XDG_CACHE_HOME as specified by
	 * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
	 * non-empty, else $HOME/.cache.
	 * On Darwin, it returns $HOME/Library/Caches.
	 * On Windows, it returns %LocalAppData%.
	 * On Plan 9, it returns $home/lib/cache.
	 * 
	 * If the location cannot be determined (for example, $HOME is not defined) or
	 * the path in $XDG_CACHE_HOME is relative, then it will return an error.
	 */
	export function UserCacheDir(): string;
	/**
	 * UserConfigDir returns the default root directory to use for user-specific
	 * configuration data. Users should create their own application-specific
	 * subdirectory within this one and use that.
	 * 
	 * On Unix systems, it returns $XDG_CONFIG_HOME as specified by
	 * https://specifications.freedesktop.org/basedir-spec/basedir-spec-latest.html if
	 * non-empty, else $HOME/.config.
	 * On Darwin, it returns $HOME/Library/Application Support.
	 * On Windows, it returns %AppData%.
	 * On Plan 9, it returns $home/lib.
	 * 
	 * If the location cannot be determined (for example, $HOME is not defined) or
	 * the path in $XDG_CONFIG_HOME is relative, then it will return an error.
	 */
	export function UserConfigDir(): string;
	/**
	 * UserHomeDir returns the current user's home directory.
	 * 
	 * On Unix, including macOS, it returns the $HOME environment variable.
	 * On Windows, it returns %USERPROFILE%.
	 * On Plan 9, it returns the $home environment variable.
	 * 
	 * If the expected variable is not set in the environment, UserHomeDir
	 * returns either a platform-specific default value or a non-nil error.
	 */
	export function UserHomeDir(): string;
	/**
	 * Chmod changes the mode of the named file to mode.
	 * If the file is a symbolic link, it changes the mode of the link's target.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * A different subset of the mode bits are used, depending on the
	 * operating system.
	 * 
	 * On Unix, the mode's permission bits, [ModeSetuid], [ModeSetgid], and
	 * [ModeSticky] are used.
	 * 
	 * On Windows, only the 0o200 bit (owner writable) of mode is used; it
	 * controls whether the file's read-only attribute is set or cleared.
	 * The other bits are currently unused. For compatibility with Go 1.12
	 * and earlier, use a non-zero mode. Use mode 0o400 for a read-only
	 * file and 0o600 for a readable+writable file.
	 * 
	 * On Plan 9, the mode's permission bits, [ModeAppend], [ModeExclusive],
	 * and [ModeTemporary] are used.
	 */
	export function Chmod(name: string, mode: FileMode): void;
	/**
	 * DirFS returns a file system (an fs.FS) for the tree of files rooted at the directory dir.
	 * 
	 * Note that DirFS("/prefix") only guarantees that the Open calls it makes to the
	 * operating system will begin with "/prefix": DirFS("/prefix").Open("file") is the
	 * same as os.Open("/prefix/file"). So if /prefix/file is a symbolic link pointing outside
	 * the /prefix tree, then using DirFS does not stop the access any more than using
	 * os.Open does. Additionally, the root of the fs.FS returned for a relative path,
	 * DirFS("prefix"), will be affected by later calls to Chdir. DirFS is therefore not
	 * a general substitute for a chroot-style security mechanism when the directory tree
	 * contains arbitrary content.
	 * 
	 * Use [Root.FS] to obtain a fs.FS that prevents escapes from the tree via symbolic links.
	 * 
	 * The directory dir must not be "".
	 * 
	 * The result implements [io/fs.StatFS], [io/fs.ReadFileFS], [io/fs.ReadDirFS], and
	 * [io/fs.ReadLinkFS].
	 */
	export function DirFS(dir: string): fs.FS;
	/**
	 * ReadFile reads the named file and returns the contents.
	 * A successful call returns err == nil, not err == EOF.
	 * Because ReadFile reads the whole file, it does not treat an EOF from Read
	 * as an error to be reported.
	 */
	export function ReadFile(name: string): byte[];
	/**
	 * WriteFile writes data to the named file, creating it if necessary.
	 * If the file does not exist, WriteFile creates it with permissions perm (before umask);
	 * otherwise WriteFile truncates it before writing, without changing permissions.
	 * Since WriteFile requires multiple system calls to complete, a failure mid-operation
	 * can leave the file in a partially written state.
	 */
	export function WriteFile(name: string, data: byte[], perm: FileMode): void;
	/**
	 * Chown changes the numeric uid and gid of the named file.
	 * If the file is a symbolic link, it changes the uid and gid of the link's target.
	 * A uid or gid of -1 means to not change that value.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows or Plan 9, Chown always returns the [syscall.EWINDOWS] or
	 * [syscall.EPLAN9] error, wrapped in [*PathError].
	 */
	export function Chown(name: string, uid: number, gid: number): void;
	/**
	 * Lchown changes the numeric uid and gid of the named file.
	 * If the file is a symbolic link, it changes the uid and gid of the link itself.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows, it always returns the [syscall.EWINDOWS] error, wrapped
	 * in [*PathError].
	 */
	export function Lchown(name: string, uid: number, gid: number): void;
	/**
	 * Chtimes changes the access and modification times of the named
	 * file, similar to the Unix utime() or utimes() functions.
	 * A zero [time.Time] value will leave the corresponding file time unchanged.
	 * 
	 * The underlying filesystem may truncate or round the values to a
	 * less precise time unit.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Chtimes(name: string, atime: time.Time, mtime: time.Time): void;
	/**
	 * Truncate changes the size of the named file.
	 * If the file is a symbolic link, it changes the size of the link's target.
	 */
	export function Truncate(name: string, size: number): void;
	/**
	 * Remove removes the named file or directory.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Remove(name: string): void;
	/**
	 * Pipe returns a connected pair of Files; reads from r return bytes written to w.
	 * It returns the files and an error, if any. The Windows handles underlying
	 * the returned files are marked as inheritable by child processes.
	 */
	export function Pipe(): [File, File];
	/**
	 * Link creates newname as a hard link to the oldname file.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Link(oldname: string, newname: string): void;
	/**
	 * Symlink creates newname as a symbolic link to oldname.
	 * On Windows, a symlink to a non-existent oldname creates a file symlink;
	 * if oldname is later created as a directory the symlink will not work.
	 * If there is an error, it will be of type *LinkError.
	 */
	export function Symlink(oldname: string, newname: string): void;
	/**
	 * Getwd returns an absolute path name corresponding to the
	 * current directory. If the current directory can be
	 * reached via multiple paths (due to symbolic links),
	 * Getwd may return any one of them.
	 * 
	 * On Unix platforms, if the environment variable PWD
	 * provides an absolute name, and it is a name of the
	 * current directory, it is returned.
	 */
	export function Getwd(): string;
	/**
	 * MkdirAll creates a directory named path,
	 * along with any necessary parents, and returns nil,
	 * or else returns an error.
	 * The permission bits perm (before umask) are used for all
	 * directories that MkdirAll creates.
	 * If path is already a directory, MkdirAll does nothing
	 * and returns nil.
	 */
	export function MkdirAll(path: string, perm: FileMode): void;
	/**
	 * RemoveAll removes path and any children it contains.
	 * It removes everything it can but returns the first error
	 * it encounters. If the path does not exist, RemoveAll
	 * returns nil (no error).
	 * If there is an error, it will be of type [*PathError].
	 */
	export function RemoveAll(path: string): void;
	/**
	 * IsPathSeparator reports whether c is a directory separator character.
	 */
	export function IsPathSeparator(c: number): boolean;
	/**
	 * Getuid returns the numeric user id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getuid(): number;
	/**
	 * Geteuid returns the numeric effective user id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Geteuid(): number;
	/**
	 * Getgid returns the numeric group id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getgid(): number;
	/**
	 * Getegid returns the numeric effective group id of the caller.
	 * 
	 * On Windows, it returns -1.
	 */
	export function Getegid(): number;
	/**
	 * Getgroups returns a list of the numeric ids of groups that the caller belongs to.
	 * 
	 * On Windows, it returns [syscall.EWINDOWS]. See the [os/user] package
	 * for a possible alternative.
	 */
	export function Getgroups(): number[];
	/**
	 * Exit causes the current program to exit with the given status code.
	 * Conventionally, code zero indicates success, non-zero an error.
	 * The program terminates immediately; deferred functions are not run.
	 * 
	 * For portability, the status code should be in the range [0, 125].
	 */
	export function Exit(code: number): void;
	/**
	 * OpenInRoot opens the file name in the directory dir.
	 * It is equivalent to OpenRoot(dir) followed by opening the file in the root.
	 * 
	 * OpenInRoot returns an error if any component of the name
	 * references a location outside of dir.
	 * 
	 * See [Root] for details and limitations.
	 */
	export function OpenInRoot(dir: string, name: string): File;
	/**
	 * OpenRoot opens the named directory.
	 * It follows symbolic links in the directory name.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function OpenRoot(name: string): Root;
	/**
	 * Stat returns a [FileInfo] describing the named file.
	 * If there is an error, it will be of type [*PathError].
	 */
	export function Stat(name: string): FileInfo;
	/**
	 * Lstat returns a [FileInfo] describing the named file.
	 * If the file is a symbolic link, the returned FileInfo
	 * describes the symbolic link. Lstat makes no attempt to follow the link.
	 * If there is an error, it will be of type [*PathError].
	 * 
	 * On Windows, if the file is a reparse point that is a surrogate for another
	 * named entity (such as a symbolic link or mounted folder), the returned
	 * FileInfo describes the reparse point, and makes no attempt to resolve it.
	 */
	export function Lstat(name: string): FileInfo;
	/**
	 * Hostname returns the host name reported by the kernel.
	 */
	export function Hostname(): string;
	/**
	 * CreateTemp creates a new temporary file in the directory dir,
	 * opens the file for reading and writing, and returns the resulting file.
	 * The filename is generated by taking pattern and adding a random string to the end.
	 * If pattern includes a "*", the random string replaces the last "*".
	 * The file is created with mode 0o600 (before umask).
	 * If dir is the empty string, CreateTemp uses the default directory for temporary files, as returned by [TempDir].
	 * Multiple programs or goroutines calling CreateTemp simultaneously will not choose the same file.
	 * The caller can use the file's Name method to find the pathname of the file.
	 * It is the caller's responsibility to remove the file when it is no longer needed.
	 */
	export function CreateTemp(dir: string, pattern: string): File;
	/**
	 * MkdirTemp creates a new temporary directory in the directory dir
	 * and returns the pathname of the new directory.
	 * The new directory's name is generated by adding a random string to the end of pattern.
	 * If pattern includes a "*", the random string replaces the last "*" instead.
	 * The directory is created with mode 0o700 (before umask).
	 * If dir is the empty string, MkdirTemp uses the default directory for temporary files, as returned by TempDir.
	 * Multiple programs or goroutines calling MkdirTemp simultaneously will not choose the same directory.
	 * It is the caller's responsibility to remove the directory when it is no longer needed.
	 */
	export function MkdirTemp(dir: string, pattern: string): string;
	/**
	 * Getpagesize returns the underlying system's memory page size.
	 */
	export function Getpagesize(): number;
	/**
	 * SameFile reports whether fi1 and fi2 describe the same file.
	 * For example, on Unix this means that the device and inode fields
	 * of the two underlying structures are identical; on other systems
	 * the decision may be based on the path names.
	 * SameFile only applies to results returned by this package's [Stat].
	 * It returns false in other cases.
	 */
	export function SameFile(fi1: FileInfo, fi2: FileInfo): boolean;
}
// END: go:os

// MODULE: go:github.com/fatih/color
declare module "go:github.com/fatih/color" {
	/**
	 * Color defines a custom color object which is defined by SGR parameters.
	 */
	export interface Color {
		/**
		 * AddRGB is used to chain foreground RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddRGB(r: number, g: number, b: number): Color;
		/**
		 * AddRGB is used to chain background RGB SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: .Add(34, 0, 12).Add(255, 128, 0).
		 */
		AddBgRGB(r: number, g: number, b: number): Color;
		/**
		 * Set sets the SGR sequence.
		 */
		Set(): Color;
		/**
		 * SetWriter is used to set the SGR sequence with the given io.Writer. This is
		 * a low-level function, and users should use the higher-level functions, such
		 * as color.Fprint, color.Print, etc.
		 */
		SetWriter(w: io.Writer): Color;
		/**
		 * UnsetWriter resets all escape attributes and clears the output with the give
		 * io.Writer. Usually should be called after SetWriter().
		 */
		UnsetWriter(w: io.Writer): void;
		/**
		 * Add is used to chain SGR parameters. Use as many as parameters to combine
		 * and create custom color objects. Example: Add(color.FgRed, color.Underline).
		 */
		Add(...value: Attribute[]): Color;
		/**
		 * Fprint formats using the default formats for its operands and writes to w.
		 * Spaces are added between operands when neither is a string.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprint(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Print formats using the default formats for its operands and writes to
		 * standard output. Spaces are added between operands when neither is a
		 * string. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Print(...a: any[]): [number, Error | null];
		/**
		 * Fprintf formats according to a format specifier and writes to w.
		 * It returns the number of bytes written and any write error encountered.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintf(w: io.Writer, format: string, ...a: any[]): [number, Error | null];
		/**
		 * Printf formats according to a format specifier and writes to standard output.
		 * It returns the number of bytes written and any write error encountered.
		 * This is the standard fmt.Printf() method wrapped with the given color.
		 */
		Printf(format: string, ...a: any[]): [number, Error | null];
		/**
		 * Fprintln formats using the default formats for its operands and writes to w.
		 * Spaces are always added between operands and a newline is appended.
		 * On Windows, users should wrap w with colorable.NewColorable() if w is of
		 * type *os.File.
		 */
		Fprintln(w: io.Writer, ...a: any[]): [number, Error | null];
		/**
		 * Println formats using the default formats for its operands and writes to
		 * standard output. Spaces are always added between operands and a newline is
		 * appended. It returns the number of bytes written and any write error
		 * encountered. This is the standard fmt.Print() method wrapped with the given
		 * color.
		 */
		Println(...a: any[]): [number, Error | null];
		/**
		 * Sprint is just like Print, but returns a string instead of printing it.
		 */
		Sprint(...a: any[]): string;
		/**
		 * Sprintln is just like Println, but returns a string instead of printing it.
		 */
		Sprintln(...a: any[]): string;
		/**
		 * Sprintf is just like Printf, but returns a string instead of printing it.
		 */
		Sprintf(format: string, ...a: any[]): string;
		/**
		 * FprintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprint().
		 */
		FprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintFunc returns a new function that prints the passed arguments as
		 * colorized with color.Print().
		 */
		PrintFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintf().
		 */
		FprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintfFunc returns a new function that prints the passed arguments as
		 * colorized with color.Printf().
		 */
		PrintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * FprintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Fprintln().
		 */
		FprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * PrintlnFunc returns a new function that prints the passed arguments as
		 * colorized with color.Println().
		 */
		PrintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprint(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output, example:
		 * 
		 * 	put := New(FgYellow).SprintFunc()
		 * 	fmt.Fprintf(color.Output, "This is a %s", put("warning"))
		 */
		SprintFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintfFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintf(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintfFunc(): (...args: unknown[]) => unknown;
		/**
		 * SprintlnFunc returns a new function that returns colorized strings for the
		 * given arguments with fmt.Sprintln(). Useful to put into or mix into other
		 * string. Windows users should use this in conjunction with color.Output.
		 */
		SprintlnFunc(): (...args: unknown[]) => unknown;
		/**
		 * DisableColor disables the color output. Useful to not change any existing
		 * code and still being able to output. Can be used for flags like
		 * "--no-color". To enable back use EnableColor() method.
		 */
		DisableColor(): void;
		/**
		 * EnableColor enables the color output. Use it in conjunction with
		 * DisableColor(). Otherwise, this method has no side effects.
		 */
		EnableColor(): void;
		/**
		 * Equals returns a boolean value indicating whether two colors are equal.
		 */
		Equals(c2: Color): boolean;
	}

	/**
	 * New returns a newly created color object.
	 */
	export function New(...value: Attribute[]): Color;
	/**
	 * RGB returns a new foreground color in 24-bit RGB.
	 */
	export function RGB(r: number, g: number, b: number): Color;
	/**
	 * BgRGB returns a new background color in 24-bit RGB.
	 */
	export function BgRGB(r: number, g: number, b: number): Color;
	/**
	 * Set sets the given parameters immediately. It will change the color of
	 * output with the given SGR parameters until color.Unset() is called.
	 */
	export function Set(...p: Attribute[]): Color;
	/**
	 * Unset resets all escape attributes and clears the output. Usually should
	 * be called after Set().
	 */
	export function Unset(): void;
	/**
	 * Black is a convenient helper function to print with black foreground. A
	 * newline is appended to format by default.
	 */
	export function Black(format: string, ...a: any[]): void;
	/**
	 * Red is a convenient helper function to print with red foreground. A
	 * newline is appended to format by default.
	 */
	export function Red(format: string, ...a: any[]): void;
	/**
	 * Green is a convenient helper function to print with green foreground. A
	 * newline is appended to format by default.
	 */
	export function Green(format: string, ...a: any[]): void;
	/**
	 * Yellow is a convenient helper function to print with yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function Yellow(format: string, ...a: any[]): void;
	/**
	 * Blue is a convenient helper function to print with blue foreground. A
	 * newline is appended to format by default.
	 */
	export function Blue(format: string, ...a: any[]): void;
	/**
	 * Magenta is a convenient helper function to print with magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function Magenta(format: string, ...a: any[]): void;
	/**
	 * Cyan is a convenient helper function to print with cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function Cyan(format: string, ...a: any[]): void;
	/**
	 * White is a convenient helper function to print with white foreground. A
	 * newline is appended to format by default.
	 */
	export function White(format: string, ...a: any[]): void;
	/**
	 * BlackString is a convenient helper function to return a string with black
	 * foreground.
	 */
	export function BlackString(format: string, ...a: any[]): string;
	/**
	 * RedString is a convenient helper function to return a string with red
	 * foreground.
	 */
	export function RedString(format: string, ...a: any[]): string;
	/**
	 * GreenString is a convenient helper function to return a string with green
	 * foreground.
	 */
	export function GreenString(format: string, ...a: any[]): string;
	/**
	 * YellowString is a convenient helper function to return a string with yellow
	 * foreground.
	 */
	export function YellowString(format: string, ...a: any[]): string;
	/**
	 * BlueString is a convenient helper function to return a string with blue
	 * foreground.
	 */
	export function BlueString(format: string, ...a: any[]): string;
	/**
	 * MagentaString is a convenient helper function to return a string with magenta
	 * foreground.
	 */
	export function MagentaString(format: string, ...a: any[]): string;
	/**
	 * CyanString is a convenient helper function to return a string with cyan
	 * foreground.
	 */
	export function CyanString(format: string, ...a: any[]): string;
	/**
	 * WhiteString is a convenient helper function to return a string with white
	 * foreground.
	 */
	export function WhiteString(format: string, ...a: any[]): string;
	/**
	 * HiBlack is a convenient helper function to print with hi-intensity black foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlack(format: string, ...a: any[]): void;
	/**
	 * HiRed is a convenient helper function to print with hi-intensity red foreground. A
	 * newline is appended to format by default.
	 */
	export function HiRed(format: string, ...a: any[]): void;
	/**
	 * HiGreen is a convenient helper function to print with hi-intensity green foreground. A
	 * newline is appended to format by default.
	 */
	export function HiGreen(format: string, ...a: any[]): void;
	/**
	 * HiYellow is a convenient helper function to print with hi-intensity yellow foreground.
	 * A newline is appended to format by default.
	 */
	export function HiYellow(format: string, ...a: any[]): void;
	/**
	 * HiBlue is a convenient helper function to print with hi-intensity blue foreground. A
	 * newline is appended to format by default.
	 */
	export function HiBlue(format: string, ...a: any[]): void;
	/**
	 * HiMagenta is a convenient helper function to print with hi-intensity magenta foreground.
	 * A newline is appended to format by default.
	 */
	export function HiMagenta(format: string, ...a: any[]): void;
	/**
	 * HiCyan is a convenient helper function to print with hi-intensity cyan foreground. A
	 * newline is appended to format by default.
	 */
	export function HiCyan(format: string, ...a: any[]): void;
	/**
	 * HiWhite is a convenient helper function to print with hi-intensity white foreground. A
	 * newline is appended to format by default.
	 */
	export function HiWhite(format: string, ...a: any[]): void;
	/**
	 * HiBlackString is a convenient helper function to return a string with hi-intensity black
	 * foreground.
	 */
	export function HiBlackString(format: string, ...a: any[]): string;
	/**
	 * HiRedString is a convenient helper function to return a string with hi-intensity red
	 * foreground.
	 */
	export function HiRedString(format: string, ...a: any[]): string;
	/**
	 * HiGreenString is a convenient helper function to return a string with hi-intensity green
	 * foreground.
	 */
	export function HiGreenString(format: string, ...a: any[]): string;
	/**
	 * HiYellowString is a convenient helper function to return a string with hi-intensity yellow
	 * foreground.
	 */
	export function HiYellowString(format: string, ...a: any[]): string;
	/**
	 * HiBlueString is a convenient helper function to return a string with hi-intensity blue
	 * foreground.
	 */
	export function HiBlueString(format: string, ...a: any[]): string;
	/**
	 * HiMagentaString is a convenient helper function to return a string with hi-intensity magenta
	 * foreground.
	 */
	export function HiMagentaString(format: string, ...a: any[]): string;
	/**
	 * HiCyanString is a convenient helper function to return a string with hi-intensity cyan
	 * foreground.
	 */
	export function HiCyanString(format: string, ...a: any[]): string;
	/**
	 * HiWhiteString is a convenient helper function to return a string with hi-intensity white
	 * foreground.
	 */
	export function HiWhiteString(format: string, ...a: any[]): string;
}
// END: go:github.com/fatih/color

// MODULE: go:net/url
declare module "go:net/url" {
	/**
	 * Error reports an error and the operation and URL that caused it.
	 */
	export interface Error {
		Op: string;
		URL: string;
		Err: Error | null;
		Unwrap(): Error | null;
		Error(): string;
		Timeout(): boolean;
		Temporary(): boolean;
	}

	/**
	 * A URL represents a parsed URL (technically, a URI reference).
	 * 
	 * The general form represented is:
	 * 
	 * 	[scheme:][//[userinfo@]host][/]path[?query][#fragment]
	 * 
	 * URLs that do not start with a slash after the scheme are interpreted as:
	 * 
	 * 	scheme:opaque[?query][#fragment]
	 * 
	 * The Host field contains the host and port subcomponents of the URL.
	 * When the port is present, it is separated from the host with a colon.
	 * When the host is an IPv6 address, it must be enclosed in square brackets:
	 * "[fe80::1]:80". The [net.JoinHostPort] function combines a host and port
	 * into a string suitable for the Host field, adding square brackets to
	 * the host when necessary.
	 * 
	 * Note that the Path field is stored in decoded form: /%47%6f%2f becomes /Go/.
	 * A consequence is that it is impossible to tell which slashes in the Path were
	 * slashes in the raw URL and which were %2f. This distinction is rarely important,
	 * but when it is, the code should use the [URL.EscapedPath] method, which preserves
	 * the original encoding of Path.
	 * 
	 * The RawPath field is an optional field which is only set when the default
	 * encoding of Path is different from the escaped path. See the EscapedPath method
	 * for more details.
	 * 
	 * URL's String method uses the EscapedPath method to obtain the path.
	 */
	export interface URL {
		Scheme: string;
		Opaque: string;
		User: Userinfo;
		Host: string;
		Path: string;
		RawPath: string;
		OmitHost: boolean;
		ForceQuery: boolean;
		RawQuery: string;
		Fragment: string;
		RawFragment: string;
		/**
		 * EscapedPath returns the escaped form of u.Path.
		 * In general there are multiple possible escaped forms of any path.
		 * EscapedPath returns u.RawPath when it is a valid escaping of u.Path.
		 * Otherwise EscapedPath ignores u.RawPath and computes an escaped
		 * form on its own.
		 * The [URL.String] and [URL.RequestURI] methods use EscapedPath to construct
		 * their results.
		 * In general, code should call EscapedPath instead of
		 * reading u.RawPath directly.
		 */
		EscapedPath(): string;
		/**
		 * EscapedFragment returns the escaped form of u.Fragment.
		 * In general there are multiple possible escaped forms of any fragment.
		 * EscapedFragment returns u.RawFragment when it is a valid escaping of u.Fragment.
		 * Otherwise EscapedFragment ignores u.RawFragment and computes an escaped
		 * form on its own.
		 * The [URL.String] method uses EscapedFragment to construct its result.
		 * In general, code should call EscapedFragment instead of
		 * reading u.RawFragment directly.
		 */
		EscapedFragment(): string;
		/**
		 * String reassembles the [URL] into a valid URL string.
		 * The general form of the result is one of:
		 * 
		 * 	scheme:opaque?query#fragment
		 * 	scheme://userinfo@host/path?query#fragment
		 * 
		 * If u.Opaque is non-empty, String uses the first form;
		 * otherwise it uses the second form.
		 * Any non-ASCII characters in host are escaped.
		 * To obtain the path, String uses u.EscapedPath().
		 * 
		 * In the second form, the following rules apply:
		 *   - if u.Scheme is empty, scheme: is omitted.
		 *   - if u.User is nil, userinfo@ is omitted.
		 *   - if u.Host is empty, host/ is omitted.
		 *   - if u.Scheme and u.Host are empty and u.User is nil,
		 *     the entire scheme://userinfo@host/ is omitted.
		 *   - if u.Host is non-empty and u.Path begins with a /,
		 *     the form host/path does not add its own /.
		 *   - if u.RawQuery is empty, ?query is omitted.
		 *   - if u.Fragment is empty, #fragment is omitted.
		 */
		String(): string;
		/**
		 * Redacted is like [URL.String] but replaces any password with "xxxxx".
		 * Only the password in u.User is redacted.
		 */
		Redacted(): string;
		/**
		 * IsAbs reports whether the [URL] is absolute.
		 * Absolute means that it has a non-empty scheme.
		 */
		IsAbs(): boolean;
		/**
		 * Parse parses a [URL] in the context of the receiver. The provided URL
		 * may be relative or absolute. Parse returns nil, err on parse
		 * failure, otherwise its return value is the same as [URL.ResolveReference].
		 */
		Parse(ref: string): [URL, Error | null];
		/**
		 * ResolveReference resolves a URI reference to an absolute URI from
		 * an absolute base URI u, per RFC 3986 Section 5.2. The URI reference
		 * may be relative or absolute. ResolveReference always returns a new
		 * [URL] instance, even if the returned URL is identical to either the
		 * base or reference. If ref is an absolute URL, then ResolveReference
		 * ignores base and returns a copy of ref.
		 */
		ResolveReference(ref: URL): URL;
		/**
		 * Query parses RawQuery and returns the corresponding values.
		 * It silently discards malformed value pairs.
		 * To check errors use [ParseQuery].
		 */
		Query(): Values;
		/**
		 * RequestURI returns the encoded path?query or opaque?query
		 * string that would be used in an HTTP request for u.
		 */
		RequestURI(): string;
		/**
		 * Hostname returns u.Host, stripping any valid port number if present.
		 * 
		 * If the result is enclosed in square brackets, as literal IPv6 addresses are,
		 * the square brackets are removed from the result.
		 */
		Hostname(): string;
		/**
		 * Port returns the port part of u.Host, without the leading colon.
		 * 
		 * If u.Host doesn't contain a valid numeric port, Port returns an empty string.
		 */
		Port(): string;
		MarshalBinary(): [byte[], Error | null];
		AppendBinary(b: byte[]): [byte[], Error | null];
		UnmarshalBinary(text: byte[]): Error | null;
		/**
		 * JoinPath returns a new [URL] with the provided path elements joined to
		 * any existing path and the resulting path cleaned of any ./ or ../ elements.
		 * Any sequences of multiple / characters will be reduced to a single /.
		 */
		JoinPath(...elem: string[]): URL;
	}

	/**
	 * The Userinfo type is an immutable encapsulation of username and
	 * password details for a [URL]. An existing Userinfo value is guaranteed
	 * to have a username set (potentially empty, as allowed by RFC 2396),
	 * and optionally a password.
	 */
	export interface Userinfo {
		/**
		 * Username returns the username.
		 */
		Username(): string;
		/**
		 * Password returns the password in case it is set, and whether it is set.
		 */
		Password(): [string, boolean];
		/**
		 * String returns the encoded userinfo information in the standard form
		 * of "username[:password]".
		 */
		String(): string;
	}

	/**
	 * QueryUnescape does the inverse transformation of [QueryEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB.
	 * It returns an error if any % is not followed by two hexadecimal
	 * digits.
	 */
	export function QueryUnescape(s: string): string;
	/**
	 * PathUnescape does the inverse transformation of [PathEscape],
	 * converting each 3-byte encoded substring of the form "%AB" into the
	 * hex-decoded byte 0xAB. It returns an error if any % is not followed
	 * by two hexadecimal digits.
	 * 
	 * PathUnescape is identical to [QueryUnescape] except that it does not
	 * unescape '+' to ' ' (space).
	 */
	export function PathUnescape(s: string): string;
	/**
	 * QueryEscape escapes the string so it can be safely placed
	 * inside a [URL] query.
	 */
	export function QueryEscape(s: string): string;
	/**
	 * PathEscape escapes the string so it can be safely placed inside a [URL] path segment,
	 * replacing special characters (including /) with %XX sequences as needed.
	 */
	export function PathEscape(s: string): string;
	/**
	 * User returns a [Userinfo] containing the provided username
	 * and no password set.
	 */
	export function User(username: string): Userinfo;
	/**
	 * UserPassword returns a [Userinfo] containing the provided username
	 * and password.
	 * 
	 * This functionality should only be used with legacy web sites.
	 * RFC 2396 warns that interpreting Userinfo this way
	 * is NOT RECOMMENDED, because the passing of authentication
	 * information in clear text (such as URI) has proven to be a
	 * security risk in almost every case where it has been used.
	 */
	export function UserPassword(username: string, password: string): Userinfo;
	/**
	 * Parse parses a raw url into a [URL] structure.
	 * 
	 * The url may be relative (a path, without a host) or absolute
	 * (starting with a scheme). Trying to parse a hostname and path
	 * without a scheme is invalid but may not necessarily return an
	 * error, due to parsing ambiguities.
	 */
	export function Parse(rawURL: string): URL;
	/**
	 * ParseRequestURI parses a raw url into a [URL] structure. It assumes that
	 * url was received in an HTTP request, so the url is interpreted
	 * only as an absolute URI or an absolute path.
	 * The string url is assumed not to have a #fragment suffix.
	 * (Web browsers strip #fragment before sending the URL to a web server.)
	 */
	export function ParseRequestURI(rawURL: string): URL;
	/**
	 * ParseQuery parses the URL-encoded query string and returns
	 * a map listing the values specified for each key.
	 * ParseQuery always returns a non-nil map containing all the
	 * valid query parameters found; err describes the first decoding error
	 * encountered, if any.
	 * 
	 * Query is expected to be a list of key=value settings separated by ampersands.
	 * A setting without an equals sign is interpreted as a key set to an empty
	 * value.
	 * Settings containing a non-URL-encoded semicolon are considered invalid.
	 */
	export function ParseQuery(query: string): Values;
	/**
	 * JoinPath returns a [URL] string with the provided path elements joined to
	 * the existing path of base and the resulting path cleaned of any ./ or ../ elements.
	 */
	export function JoinPath(base: string, ...elem: string[]): string;
}
// END: go:net/url

// MODULE: go:net/http
declare module "go:net/http" {
    export function ListenAndServe(addr: string, handler: (req: Request, res: Response) => Promise<void> | void): void;
    export function Get(url: string): { Status: string; StatusCode: number; Body: string };
    export function Post(url: string, body: string, contentType?: string): Promise<{ Status: string; StatusCode: number; Body: string }>;
    export function Fetch(url: string): Promise<{ Status: string; StatusCode: number; Body: string }>;

    export interface Request {
        method: string;
        url: string;
        path: string;
        host: string;
        proto: string;
        query: Record<string, string | string[]>;
        headers: Record<string, string | string[]>;
        body(): Promise<string>;
        bodySync(): string;
    }

    export interface Response {
        setHeader(key: string, value: string): void;
        status(code: number): Response;
        write(data: string): Response;
        send(data?: string): void;
        json(data: any): void;
        redirect(url: string, code?: number): void;
    }

    export interface Server {
        close(timeout?: number): void;
    }
}
// END: go:net/http

// MODULE: go:sync
declare module "go:sync" {
    export function Spawn(fn: () => void): void;
    export function Sleep(ms: number): Promise<void>;
    export function Chan<T = any>(buffer?: number): {
        Send(val: T): void;
        Recv(): T;
        TryRecv(): [T, boolean];
        Close(): void;
    };
}
// END: go:sync

// MODULE: go:memory
declare module "go:memory" {
    export function makeShared(name: string, size: number): Uint8Array;
}
// END: go:memory

// MODULE: typego:memory
declare module "typego:memory" {
    export function makeShared(name: string, size: number): { buffer: ArrayBuffer; mutex: any };
    export function stats(): { alloc: number; totalAlloc: number; sys: number; numGC: number };
    export function ptr(val: any): any;
}
// END: typego:memory

// MODULE: go:memory
declare module "go:memory" {
    export function makeShared(name: string, size: number): Uint8Array;
}
// END: go:memory

// MODULE: typego:memory
declare module "typego:memory" {
    export function makeShared(name: string, size: number): { buffer: ArrayBuffer; mutex: any };
    export function stats(): { alloc: number; totalAlloc: number; sys: number; numGC: number };
    export function ptr(val: any): any;
}
// END: typego:memory

// MODULE: typego:worker
declare module "typego:worker" {
    export class Worker {
        constructor(scriptPath: string);
        postMessage(msg: any): void;
        terminate(): void;
        onmessage: (msg: { data: any }) => void;
    };
}
// END: typego:worker
